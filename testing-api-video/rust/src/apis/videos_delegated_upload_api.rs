/*
 * api.video
 *
 * api.video is an API that encodes on the go to facilitate immediate playback, enhancing viewer streaming experiences across multiple devices and platforms. You can stream live or on-demand online videos within minutes.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`d_elete_upload_tokens_upload_token`]
#[derive(Clone, Debug, Default)]
pub struct DEleteUploadTokensUploadTokenParams {
    /// The unique identifier for the upload token you want to delete. Deleting a token will make it so the token can no longer be used for authentication.
    pub upload_token: String
}

/// struct for passing parameters to the method [`g_et_upload_tokens`]
#[derive(Clone, Debug, Default)]
pub struct GEtUploadTokensParams {
    /// Allowed: createdAt, ttl. You can use these to sort by when a token was created, or how much longer the token will be active (ttl - time to live). Date and time is presented in ISO-8601 format.
    pub sort_by: Option<String>,
    /// Allowed: asc, desc. Ascending is 0-9 or A-Z. Descending is 9-0 or Z-A.
    pub sort_order: Option<String>,
    /// Choose the number of search results to return per page. Minimum value: 1
    pub current_page: Option<i32>,
    /// Results per page. Allowed values 1-100, default is 25.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`g_et_upload_tokens_upload_token`]
#[derive(Clone, Debug, Default)]
pub struct GEtUploadTokensUploadTokenParams {
    /// The unique identifier for the token you want information about.
    pub upload_token: String
}

/// struct for passing parameters to the method [`p_ost_upload`]
#[derive(Clone, Debug, Default)]
pub struct POstUploadParams {
    /// The unique identifier for the token you want to use to upload a video.
    pub token: String,
    /// The path to the video you want to upload.
    pub file: std::path::PathBuf,
    /// Content-Range represents the range of bytes that will be returned as a result of the request. Byte ranges are inclusive, meaning that bytes 0-999 represents the first 1000 bytes in a file or object.
    pub content_range: Option<String>,
    /// The video id returned by the first call to this endpoint in a large video upload scenario.
    pub video_id: Option<String>
}

/// struct for passing parameters to the method [`p_ost_upload_tokens`]
#[derive(Clone, Debug, Default)]
pub struct POstUploadTokensParams {
    pub token_create_payload: Option<crate::models::TokenCreatePayload>
}


/// struct for typed errors of method [`d_elete_upload_tokens_upload_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEleteUploadTokensUploadTokenError {
    Status404(crate::models::NotFound),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_upload_tokens`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtUploadTokensError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_upload_tokens_upload_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtUploadTokensUploadTokenError {
    Status404(crate::models::NotFound),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_upload`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstUploadError {
    Status400(crate::models::BadRequest),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_upload_tokens`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstUploadTokensError {
    Status400(crate::models::BadRequest),
    UnknownValue(serde_json::Value),
}


/// Delete an existing upload token. This is especially useful for tokens you may have created that do not expire.
pub async fn d_elete_upload_tokens_upload_token(configuration: &configuration::Configuration, params: DEleteUploadTokensUploadTokenParams) -> Result<(), Error<DEleteUploadTokensUploadTokenError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let upload_token = params.upload_token;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/upload-tokens/{uploadToken}", local_var_configuration.base_path, uploadToken=crate::apis::urlencode(upload_token));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DEleteUploadTokensUploadTokenError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// A delegated token is used to allow secure uploads without exposing your API key. Use this endpoint to retrieve a list of all currently active delegated tokens. Tutorials using [delegated upload](https://api.video/blog/endpoints/delegated-upload).
pub async fn g_et_upload_tokens(configuration: &configuration::Configuration, params: GEtUploadTokensParams) -> Result<crate::models::TokenListResponse, Error<GEtUploadTokensError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sort_by = params.sort_by;
    let sort_order = params.sort_order;
    let current_page = params.current_page;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/upload-tokens", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = sort_by {
        local_var_req_builder = local_var_req_builder.query(&[("sortBy", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_order {
        local_var_req_builder = local_var_req_builder.query(&[("sortOrder", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = current_page {
        local_var_req_builder = local_var_req_builder.query(&[("currentPage", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("pageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtUploadTokensError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// You can retrieve details about a specific upload token if you have the unique identifier for the upload token. Add it in the path of the endpoint. Details include time-to-live (ttl), when the token was created, and when it will expire.
pub async fn g_et_upload_tokens_upload_token(configuration: &configuration::Configuration, params: GEtUploadTokensUploadTokenParams) -> Result<crate::models::UploadToken, Error<GEtUploadTokensUploadTokenError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let upload_token = params.upload_token;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/upload-tokens/{uploadToken}", local_var_configuration.base_path, uploadToken=crate::apis::urlencode(upload_token));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtUploadTokensUploadTokenError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// When given a token, anyone can upload a file to the URI `https://ws.api.video/upload?token=<tokenId>`.  Example with cURL:  ```curl $ curl  --request POST --url 'https://ws.api.video/upload?token=toXXX'  --header 'content-type: multipart/form-data'  -F file=@video.mp4 ```  Or in an HTML form, with a little JavaScript to convert the form into JSON: ```html <!--form for user interaction--> <form name=\"videoUploadForm\" >   <label for=video>Video:</label>   <input type=file name=source/><br/>   <input value=\"Submit\" type=\"submit\"> </form> <div></div> <!--JS takes the form data      uses FormData to turn the response into JSON.     then uses POST to upload the video file.     Update the token parameter in the url to your upload token.     --> <script>    var form = document.forms.namedItem(\"videoUploadForm\");     form.addEventListener('submit', function(ev) {   ev.preventDefault();      var oOutput = document.querySelector(\"div\"),          oData = new FormData(form);      var oReq = new XMLHttpRequest();         oReq.open(\"POST\", \"https://ws.api.video/upload?token=toXXX\", true);      oReq.send(oData);   oReq.onload = function(oEvent) {        if (oReq.status ==201) {          oOutput.innerHTML = \"Your video is uploaded!<br/>\"  + oReq.response;        } else {          oOutput.innerHTML = \"Error \" + oReq.status + \" occurred when trying to upload your file.<br />\";        }      };    }, false);  </script> ```   ### Dealing with large files  We have created a <a href='https://api.video/blog/tutorials/uploading-large-files-with-javascript'>tutorial</a> to walk through the steps required.
pub async fn p_ost_upload(configuration: &configuration::Configuration, params: POstUploadParams) -> Result<crate::models::Video, Error<POstUploadError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let file = params.file;
    let content_range = params.content_range;
    let video_id = params.video_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/upload", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("token", &token.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = content_range {
        local_var_req_builder = local_var_req_builder.header("Content-Range", local_var_param_value.to_string());
    }
    let mut local_var_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'file' parameter
    if let Some(local_var_param_value) = video_id {
        local_var_form = local_var_form.text("videoId", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.multipart(local_var_form);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstUploadError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Use this endpoint to generate an upload token. You can use this token to authenticate video uploads while keeping your API key safe. Tutorials using [delegated upload](https://api.video/blog/endpoints/delegated-upload).
pub async fn p_ost_upload_tokens(configuration: &configuration::Configuration, params: POstUploadTokensParams) -> Result<crate::models::UploadToken, Error<POstUploadTokensError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token_create_payload = params.token_create_payload;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/upload-tokens", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&token_create_payload);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstUploadTokensError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

