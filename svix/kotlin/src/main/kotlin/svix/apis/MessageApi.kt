/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package svix.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.outmatchapi.svix.HTTPValidationError
import com.outmatchapi.svix.HttpErrorOut
import com.outmatchapi.svix.ListResponseMessageOut
import com.outmatchapi.svix.MessageIn
import com.outmatchapi.svix.MessageOut

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import svix.infrastructure.ApiClient
import svix.infrastructure.ApiResponse
import svix.infrastructure.ClientException
import svix.infrastructure.ClientError
import svix.infrastructure.ServerException
import svix.infrastructure.ServerError
import svix.infrastructure.MultiValueMap
import svix.infrastructure.PartConfig
import svix.infrastructure.RequestConfig
import svix.infrastructure.RequestMethod
import svix.infrastructure.ResponseType
import svix.infrastructure.Success
import svix.infrastructure.toMultiValue

class MessageApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * Create Message
     * Creates a new message and dispatches it to all of the application&#39;s endpoints.  The &#x60;eventId&#x60; is an optional custom unique ID. It&#39;s verified to be unique only up to a day, after that no verification will be made. If a message with the same &#x60;eventId&#x60; already exists for any application in your environment, a 409 conflict error will be returned.  The &#x60;eventType&#x60; indicates the type and schema of the event. All messages of a certain &#x60;eventType&#x60; are expected to have the same schema. Endpoints can choose to only listen to specific event types. Messages can also have &#x60;channels&#x60;, which similar to event types let endpoints filter by them. Unlike event types, messages can have multiple channels, and channels don&#39;t imply a specific message content or schema.  The &#x60;payload&#x60; property is the webhook&#39;s body (the actual webhook message). Svix supports payload sizes of up to ~350kb, though it&#39;s generally a good idea to keep webhook payloads small, probably no larger than 40kb.
     * @param appId 
     * @param messageIn 
     * @param withContent  (optional, default to true)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return MessageOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createMessageApiV1AppAppIdMsgPost(appId: kotlin.String, messageIn: MessageIn, withContent: kotlin.Boolean? = true, idempotencyKey: kotlin.String? = null) : MessageOut = withContext(Dispatchers.IO) {
        val localVarResponse = createMessageApiV1AppAppIdMsgPostWithHttpInfo(appId = appId, messageIn = messageIn, withContent = withContent, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MessageOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create Message
     * Creates a new message and dispatches it to all of the application&#39;s endpoints.  The &#x60;eventId&#x60; is an optional custom unique ID. It&#39;s verified to be unique only up to a day, after that no verification will be made. If a message with the same &#x60;eventId&#x60; already exists for any application in your environment, a 409 conflict error will be returned.  The &#x60;eventType&#x60; indicates the type and schema of the event. All messages of a certain &#x60;eventType&#x60; are expected to have the same schema. Endpoints can choose to only listen to specific event types. Messages can also have &#x60;channels&#x60;, which similar to event types let endpoints filter by them. Unlike event types, messages can have multiple channels, and channels don&#39;t imply a specific message content or schema.  The &#x60;payload&#x60; property is the webhook&#39;s body (the actual webhook message). Svix supports payload sizes of up to ~350kb, though it&#39;s generally a good idea to keep webhook payloads small, probably no larger than 40kb.
     * @param appId 
     * @param messageIn 
     * @param withContent  (optional, default to true)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<MessageOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun createMessageApiV1AppAppIdMsgPostWithHttpInfo(appId: kotlin.String, messageIn: MessageIn, withContent: kotlin.Boolean?, idempotencyKey: kotlin.String?) : ApiResponse<MessageOut?> = withContext(Dispatchers.IO) {
        val localVariableConfig = createMessageApiV1AppAppIdMsgPostRequestConfig(appId = appId, messageIn = messageIn, withContent = withContent, idempotencyKey = idempotencyKey)

        return@withContext request<MessageIn, MessageOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createMessageApiV1AppAppIdMsgPost
     *
     * @param appId 
     * @param messageIn 
     * @param withContent  (optional, default to true)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun createMessageApiV1AppAppIdMsgPostRequestConfig(appId: kotlin.String, messageIn: MessageIn, withContent: kotlin.Boolean?, idempotencyKey: kotlin.String?) : RequestConfig<MessageIn> {
        val localVariableBody = messageIn
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (withContent != null) {
                    put("with_content", listOf(withContent.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/app/{app_id}/msg/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get Message
     * Get a message by its ID or eventID.
     * @param msgId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return MessageOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getMessageApiV1AppAppIdMsgMsgIdGet(msgId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String? = null) : MessageOut = withContext(Dispatchers.IO) {
        val localVarResponse = getMessageApiV1AppAppIdMsgMsgIdGetWithHttpInfo(msgId = msgId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MessageOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Message
     * Get a message by its ID or eventID.
     * @param msgId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<MessageOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getMessageApiV1AppAppIdMsgMsgIdGetWithHttpInfo(msgId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : ApiResponse<MessageOut?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getMessageApiV1AppAppIdMsgMsgIdGetRequestConfig(msgId = msgId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext request<Unit, MessageOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMessageApiV1AppAppIdMsgMsgIdGet
     *
     * @param msgId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun getMessageApiV1AppAppIdMsgMsgIdGetRequestConfig(msgId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/app/{app_id}/msg/{msg_id}/".replace("{"+"msg_id"+"}", encodeURIComponent(msgId.toString())).replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List Messages
     * List all of the application&#39;s messages.  The &#x60;before&#x60; parameter lets you filter all items created before a certain date and is ignored if an iterator is passed. The &#x60;after&#x60; parameter lets you filter all items created after a certain date and is ignored if an iterator is passed. &#x60;before&#x60; and &#x60;after&#x60; cannot be used simultaneously.
     * @param appId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param eventTypes  (optional)
     * @param channel  (optional)
     * @param before  (optional)
     * @param after  (optional)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ListResponseMessageOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listMessagesApiV1AppAppIdMsgGet(appId: kotlin.String, iterator: kotlin.String? = null, limit: kotlin.Int? = 50, eventTypes: kotlin.collections.List<kotlin.String>? = null, channel: kotlin.String? = null, before: java.time.OffsetDateTime? = null, after: java.time.OffsetDateTime? = null, idempotencyKey: kotlin.String? = null) : ListResponseMessageOut = withContext(Dispatchers.IO) {
        val localVarResponse = listMessagesApiV1AppAppIdMsgGetWithHttpInfo(appId = appId, iterator = iterator, limit = limit, eventTypes = eventTypes, channel = channel, before = before, after = after, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListResponseMessageOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List Messages
     * List all of the application&#39;s messages.  The &#x60;before&#x60; parameter lets you filter all items created before a certain date and is ignored if an iterator is passed. The &#x60;after&#x60; parameter lets you filter all items created after a certain date and is ignored if an iterator is passed. &#x60;before&#x60; and &#x60;after&#x60; cannot be used simultaneously.
     * @param appId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param eventTypes  (optional)
     * @param channel  (optional)
     * @param before  (optional)
     * @param after  (optional)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<ListResponseMessageOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun listMessagesApiV1AppAppIdMsgGetWithHttpInfo(appId: kotlin.String, iterator: kotlin.String?, limit: kotlin.Int?, eventTypes: kotlin.collections.List<kotlin.String>?, channel: kotlin.String?, before: java.time.OffsetDateTime?, after: java.time.OffsetDateTime?, idempotencyKey: kotlin.String?) : ApiResponse<ListResponseMessageOut?> = withContext(Dispatchers.IO) {
        val localVariableConfig = listMessagesApiV1AppAppIdMsgGetRequestConfig(appId = appId, iterator = iterator, limit = limit, eventTypes = eventTypes, channel = channel, before = before, after = after, idempotencyKey = idempotencyKey)

        return@withContext request<Unit, ListResponseMessageOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listMessagesApiV1AppAppIdMsgGet
     *
     * @param appId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param eventTypes  (optional)
     * @param channel  (optional)
     * @param before  (optional)
     * @param after  (optional)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun listMessagesApiV1AppAppIdMsgGetRequestConfig(appId: kotlin.String, iterator: kotlin.String?, limit: kotlin.Int?, eventTypes: kotlin.collections.List<kotlin.String>?, channel: kotlin.String?, before: java.time.OffsetDateTime?, after: java.time.OffsetDateTime?, idempotencyKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (iterator != null) {
                    put("iterator", listOf(iterator.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (eventTypes != null) {
                    put("event_types", toMultiValue(eventTypes.toList(), "multi"))
                }
                if (channel != null) {
                    put("channel", listOf(channel.toString()))
                }
                if (before != null) {
                    put("before", listOf(parseDateToQueryString(before)))
                }
                if (after != null) {
                    put("after", listOf(parseDateToQueryString(after)))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/app/{app_id}/msg/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
