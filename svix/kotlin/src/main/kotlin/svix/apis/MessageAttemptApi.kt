/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package svix.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.outmatchapi.svix.HTTPValidationError
import com.outmatchapi.svix.HttpErrorOut
import com.outmatchapi.svix.ListResponseEndpointMessageOut
import com.outmatchapi.svix.ListResponseMessageAttemptEndpointOut
import com.outmatchapi.svix.ListResponseMessageAttemptOut
import com.outmatchapi.svix.ListResponseMessageEndpointOut
import com.outmatchapi.svix.MessageAttemptOut
import com.outmatchapi.svix.MessageStatus
import com.outmatchapi.svix.StatusCodeClass

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import svix.infrastructure.ApiClient
import svix.infrastructure.ApiResponse
import svix.infrastructure.ClientException
import svix.infrastructure.ClientError
import svix.infrastructure.ServerException
import svix.infrastructure.ServerError
import svix.infrastructure.MultiValueMap
import svix.infrastructure.PartConfig
import svix.infrastructure.RequestConfig
import svix.infrastructure.RequestMethod
import svix.infrastructure.ResponseType
import svix.infrastructure.Success
import svix.infrastructure.toMultiValue

class MessageAttemptApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * Get Attempt
     * &#x60;msg_id&#x60;: Use a message id or a message &#x60;eventId&#x60;
     * @param attemptId 
     * @param msgId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return MessageAttemptOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getAttemptApiV1AppAppIdMsgMsgIdAttemptAttemptIdGet(attemptId: kotlin.String, msgId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String? = null) : MessageAttemptOut = withContext(Dispatchers.IO) {
        val localVarResponse = getAttemptApiV1AppAppIdMsgMsgIdAttemptAttemptIdGetWithHttpInfo(attemptId = attemptId, msgId = msgId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MessageAttemptOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Attempt
     * &#x60;msg_id&#x60;: Use a message id or a message &#x60;eventId&#x60;
     * @param attemptId 
     * @param msgId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<MessageAttemptOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getAttemptApiV1AppAppIdMsgMsgIdAttemptAttemptIdGetWithHttpInfo(attemptId: kotlin.String, msgId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : ApiResponse<MessageAttemptOut?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getAttemptApiV1AppAppIdMsgMsgIdAttemptAttemptIdGetRequestConfig(attemptId = attemptId, msgId = msgId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext request<Unit, MessageAttemptOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAttemptApiV1AppAppIdMsgMsgIdAttemptAttemptIdGet
     *
     * @param attemptId 
     * @param msgId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun getAttemptApiV1AppAppIdMsgMsgIdAttemptAttemptIdGetRequestConfig(attemptId: kotlin.String, msgId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/app/{app_id}/msg/{msg_id}/attempt/{attempt_id}/".replace("{"+"attempt_id"+"}", encodeURIComponent(attemptId.toString())).replace("{"+"msg_id"+"}", encodeURIComponent(msgId.toString())).replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List Attempted Destinations
     * &#x60;msg_id&#x60;: Use a message id or a message &#x60;eventId&#x60;
     * @param msgId 
     * @param appId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ListResponseMessageEndpointOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listAttemptedDestinationsApiV1AppAppIdMsgMsgIdEndpointGet(msgId: kotlin.String, appId: kotlin.String, iterator: kotlin.String? = null, limit: kotlin.Int? = 50, idempotencyKey: kotlin.String? = null) : ListResponseMessageEndpointOut = withContext(Dispatchers.IO) {
        val localVarResponse = listAttemptedDestinationsApiV1AppAppIdMsgMsgIdEndpointGetWithHttpInfo(msgId = msgId, appId = appId, iterator = iterator, limit = limit, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListResponseMessageEndpointOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List Attempted Destinations
     * &#x60;msg_id&#x60;: Use a message id or a message &#x60;eventId&#x60;
     * @param msgId 
     * @param appId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<ListResponseMessageEndpointOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun listAttemptedDestinationsApiV1AppAppIdMsgMsgIdEndpointGetWithHttpInfo(msgId: kotlin.String, appId: kotlin.String, iterator: kotlin.String?, limit: kotlin.Int?, idempotencyKey: kotlin.String?) : ApiResponse<ListResponseMessageEndpointOut?> = withContext(Dispatchers.IO) {
        val localVariableConfig = listAttemptedDestinationsApiV1AppAppIdMsgMsgIdEndpointGetRequestConfig(msgId = msgId, appId = appId, iterator = iterator, limit = limit, idempotencyKey = idempotencyKey)

        return@withContext request<Unit, ListResponseMessageEndpointOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listAttemptedDestinationsApiV1AppAppIdMsgMsgIdEndpointGet
     *
     * @param msgId 
     * @param appId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun listAttemptedDestinationsApiV1AppAppIdMsgMsgIdEndpointGetRequestConfig(msgId: kotlin.String, appId: kotlin.String, iterator: kotlin.String?, limit: kotlin.Int?, idempotencyKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (iterator != null) {
                    put("iterator", listOf(iterator.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/app/{app_id}/msg/{msg_id}/endpoint/".replace("{"+"msg_id"+"}", encodeURIComponent(msgId.toString())).replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List Attempted Messages
     * List messages for a particular endpoint. Additionally includes metadata about the latest message attempt.  The &#x60;before&#x60; parameter lets you filter all items created before a certain date and is ignored if an iterator is passed.
     * @param endpointId 
     * @param appId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param channel  (optional)
     * @param status  (optional)
     * @param before  (optional)
     * @param after  (optional)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ListResponseEndpointMessageOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listAttemptedMessagesApiV1AppAppIdEndpointEndpointIdMsgGet(endpointId: kotlin.String, appId: kotlin.String, iterator: kotlin.String? = null, limit: kotlin.Int? = 50, channel: kotlin.String? = null, status: MessageStatus? = null, before: java.time.OffsetDateTime? = null, after: java.time.OffsetDateTime? = null, idempotencyKey: kotlin.String? = null) : ListResponseEndpointMessageOut = withContext(Dispatchers.IO) {
        val localVarResponse = listAttemptedMessagesApiV1AppAppIdEndpointEndpointIdMsgGetWithHttpInfo(endpointId = endpointId, appId = appId, iterator = iterator, limit = limit, channel = channel, status = status, before = before, after = after, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListResponseEndpointMessageOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List Attempted Messages
     * List messages for a particular endpoint. Additionally includes metadata about the latest message attempt.  The &#x60;before&#x60; parameter lets you filter all items created before a certain date and is ignored if an iterator is passed.
     * @param endpointId 
     * @param appId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param channel  (optional)
     * @param status  (optional)
     * @param before  (optional)
     * @param after  (optional)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<ListResponseEndpointMessageOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun listAttemptedMessagesApiV1AppAppIdEndpointEndpointIdMsgGetWithHttpInfo(endpointId: kotlin.String, appId: kotlin.String, iterator: kotlin.String?, limit: kotlin.Int?, channel: kotlin.String?, status: MessageStatus?, before: java.time.OffsetDateTime?, after: java.time.OffsetDateTime?, idempotencyKey: kotlin.String?) : ApiResponse<ListResponseEndpointMessageOut?> = withContext(Dispatchers.IO) {
        val localVariableConfig = listAttemptedMessagesApiV1AppAppIdEndpointEndpointIdMsgGetRequestConfig(endpointId = endpointId, appId = appId, iterator = iterator, limit = limit, channel = channel, status = status, before = before, after = after, idempotencyKey = idempotencyKey)

        return@withContext request<Unit, ListResponseEndpointMessageOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listAttemptedMessagesApiV1AppAppIdEndpointEndpointIdMsgGet
     *
     * @param endpointId 
     * @param appId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param channel  (optional)
     * @param status  (optional)
     * @param before  (optional)
     * @param after  (optional)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun listAttemptedMessagesApiV1AppAppIdEndpointEndpointIdMsgGetRequestConfig(endpointId: kotlin.String, appId: kotlin.String, iterator: kotlin.String?, limit: kotlin.Int?, channel: kotlin.String?, status: MessageStatus?, before: java.time.OffsetDateTime?, after: java.time.OffsetDateTime?, idempotencyKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (iterator != null) {
                    put("iterator", listOf(iterator.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (channel != null) {
                    put("channel", listOf(channel.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (before != null) {
                    put("before", listOf(parseDateToQueryString(before)))
                }
                if (after != null) {
                    put("after", listOf(parseDateToQueryString(after)))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/app/{app_id}/endpoint/{endpoint_id}/msg/".replace("{"+"endpoint_id"+"}", encodeURIComponent(endpointId.toString())).replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List Attempts
     * Deprecated: Please use \&quot;List Attempts by Endpoint\&quot; and \&quot;List Attempts by Msg\&quot; instead.  &#x60;msg_id&#x60;: Use a message id or a message &#x60;eventId&#x60;
     * @param appId 
     * @param msgId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param endpointId  (optional)
     * @param eventTypes  (optional)
     * @param channel  (optional)
     * @param status  (optional)
     * @param before  (optional)
     * @param after  (optional)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ListResponseMessageAttemptOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    suspend fun listAttemptsApiV1AppAppIdMsgMsgIdAttemptGet(appId: kotlin.String, msgId: kotlin.String, iterator: kotlin.String? = null, limit: kotlin.Int? = 50, endpointId: kotlin.String? = null, eventTypes: kotlin.collections.List<kotlin.String>? = null, channel: kotlin.String? = null, status: MessageStatus? = null, before: java.time.OffsetDateTime? = null, after: java.time.OffsetDateTime? = null, idempotencyKey: kotlin.String? = null) : ListResponseMessageAttemptOut = withContext(Dispatchers.IO) {
        @Suppress("DEPRECATION")
        val localVarResponse = listAttemptsApiV1AppAppIdMsgMsgIdAttemptGetWithHttpInfo(appId = appId, msgId = msgId, iterator = iterator, limit = limit, endpointId = endpointId, eventTypes = eventTypes, channel = channel, status = status, before = before, after = after, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListResponseMessageAttemptOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List Attempts
     * Deprecated: Please use \&quot;List Attempts by Endpoint\&quot; and \&quot;List Attempts by Msg\&quot; instead.  &#x60;msg_id&#x60;: Use a message id or a message &#x60;eventId&#x60;
     * @param appId 
     * @param msgId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param endpointId  (optional)
     * @param eventTypes  (optional)
     * @param channel  (optional)
     * @param status  (optional)
     * @param before  (optional)
     * @param after  (optional)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<ListResponseMessageAttemptOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    suspend fun listAttemptsApiV1AppAppIdMsgMsgIdAttemptGetWithHttpInfo(appId: kotlin.String, msgId: kotlin.String, iterator: kotlin.String?, limit: kotlin.Int?, endpointId: kotlin.String?, eventTypes: kotlin.collections.List<kotlin.String>?, channel: kotlin.String?, status: MessageStatus?, before: java.time.OffsetDateTime?, after: java.time.OffsetDateTime?, idempotencyKey: kotlin.String?) : ApiResponse<ListResponseMessageAttemptOut?> = withContext(Dispatchers.IO) {
        @Suppress("DEPRECATION")
        val localVariableConfig = listAttemptsApiV1AppAppIdMsgMsgIdAttemptGetRequestConfig(appId = appId, msgId = msgId, iterator = iterator, limit = limit, endpointId = endpointId, eventTypes = eventTypes, channel = channel, status = status, before = before, after = after, idempotencyKey = idempotencyKey)

        return@withContext request<Unit, ListResponseMessageAttemptOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listAttemptsApiV1AppAppIdMsgMsgIdAttemptGet
     *
     * @param appId 
     * @param msgId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param endpointId  (optional)
     * @param eventTypes  (optional)
     * @param channel  (optional)
     * @param status  (optional)
     * @param before  (optional)
     * @param after  (optional)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    @Deprecated(message = "This operation is deprecated.")
    fun listAttemptsApiV1AppAppIdMsgMsgIdAttemptGetRequestConfig(appId: kotlin.String, msgId: kotlin.String, iterator: kotlin.String?, limit: kotlin.Int?, endpointId: kotlin.String?, eventTypes: kotlin.collections.List<kotlin.String>?, channel: kotlin.String?, status: MessageStatus?, before: java.time.OffsetDateTime?, after: java.time.OffsetDateTime?, idempotencyKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (iterator != null) {
                    put("iterator", listOf(iterator.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (endpointId != null) {
                    put("endpoint_id", listOf(endpointId.toString()))
                }
                if (eventTypes != null) {
                    put("event_types", toMultiValue(eventTypes.toList(), "multi"))
                }
                if (channel != null) {
                    put("channel", listOf(channel.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (before != null) {
                    put("before", listOf(parseDateToQueryString(before)))
                }
                if (after != null) {
                    put("after", listOf(parseDateToQueryString(after)))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/app/{app_id}/msg/{msg_id}/attempt/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())).replace("{"+"msg_id"+"}", encodeURIComponent(msgId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List Attempts By Endpoint
     * List attempts by endpoint id
     * @param appId 
     * @param endpointId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param status  (optional)
     * @param statusCodeClass  (optional)
     * @param eventTypes  (optional)
     * @param channel  (optional)
     * @param before  (optional)
     * @param after  (optional)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ListResponseMessageAttemptOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listAttemptsByEndpointApiV1AppAppIdAttemptEndpointEndpointIdGet(appId: kotlin.String, endpointId: kotlin.String, iterator: kotlin.String? = null, limit: kotlin.Int? = 50, status: MessageStatus? = null, statusCodeClass: StatusCodeClass? = null, eventTypes: kotlin.collections.List<kotlin.String>? = null, channel: kotlin.String? = null, before: java.time.OffsetDateTime? = null, after: java.time.OffsetDateTime? = null, idempotencyKey: kotlin.String? = null) : ListResponseMessageAttemptOut = withContext(Dispatchers.IO) {
        val localVarResponse = listAttemptsByEndpointApiV1AppAppIdAttemptEndpointEndpointIdGetWithHttpInfo(appId = appId, endpointId = endpointId, iterator = iterator, limit = limit, status = status, statusCodeClass = statusCodeClass, eventTypes = eventTypes, channel = channel, before = before, after = after, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListResponseMessageAttemptOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List Attempts By Endpoint
     * List attempts by endpoint id
     * @param appId 
     * @param endpointId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param status  (optional)
     * @param statusCodeClass  (optional)
     * @param eventTypes  (optional)
     * @param channel  (optional)
     * @param before  (optional)
     * @param after  (optional)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<ListResponseMessageAttemptOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun listAttemptsByEndpointApiV1AppAppIdAttemptEndpointEndpointIdGetWithHttpInfo(appId: kotlin.String, endpointId: kotlin.String, iterator: kotlin.String?, limit: kotlin.Int?, status: MessageStatus?, statusCodeClass: StatusCodeClass?, eventTypes: kotlin.collections.List<kotlin.String>?, channel: kotlin.String?, before: java.time.OffsetDateTime?, after: java.time.OffsetDateTime?, idempotencyKey: kotlin.String?) : ApiResponse<ListResponseMessageAttemptOut?> = withContext(Dispatchers.IO) {
        val localVariableConfig = listAttemptsByEndpointApiV1AppAppIdAttemptEndpointEndpointIdGetRequestConfig(appId = appId, endpointId = endpointId, iterator = iterator, limit = limit, status = status, statusCodeClass = statusCodeClass, eventTypes = eventTypes, channel = channel, before = before, after = after, idempotencyKey = idempotencyKey)

        return@withContext request<Unit, ListResponseMessageAttemptOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listAttemptsByEndpointApiV1AppAppIdAttemptEndpointEndpointIdGet
     *
     * @param appId 
     * @param endpointId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param status  (optional)
     * @param statusCodeClass  (optional)
     * @param eventTypes  (optional)
     * @param channel  (optional)
     * @param before  (optional)
     * @param after  (optional)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun listAttemptsByEndpointApiV1AppAppIdAttemptEndpointEndpointIdGetRequestConfig(appId: kotlin.String, endpointId: kotlin.String, iterator: kotlin.String?, limit: kotlin.Int?, status: MessageStatus?, statusCodeClass: StatusCodeClass?, eventTypes: kotlin.collections.List<kotlin.String>?, channel: kotlin.String?, before: java.time.OffsetDateTime?, after: java.time.OffsetDateTime?, idempotencyKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (iterator != null) {
                    put("iterator", listOf(iterator.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (statusCodeClass != null) {
                    put("status_code_class", listOf(statusCodeClass.toString()))
                }
                if (eventTypes != null) {
                    put("event_types", toMultiValue(eventTypes.toList(), "multi"))
                }
                if (channel != null) {
                    put("channel", listOf(channel.toString()))
                }
                if (before != null) {
                    put("before", listOf(parseDateToQueryString(before)))
                }
                if (after != null) {
                    put("after", listOf(parseDateToQueryString(after)))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/app/{app_id}/attempt/endpoint/{endpoint_id}/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())).replace("{"+"endpoint_id"+"}", encodeURIComponent(endpointId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List Attempts By Msg
     * List attempts by message id
     * @param appId 
     * @param msgId 
     * @param endpointId  (optional)
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param status  (optional)
     * @param statusCodeClass  (optional)
     * @param eventTypes  (optional)
     * @param channel  (optional)
     * @param before  (optional)
     * @param after  (optional)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ListResponseMessageAttemptOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listAttemptsByMsgApiV1AppAppIdAttemptMsgMsgIdGet(appId: kotlin.String, msgId: kotlin.String, endpointId: kotlin.String? = null, iterator: kotlin.String? = null, limit: kotlin.Int? = 50, status: MessageStatus? = null, statusCodeClass: StatusCodeClass? = null, eventTypes: kotlin.collections.List<kotlin.String>? = null, channel: kotlin.String? = null, before: java.time.OffsetDateTime? = null, after: java.time.OffsetDateTime? = null, idempotencyKey: kotlin.String? = null) : ListResponseMessageAttemptOut = withContext(Dispatchers.IO) {
        val localVarResponse = listAttemptsByMsgApiV1AppAppIdAttemptMsgMsgIdGetWithHttpInfo(appId = appId, msgId = msgId, endpointId = endpointId, iterator = iterator, limit = limit, status = status, statusCodeClass = statusCodeClass, eventTypes = eventTypes, channel = channel, before = before, after = after, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListResponseMessageAttemptOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List Attempts By Msg
     * List attempts by message id
     * @param appId 
     * @param msgId 
     * @param endpointId  (optional)
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param status  (optional)
     * @param statusCodeClass  (optional)
     * @param eventTypes  (optional)
     * @param channel  (optional)
     * @param before  (optional)
     * @param after  (optional)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<ListResponseMessageAttemptOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun listAttemptsByMsgApiV1AppAppIdAttemptMsgMsgIdGetWithHttpInfo(appId: kotlin.String, msgId: kotlin.String, endpointId: kotlin.String?, iterator: kotlin.String?, limit: kotlin.Int?, status: MessageStatus?, statusCodeClass: StatusCodeClass?, eventTypes: kotlin.collections.List<kotlin.String>?, channel: kotlin.String?, before: java.time.OffsetDateTime?, after: java.time.OffsetDateTime?, idempotencyKey: kotlin.String?) : ApiResponse<ListResponseMessageAttemptOut?> = withContext(Dispatchers.IO) {
        val localVariableConfig = listAttemptsByMsgApiV1AppAppIdAttemptMsgMsgIdGetRequestConfig(appId = appId, msgId = msgId, endpointId = endpointId, iterator = iterator, limit = limit, status = status, statusCodeClass = statusCodeClass, eventTypes = eventTypes, channel = channel, before = before, after = after, idempotencyKey = idempotencyKey)

        return@withContext request<Unit, ListResponseMessageAttemptOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listAttemptsByMsgApiV1AppAppIdAttemptMsgMsgIdGet
     *
     * @param appId 
     * @param msgId 
     * @param endpointId  (optional)
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param status  (optional)
     * @param statusCodeClass  (optional)
     * @param eventTypes  (optional)
     * @param channel  (optional)
     * @param before  (optional)
     * @param after  (optional)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun listAttemptsByMsgApiV1AppAppIdAttemptMsgMsgIdGetRequestConfig(appId: kotlin.String, msgId: kotlin.String, endpointId: kotlin.String?, iterator: kotlin.String?, limit: kotlin.Int?, status: MessageStatus?, statusCodeClass: StatusCodeClass?, eventTypes: kotlin.collections.List<kotlin.String>?, channel: kotlin.String?, before: java.time.OffsetDateTime?, after: java.time.OffsetDateTime?, idempotencyKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (endpointId != null) {
                    put("endpoint_id", listOf(endpointId.toString()))
                }
                if (iterator != null) {
                    put("iterator", listOf(iterator.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (statusCodeClass != null) {
                    put("status_code_class", listOf(statusCodeClass.toString()))
                }
                if (eventTypes != null) {
                    put("event_types", toMultiValue(eventTypes.toList(), "multi"))
                }
                if (channel != null) {
                    put("channel", listOf(channel.toString()))
                }
                if (before != null) {
                    put("before", listOf(parseDateToQueryString(before)))
                }
                if (after != null) {
                    put("after", listOf(parseDateToQueryString(after)))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/app/{app_id}/attempt/msg/{msg_id}/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())).replace("{"+"msg_id"+"}", encodeURIComponent(msgId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List Attempts For Endpoint
     * DEPRECATED: please use list_attempts with endpoint_id as a query parameter instead.  List the message attempts for a particular endpoint.  Returning the endpoint.  The &#x60;before&#x60; parameter lets you filter all items created before a certain date and is ignored if an iterator is passed.
     * @param msgId 
     * @param appId 
     * @param endpointId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param eventTypes  (optional)
     * @param channel  (optional)
     * @param status  (optional)
     * @param before  (optional)
     * @param after  (optional)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ListResponseMessageAttemptEndpointOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    suspend fun listAttemptsForEndpointApiV1AppAppIdMsgMsgIdEndpointEndpointIdAttemptGet(msgId: kotlin.String, appId: kotlin.String, endpointId: kotlin.String, iterator: kotlin.String? = null, limit: kotlin.Int? = 50, eventTypes: kotlin.collections.List<kotlin.String>? = null, channel: kotlin.String? = null, status: MessageStatus? = null, before: java.time.OffsetDateTime? = null, after: java.time.OffsetDateTime? = null, idempotencyKey: kotlin.String? = null) : ListResponseMessageAttemptEndpointOut = withContext(Dispatchers.IO) {
        @Suppress("DEPRECATION")
        val localVarResponse = listAttemptsForEndpointApiV1AppAppIdMsgMsgIdEndpointEndpointIdAttemptGetWithHttpInfo(msgId = msgId, appId = appId, endpointId = endpointId, iterator = iterator, limit = limit, eventTypes = eventTypes, channel = channel, status = status, before = before, after = after, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListResponseMessageAttemptEndpointOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List Attempts For Endpoint
     * DEPRECATED: please use list_attempts with endpoint_id as a query parameter instead.  List the message attempts for a particular endpoint.  Returning the endpoint.  The &#x60;before&#x60; parameter lets you filter all items created before a certain date and is ignored if an iterator is passed.
     * @param msgId 
     * @param appId 
     * @param endpointId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param eventTypes  (optional)
     * @param channel  (optional)
     * @param status  (optional)
     * @param before  (optional)
     * @param after  (optional)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<ListResponseMessageAttemptEndpointOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    suspend fun listAttemptsForEndpointApiV1AppAppIdMsgMsgIdEndpointEndpointIdAttemptGetWithHttpInfo(msgId: kotlin.String, appId: kotlin.String, endpointId: kotlin.String, iterator: kotlin.String?, limit: kotlin.Int?, eventTypes: kotlin.collections.List<kotlin.String>?, channel: kotlin.String?, status: MessageStatus?, before: java.time.OffsetDateTime?, after: java.time.OffsetDateTime?, idempotencyKey: kotlin.String?) : ApiResponse<ListResponseMessageAttemptEndpointOut?> = withContext(Dispatchers.IO) {
        @Suppress("DEPRECATION")
        val localVariableConfig = listAttemptsForEndpointApiV1AppAppIdMsgMsgIdEndpointEndpointIdAttemptGetRequestConfig(msgId = msgId, appId = appId, endpointId = endpointId, iterator = iterator, limit = limit, eventTypes = eventTypes, channel = channel, status = status, before = before, after = after, idempotencyKey = idempotencyKey)

        return@withContext request<Unit, ListResponseMessageAttemptEndpointOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listAttemptsForEndpointApiV1AppAppIdMsgMsgIdEndpointEndpointIdAttemptGet
     *
     * @param msgId 
     * @param appId 
     * @param endpointId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param eventTypes  (optional)
     * @param channel  (optional)
     * @param status  (optional)
     * @param before  (optional)
     * @param after  (optional)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    @Deprecated(message = "This operation is deprecated.")
    fun listAttemptsForEndpointApiV1AppAppIdMsgMsgIdEndpointEndpointIdAttemptGetRequestConfig(msgId: kotlin.String, appId: kotlin.String, endpointId: kotlin.String, iterator: kotlin.String?, limit: kotlin.Int?, eventTypes: kotlin.collections.List<kotlin.String>?, channel: kotlin.String?, status: MessageStatus?, before: java.time.OffsetDateTime?, after: java.time.OffsetDateTime?, idempotencyKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (iterator != null) {
                    put("iterator", listOf(iterator.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (eventTypes != null) {
                    put("event_types", toMultiValue(eventTypes.toList(), "multi"))
                }
                if (channel != null) {
                    put("channel", listOf(channel.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (before != null) {
                    put("before", listOf(parseDateToQueryString(before)))
                }
                if (after != null) {
                    put("after", listOf(parseDateToQueryString(after)))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/app/{app_id}/msg/{msg_id}/endpoint/{endpoint_id}/attempt/".replace("{"+"msg_id"+"}", encodeURIComponent(msgId.toString())).replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())).replace("{"+"endpoint_id"+"}", encodeURIComponent(endpointId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Resend Webhook
     * Resend a message to the specified endpoint.
     * @param endpointId 
     * @param msgId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun resendWebhookApiV1AppAppIdMsgMsgIdEndpointEndpointIdResendPost(endpointId: kotlin.String, msgId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = resendWebhookApiV1AppAppIdMsgMsgIdEndpointEndpointIdResendPostWithHttpInfo(endpointId = endpointId, msgId = msgId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Resend Webhook
     * Resend a message to the specified endpoint.
     * @param endpointId 
     * @param msgId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun resendWebhookApiV1AppAppIdMsgMsgIdEndpointEndpointIdResendPostWithHttpInfo(endpointId: kotlin.String, msgId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = resendWebhookApiV1AppAppIdMsgMsgIdEndpointEndpointIdResendPostRequestConfig(endpointId = endpointId, msgId = msgId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation resendWebhookApiV1AppAppIdMsgMsgIdEndpointEndpointIdResendPost
     *
     * @param endpointId 
     * @param msgId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun resendWebhookApiV1AppAppIdMsgMsgIdEndpointEndpointIdResendPostRequestConfig(endpointId: kotlin.String, msgId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/app/{app_id}/msg/{msg_id}/endpoint/{endpoint_id}/resend/".replace("{"+"endpoint_id"+"}", encodeURIComponent(endpointId.toString())).replace("{"+"msg_id"+"}", encodeURIComponent(msgId.toString())).replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
