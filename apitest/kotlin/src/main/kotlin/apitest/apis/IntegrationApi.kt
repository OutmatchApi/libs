/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package apitest.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.outmatchapi.apitest.HTTPValidationError
import com.outmatchapi.apitest.HttpErrorOut
import com.outmatchapi.apitest.IntegrationIn
import com.outmatchapi.apitest.IntegrationKeyOut
import com.outmatchapi.apitest.IntegrationOut
import com.outmatchapi.apitest.IntegrationUpdate
import com.outmatchapi.apitest.ListResponseIntegrationOut

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import apitest.infrastructure.ApiClient
import apitest.infrastructure.ApiResponse
import apitest.infrastructure.ClientException
import apitest.infrastructure.ClientError
import apitest.infrastructure.ServerException
import apitest.infrastructure.ServerError
import apitest.infrastructure.MultiValueMap
import apitest.infrastructure.PartConfig
import apitest.infrastructure.RequestConfig
import apitest.infrastructure.RequestMethod
import apitest.infrastructure.ResponseType
import apitest.infrastructure.Success
import apitest.infrastructure.toMultiValue

class IntegrationApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * Create Integration
     * Create an integration.
     * @param appId 
     * @param integrationIn 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return IntegrationOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createIntegrationApiV1AppAppIdIntegrationPost(appId: kotlin.String, integrationIn: IntegrationIn, idempotencyKey: kotlin.String? = null) : IntegrationOut = withContext(Dispatchers.IO) {
        val localVarResponse = createIntegrationApiV1AppAppIdIntegrationPostWithHttpInfo(appId = appId, integrationIn = integrationIn, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IntegrationOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create Integration
     * Create an integration.
     * @param appId 
     * @param integrationIn 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<IntegrationOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun createIntegrationApiV1AppAppIdIntegrationPostWithHttpInfo(appId: kotlin.String, integrationIn: IntegrationIn, idempotencyKey: kotlin.String?) : ApiResponse<IntegrationOut?> = withContext(Dispatchers.IO) {
        val localVariableConfig = createIntegrationApiV1AppAppIdIntegrationPostRequestConfig(appId = appId, integrationIn = integrationIn, idempotencyKey = idempotencyKey)

        return@withContext request<IntegrationIn, IntegrationOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createIntegrationApiV1AppAppIdIntegrationPost
     *
     * @param appId 
     * @param integrationIn 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun createIntegrationApiV1AppAppIdIntegrationPostRequestConfig(appId: kotlin.String, integrationIn: IntegrationIn, idempotencyKey: kotlin.String?) : RequestConfig<IntegrationIn> {
        val localVariableBody = integrationIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/app/{app_id}/integration/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Delete Integration
     * Delete an integration and revoke it&#39;s key.
     * @param integId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deleteIntegrationApiV1AppAppIdIntegrationIntegIdDelete(integId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = deleteIntegrationApiV1AppAppIdIntegrationIntegIdDeleteWithHttpInfo(integId = integId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete Integration
     * Delete an integration and revoke it&#39;s key.
     * @param integId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun deleteIntegrationApiV1AppAppIdIntegrationIntegIdDeleteWithHttpInfo(integId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = deleteIntegrationApiV1AppAppIdIntegrationIntegIdDeleteRequestConfig(integId = integId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteIntegrationApiV1AppAppIdIntegrationIntegIdDelete
     *
     * @param integId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun deleteIntegrationApiV1AppAppIdIntegrationIntegIdDeleteRequestConfig(integId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/app/{app_id}/integration/{integ_id}/".replace("{"+"integ_id"+"}", encodeURIComponent(integId.toString())).replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get Integration
     * Get an integration.
     * @param integId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return IntegrationOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getIntegrationApiV1AppAppIdIntegrationIntegIdGet(integId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String? = null) : IntegrationOut = withContext(Dispatchers.IO) {
        val localVarResponse = getIntegrationApiV1AppAppIdIntegrationIntegIdGetWithHttpInfo(integId = integId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IntegrationOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Integration
     * Get an integration.
     * @param integId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<IntegrationOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getIntegrationApiV1AppAppIdIntegrationIntegIdGetWithHttpInfo(integId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : ApiResponse<IntegrationOut?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getIntegrationApiV1AppAppIdIntegrationIntegIdGetRequestConfig(integId = integId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext request<Unit, IntegrationOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getIntegrationApiV1AppAppIdIntegrationIntegIdGet
     *
     * @param integId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun getIntegrationApiV1AppAppIdIntegrationIntegIdGetRequestConfig(integId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/app/{app_id}/integration/{integ_id}/".replace("{"+"integ_id"+"}", encodeURIComponent(integId.toString())).replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get Integration Key
     * Get an integration&#39;s key.
     * @param integId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return IntegrationKeyOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyGet(integId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String? = null) : IntegrationKeyOut = withContext(Dispatchers.IO) {
        val localVarResponse = getIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyGetWithHttpInfo(integId = integId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IntegrationKeyOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Integration Key
     * Get an integration&#39;s key.
     * @param integId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<IntegrationKeyOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyGetWithHttpInfo(integId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : ApiResponse<IntegrationKeyOut?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyGetRequestConfig(integId = integId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext request<Unit, IntegrationKeyOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyGet
     *
     * @param integId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun getIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyGetRequestConfig(integId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/app/{app_id}/integration/{integ_id}/key/".replace("{"+"integ_id"+"}", encodeURIComponent(integId.toString())).replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List Integrations
     * List the application&#39;s integrations.
     * @param appId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ListResponseIntegrationOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listIntegrationsApiV1AppAppIdIntegrationGet(appId: kotlin.String, iterator: kotlin.String? = null, limit: kotlin.Int? = 50, idempotencyKey: kotlin.String? = null) : ListResponseIntegrationOut = withContext(Dispatchers.IO) {
        val localVarResponse = listIntegrationsApiV1AppAppIdIntegrationGetWithHttpInfo(appId = appId, iterator = iterator, limit = limit, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListResponseIntegrationOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List Integrations
     * List the application&#39;s integrations.
     * @param appId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<ListResponseIntegrationOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun listIntegrationsApiV1AppAppIdIntegrationGetWithHttpInfo(appId: kotlin.String, iterator: kotlin.String?, limit: kotlin.Int?, idempotencyKey: kotlin.String?) : ApiResponse<ListResponseIntegrationOut?> = withContext(Dispatchers.IO) {
        val localVariableConfig = listIntegrationsApiV1AppAppIdIntegrationGetRequestConfig(appId = appId, iterator = iterator, limit = limit, idempotencyKey = idempotencyKey)

        return@withContext request<Unit, ListResponseIntegrationOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listIntegrationsApiV1AppAppIdIntegrationGet
     *
     * @param appId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun listIntegrationsApiV1AppAppIdIntegrationGetRequestConfig(appId: kotlin.String, iterator: kotlin.String?, limit: kotlin.Int?, idempotencyKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (iterator != null) {
                    put("iterator", listOf(iterator.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/app/{app_id}/integration/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Rotate Integration Key
     * Rotate the integration&#39;s key. The previous key will be immediately revoked.
     * @param integId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return IntegrationKeyOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun rotateIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyRotatePost(integId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String? = null) : IntegrationKeyOut = withContext(Dispatchers.IO) {
        val localVarResponse = rotateIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyRotatePostWithHttpInfo(integId = integId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IntegrationKeyOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Rotate Integration Key
     * Rotate the integration&#39;s key. The previous key will be immediately revoked.
     * @param integId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<IntegrationKeyOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun rotateIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyRotatePostWithHttpInfo(integId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : ApiResponse<IntegrationKeyOut?> = withContext(Dispatchers.IO) {
        val localVariableConfig = rotateIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyRotatePostRequestConfig(integId = integId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext request<Unit, IntegrationKeyOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rotateIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyRotatePost
     *
     * @param integId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun rotateIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyRotatePostRequestConfig(integId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/app/{app_id}/integration/{integ_id}/key/rotate/".replace("{"+"integ_id"+"}", encodeURIComponent(integId.toString())).replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Update Integration
     * Update an integration.
     * @param integId 
     * @param appId 
     * @param integrationUpdate 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return IntegrationOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updateIntegrationApiV1AppAppIdIntegrationIntegIdPut(integId: kotlin.String, appId: kotlin.String, integrationUpdate: IntegrationUpdate, idempotencyKey: kotlin.String? = null) : IntegrationOut = withContext(Dispatchers.IO) {
        val localVarResponse = updateIntegrationApiV1AppAppIdIntegrationIntegIdPutWithHttpInfo(integId = integId, appId = appId, integrationUpdate = integrationUpdate, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IntegrationOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update Integration
     * Update an integration.
     * @param integId 
     * @param appId 
     * @param integrationUpdate 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<IntegrationOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun updateIntegrationApiV1AppAppIdIntegrationIntegIdPutWithHttpInfo(integId: kotlin.String, appId: kotlin.String, integrationUpdate: IntegrationUpdate, idempotencyKey: kotlin.String?) : ApiResponse<IntegrationOut?> = withContext(Dispatchers.IO) {
        val localVariableConfig = updateIntegrationApiV1AppAppIdIntegrationIntegIdPutRequestConfig(integId = integId, appId = appId, integrationUpdate = integrationUpdate, idempotencyKey = idempotencyKey)

        return@withContext request<IntegrationUpdate, IntegrationOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateIntegrationApiV1AppAppIdIntegrationIntegIdPut
     *
     * @param integId 
     * @param appId 
     * @param integrationUpdate 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun updateIntegrationApiV1AppAppIdIntegrationIntegIdPutRequestConfig(integId: kotlin.String, appId: kotlin.String, integrationUpdate: IntegrationUpdate, idempotencyKey: kotlin.String?) : RequestConfig<IntegrationUpdate> {
        val localVariableBody = integrationUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v1/app/{app_id}/integration/{integ_id}/".replace("{"+"integ_id"+"}", encodeURIComponent(integId.toString())).replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
