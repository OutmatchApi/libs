/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package apitest.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.outmatchapi.apitest.EndpointHeadersIn
import com.outmatchapi.apitest.EndpointHeadersOut
import com.outmatchapi.apitest.EndpointHeadersPatchIn
import com.outmatchapi.apitest.EndpointIn
import com.outmatchapi.apitest.EndpointOut
import com.outmatchapi.apitest.EndpointSecretOut
import com.outmatchapi.apitest.EndpointSecretRotateIn
import com.outmatchapi.apitest.EndpointStats
import com.outmatchapi.apitest.EndpointUpdate
import com.outmatchapi.apitest.HTTPValidationError
import com.outmatchapi.apitest.HttpErrorOut
import com.outmatchapi.apitest.ListResponseEndpointOut
import com.outmatchapi.apitest.RecoverIn
import com.outmatchapi.apitest.ReplayIn

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import apitest.infrastructure.ApiClient
import apitest.infrastructure.ApiResponse
import apitest.infrastructure.ClientException
import apitest.infrastructure.ClientError
import apitest.infrastructure.ServerException
import apitest.infrastructure.ServerError
import apitest.infrastructure.MultiValueMap
import apitest.infrastructure.PartConfig
import apitest.infrastructure.RequestConfig
import apitest.infrastructure.RequestMethod
import apitest.infrastructure.ResponseType
import apitest.infrastructure.Success
import apitest.infrastructure.toMultiValue

class EndpointApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * Create Endpoint
     * Create a new endpoint for the application.  When &#x60;secret&#x60; is &#x60;null&#x60; the secret is automatically generated (recommended)
     * @param appId 
     * @param endpointIn 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return EndpointOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createEndpointApiV1AppAppIdEndpointPost(appId: kotlin.String, endpointIn: EndpointIn, idempotencyKey: kotlin.String? = null) : EndpointOut = withContext(Dispatchers.IO) {
        val localVarResponse = createEndpointApiV1AppAppIdEndpointPostWithHttpInfo(appId = appId, endpointIn = endpointIn, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EndpointOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create Endpoint
     * Create a new endpoint for the application.  When &#x60;secret&#x60; is &#x60;null&#x60; the secret is automatically generated (recommended)
     * @param appId 
     * @param endpointIn 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<EndpointOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun createEndpointApiV1AppAppIdEndpointPostWithHttpInfo(appId: kotlin.String, endpointIn: EndpointIn, idempotencyKey: kotlin.String?) : ApiResponse<EndpointOut?> = withContext(Dispatchers.IO) {
        val localVariableConfig = createEndpointApiV1AppAppIdEndpointPostRequestConfig(appId = appId, endpointIn = endpointIn, idempotencyKey = idempotencyKey)

        return@withContext request<EndpointIn, EndpointOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createEndpointApiV1AppAppIdEndpointPost
     *
     * @param appId 
     * @param endpointIn 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun createEndpointApiV1AppAppIdEndpointPostRequestConfig(appId: kotlin.String, endpointIn: EndpointIn, idempotencyKey: kotlin.String?) : RequestConfig<EndpointIn> {
        val localVariableBody = endpointIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/app/{app_id}/endpoint/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Delete Endpoint
     * Delete an endpoint.
     * @param endpointId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deleteEndpointApiV1AppAppIdEndpointEndpointIdDelete(endpointId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = deleteEndpointApiV1AppAppIdEndpointEndpointIdDeleteWithHttpInfo(endpointId = endpointId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete Endpoint
     * Delete an endpoint.
     * @param endpointId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun deleteEndpointApiV1AppAppIdEndpointEndpointIdDeleteWithHttpInfo(endpointId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = deleteEndpointApiV1AppAppIdEndpointEndpointIdDeleteRequestConfig(endpointId = endpointId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteEndpointApiV1AppAppIdEndpointEndpointIdDelete
     *
     * @param endpointId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun deleteEndpointApiV1AppAppIdEndpointEndpointIdDeleteRequestConfig(endpointId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/app/{app_id}/endpoint/{endpoint_id}/".replace("{"+"endpoint_id"+"}", encodeURIComponent(endpointId.toString())).replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get Endpoint
     * Get an application.
     * @param endpointId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return EndpointOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getEndpointApiV1AppAppIdEndpointEndpointIdGet(endpointId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String? = null) : EndpointOut = withContext(Dispatchers.IO) {
        val localVarResponse = getEndpointApiV1AppAppIdEndpointEndpointIdGetWithHttpInfo(endpointId = endpointId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EndpointOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Endpoint
     * Get an application.
     * @param endpointId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<EndpointOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getEndpointApiV1AppAppIdEndpointEndpointIdGetWithHttpInfo(endpointId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : ApiResponse<EndpointOut?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getEndpointApiV1AppAppIdEndpointEndpointIdGetRequestConfig(endpointId = endpointId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext request<Unit, EndpointOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEndpointApiV1AppAppIdEndpointEndpointIdGet
     *
     * @param endpointId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun getEndpointApiV1AppAppIdEndpointEndpointIdGetRequestConfig(endpointId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/app/{app_id}/endpoint/{endpoint_id}/".replace("{"+"endpoint_id"+"}", encodeURIComponent(endpointId.toString())).replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get Endpoint Headers
     * Get the additional headers to be sent with the webhook
     * @param endpointId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return EndpointHeadersOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getEndpointHeadersApiV1AppAppIdEndpointEndpointIdHeadersGet(endpointId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String? = null) : EndpointHeadersOut = withContext(Dispatchers.IO) {
        val localVarResponse = getEndpointHeadersApiV1AppAppIdEndpointEndpointIdHeadersGetWithHttpInfo(endpointId = endpointId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EndpointHeadersOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Endpoint Headers
     * Get the additional headers to be sent with the webhook
     * @param endpointId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<EndpointHeadersOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getEndpointHeadersApiV1AppAppIdEndpointEndpointIdHeadersGetWithHttpInfo(endpointId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : ApiResponse<EndpointHeadersOut?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getEndpointHeadersApiV1AppAppIdEndpointEndpointIdHeadersGetRequestConfig(endpointId = endpointId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext request<Unit, EndpointHeadersOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEndpointHeadersApiV1AppAppIdEndpointEndpointIdHeadersGet
     *
     * @param endpointId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun getEndpointHeadersApiV1AppAppIdEndpointEndpointIdHeadersGetRequestConfig(endpointId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/app/{app_id}/endpoint/{endpoint_id}/headers/".replace("{"+"endpoint_id"+"}", encodeURIComponent(endpointId.toString())).replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get Endpoint Secret
     * Get the endpoint&#39;s signing secret.  This is used to verify the authenticity of the webhook. For more information please refer to [the consuming webhooks docs](https://docs.svix.com/consuming-webhooks/).
     * @param endpointId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return EndpointSecretOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getEndpointSecretApiV1AppAppIdEndpointEndpointIdSecretGet(endpointId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String? = null) : EndpointSecretOut = withContext(Dispatchers.IO) {
        val localVarResponse = getEndpointSecretApiV1AppAppIdEndpointEndpointIdSecretGetWithHttpInfo(endpointId = endpointId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EndpointSecretOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Endpoint Secret
     * Get the endpoint&#39;s signing secret.  This is used to verify the authenticity of the webhook. For more information please refer to [the consuming webhooks docs](https://docs.svix.com/consuming-webhooks/).
     * @param endpointId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<EndpointSecretOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getEndpointSecretApiV1AppAppIdEndpointEndpointIdSecretGetWithHttpInfo(endpointId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : ApiResponse<EndpointSecretOut?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getEndpointSecretApiV1AppAppIdEndpointEndpointIdSecretGetRequestConfig(endpointId = endpointId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext request<Unit, EndpointSecretOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEndpointSecretApiV1AppAppIdEndpointEndpointIdSecretGet
     *
     * @param endpointId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun getEndpointSecretApiV1AppAppIdEndpointEndpointIdSecretGetRequestConfig(endpointId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/app/{app_id}/endpoint/{endpoint_id}/secret/".replace("{"+"endpoint_id"+"}", encodeURIComponent(endpointId.toString())).replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get Endpoint Stats
     * Get basic statistics for the endpoint.
     * @param endpointId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return EndpointStats
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getEndpointStatsApiV1AppAppIdEndpointEndpointIdStatsGet(endpointId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String? = null) : EndpointStats = withContext(Dispatchers.IO) {
        val localVarResponse = getEndpointStatsApiV1AppAppIdEndpointEndpointIdStatsGetWithHttpInfo(endpointId = endpointId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EndpointStats
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Endpoint Stats
     * Get basic statistics for the endpoint.
     * @param endpointId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<EndpointStats?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getEndpointStatsApiV1AppAppIdEndpointEndpointIdStatsGetWithHttpInfo(endpointId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : ApiResponse<EndpointStats?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getEndpointStatsApiV1AppAppIdEndpointEndpointIdStatsGetRequestConfig(endpointId = endpointId, appId = appId, idempotencyKey = idempotencyKey)

        return@withContext request<Unit, EndpointStats>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEndpointStatsApiV1AppAppIdEndpointEndpointIdStatsGet
     *
     * @param endpointId 
     * @param appId 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun getEndpointStatsApiV1AppAppIdEndpointEndpointIdStatsGetRequestConfig(endpointId: kotlin.String, appId: kotlin.String, idempotencyKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/app/{app_id}/endpoint/{endpoint_id}/stats/".replace("{"+"endpoint_id"+"}", encodeURIComponent(endpointId.toString())).replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List Endpoints
     * List the application&#39;s endpoints.
     * @param appId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ListResponseEndpointOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listEndpointsApiV1AppAppIdEndpointGet(appId: kotlin.String, iterator: kotlin.String? = null, limit: kotlin.Int? = 50, idempotencyKey: kotlin.String? = null) : ListResponseEndpointOut = withContext(Dispatchers.IO) {
        val localVarResponse = listEndpointsApiV1AppAppIdEndpointGetWithHttpInfo(appId = appId, iterator = iterator, limit = limit, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListResponseEndpointOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List Endpoints
     * List the application&#39;s endpoints.
     * @param appId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<ListResponseEndpointOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun listEndpointsApiV1AppAppIdEndpointGetWithHttpInfo(appId: kotlin.String, iterator: kotlin.String?, limit: kotlin.Int?, idempotencyKey: kotlin.String?) : ApiResponse<ListResponseEndpointOut?> = withContext(Dispatchers.IO) {
        val localVariableConfig = listEndpointsApiV1AppAppIdEndpointGetRequestConfig(appId = appId, iterator = iterator, limit = limit, idempotencyKey = idempotencyKey)

        return@withContext request<Unit, ListResponseEndpointOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listEndpointsApiV1AppAppIdEndpointGet
     *
     * @param appId 
     * @param iterator  (optional)
     * @param limit  (optional, default to 50)
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun listEndpointsApiV1AppAppIdEndpointGetRequestConfig(appId: kotlin.String, iterator: kotlin.String?, limit: kotlin.Int?, idempotencyKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (iterator != null) {
                    put("iterator", listOf(iterator.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/app/{app_id}/endpoint/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Patch Endpoint Headers
     * Partially set the additional headers to be sent with the webhook
     * @param appId 
     * @param endpointId 
     * @param endpointHeadersPatchIn 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun patchEndpointHeadersApiV1AppAppIdEndpointEndpointIdHeadersPatch(appId: kotlin.String, endpointId: kotlin.String, endpointHeadersPatchIn: EndpointHeadersPatchIn, idempotencyKey: kotlin.String? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = patchEndpointHeadersApiV1AppAppIdEndpointEndpointIdHeadersPatchWithHttpInfo(appId = appId, endpointId = endpointId, endpointHeadersPatchIn = endpointHeadersPatchIn, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Patch Endpoint Headers
     * Partially set the additional headers to be sent with the webhook
     * @param appId 
     * @param endpointId 
     * @param endpointHeadersPatchIn 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun patchEndpointHeadersApiV1AppAppIdEndpointEndpointIdHeadersPatchWithHttpInfo(appId: kotlin.String, endpointId: kotlin.String, endpointHeadersPatchIn: EndpointHeadersPatchIn, idempotencyKey: kotlin.String?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = patchEndpointHeadersApiV1AppAppIdEndpointEndpointIdHeadersPatchRequestConfig(appId = appId, endpointId = endpointId, endpointHeadersPatchIn = endpointHeadersPatchIn, idempotencyKey = idempotencyKey)

        return@withContext request<EndpointHeadersPatchIn, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation patchEndpointHeadersApiV1AppAppIdEndpointEndpointIdHeadersPatch
     *
     * @param appId 
     * @param endpointId 
     * @param endpointHeadersPatchIn 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun patchEndpointHeadersApiV1AppAppIdEndpointEndpointIdHeadersPatchRequestConfig(appId: kotlin.String, endpointId: kotlin.String, endpointHeadersPatchIn: EndpointHeadersPatchIn, idempotencyKey: kotlin.String?) : RequestConfig<EndpointHeadersPatchIn> {
        val localVariableBody = endpointHeadersPatchIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v1/app/{app_id}/endpoint/{endpoint_id}/headers/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())).replace("{"+"endpoint_id"+"}", encodeURIComponent(endpointId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Recover Failed Webhooks
     * Resend all failed messages since a given time.
     * @param appId 
     * @param endpointId 
     * @param recoverIn 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun recoverFailedWebhooksApiV1AppAppIdEndpointEndpointIdRecoverPost(appId: kotlin.String, endpointId: kotlin.String, recoverIn: RecoverIn, idempotencyKey: kotlin.String? = null) : kotlin.Any = withContext(Dispatchers.IO) {
        val localVarResponse = recoverFailedWebhooksApiV1AppAppIdEndpointEndpointIdRecoverPostWithHttpInfo(appId = appId, endpointId = endpointId, recoverIn = recoverIn, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Recover Failed Webhooks
     * Resend all failed messages since a given time.
     * @param appId 
     * @param endpointId 
     * @param recoverIn 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun recoverFailedWebhooksApiV1AppAppIdEndpointEndpointIdRecoverPostWithHttpInfo(appId: kotlin.String, endpointId: kotlin.String, recoverIn: RecoverIn, idempotencyKey: kotlin.String?) : ApiResponse<kotlin.Any?> = withContext(Dispatchers.IO) {
        val localVariableConfig = recoverFailedWebhooksApiV1AppAppIdEndpointEndpointIdRecoverPostRequestConfig(appId = appId, endpointId = endpointId, recoverIn = recoverIn, idempotencyKey = idempotencyKey)

        return@withContext request<RecoverIn, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation recoverFailedWebhooksApiV1AppAppIdEndpointEndpointIdRecoverPost
     *
     * @param appId 
     * @param endpointId 
     * @param recoverIn 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun recoverFailedWebhooksApiV1AppAppIdEndpointEndpointIdRecoverPostRequestConfig(appId: kotlin.String, endpointId: kotlin.String, recoverIn: RecoverIn, idempotencyKey: kotlin.String?) : RequestConfig<RecoverIn> {
        val localVariableBody = recoverIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/app/{app_id}/endpoint/{endpoint_id}/recover/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())).replace("{"+"endpoint_id"+"}", encodeURIComponent(endpointId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Replay Missing Webhooks
     * Replays messages to the endpoint. Only messages that were created after &#x60;since&#x60; will be sent. Messages that were previously sent to the endpoint are not resent.
     * @param appId 
     * @param endpointId 
     * @param replayIn 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun replayMissingWebhooksApiV1AppAppIdEndpointEndpointIdReplayMissingPost(appId: kotlin.String, endpointId: kotlin.String, replayIn: ReplayIn, idempotencyKey: kotlin.String? = null) : kotlin.Any = withContext(Dispatchers.IO) {
        val localVarResponse = replayMissingWebhooksApiV1AppAppIdEndpointEndpointIdReplayMissingPostWithHttpInfo(appId = appId, endpointId = endpointId, replayIn = replayIn, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Replay Missing Webhooks
     * Replays messages to the endpoint. Only messages that were created after &#x60;since&#x60; will be sent. Messages that were previously sent to the endpoint are not resent.
     * @param appId 
     * @param endpointId 
     * @param replayIn 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun replayMissingWebhooksApiV1AppAppIdEndpointEndpointIdReplayMissingPostWithHttpInfo(appId: kotlin.String, endpointId: kotlin.String, replayIn: ReplayIn, idempotencyKey: kotlin.String?) : ApiResponse<kotlin.Any?> = withContext(Dispatchers.IO) {
        val localVariableConfig = replayMissingWebhooksApiV1AppAppIdEndpointEndpointIdReplayMissingPostRequestConfig(appId = appId, endpointId = endpointId, replayIn = replayIn, idempotencyKey = idempotencyKey)

        return@withContext request<ReplayIn, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation replayMissingWebhooksApiV1AppAppIdEndpointEndpointIdReplayMissingPost
     *
     * @param appId 
     * @param endpointId 
     * @param replayIn 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun replayMissingWebhooksApiV1AppAppIdEndpointEndpointIdReplayMissingPostRequestConfig(appId: kotlin.String, endpointId: kotlin.String, replayIn: ReplayIn, idempotencyKey: kotlin.String?) : RequestConfig<ReplayIn> {
        val localVariableBody = replayIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/app/{app_id}/endpoint/{endpoint_id}/replay-missing/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())).replace("{"+"endpoint_id"+"}", encodeURIComponent(endpointId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Rotate Endpoint Secret
     * Rotates the endpoint&#39;s signing secret.  The previous secret will be valid for the next 24 hours.
     * @param endpointId 
     * @param appId 
     * @param endpointSecretRotateIn 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun rotateEndpointSecretApiV1AppAppIdEndpointEndpointIdSecretRotatePost(endpointId: kotlin.String, appId: kotlin.String, endpointSecretRotateIn: EndpointSecretRotateIn, idempotencyKey: kotlin.String? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = rotateEndpointSecretApiV1AppAppIdEndpointEndpointIdSecretRotatePostWithHttpInfo(endpointId = endpointId, appId = appId, endpointSecretRotateIn = endpointSecretRotateIn, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Rotate Endpoint Secret
     * Rotates the endpoint&#39;s signing secret.  The previous secret will be valid for the next 24 hours.
     * @param endpointId 
     * @param appId 
     * @param endpointSecretRotateIn 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun rotateEndpointSecretApiV1AppAppIdEndpointEndpointIdSecretRotatePostWithHttpInfo(endpointId: kotlin.String, appId: kotlin.String, endpointSecretRotateIn: EndpointSecretRotateIn, idempotencyKey: kotlin.String?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = rotateEndpointSecretApiV1AppAppIdEndpointEndpointIdSecretRotatePostRequestConfig(endpointId = endpointId, appId = appId, endpointSecretRotateIn = endpointSecretRotateIn, idempotencyKey = idempotencyKey)

        return@withContext request<EndpointSecretRotateIn, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rotateEndpointSecretApiV1AppAppIdEndpointEndpointIdSecretRotatePost
     *
     * @param endpointId 
     * @param appId 
     * @param endpointSecretRotateIn 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun rotateEndpointSecretApiV1AppAppIdEndpointEndpointIdSecretRotatePostRequestConfig(endpointId: kotlin.String, appId: kotlin.String, endpointSecretRotateIn: EndpointSecretRotateIn, idempotencyKey: kotlin.String?) : RequestConfig<EndpointSecretRotateIn> {
        val localVariableBody = endpointSecretRotateIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/app/{app_id}/endpoint/{endpoint_id}/secret/rotate/".replace("{"+"endpoint_id"+"}", encodeURIComponent(endpointId.toString())).replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Update Endpoint
     * Update an endpoint.
     * @param endpointId 
     * @param appId 
     * @param endpointUpdate 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return EndpointOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updateEndpointApiV1AppAppIdEndpointEndpointIdPut(endpointId: kotlin.String, appId: kotlin.String, endpointUpdate: EndpointUpdate, idempotencyKey: kotlin.String? = null) : EndpointOut = withContext(Dispatchers.IO) {
        val localVarResponse = updateEndpointApiV1AppAppIdEndpointEndpointIdPutWithHttpInfo(endpointId = endpointId, appId = appId, endpointUpdate = endpointUpdate, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EndpointOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update Endpoint
     * Update an endpoint.
     * @param endpointId 
     * @param appId 
     * @param endpointUpdate 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<EndpointOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun updateEndpointApiV1AppAppIdEndpointEndpointIdPutWithHttpInfo(endpointId: kotlin.String, appId: kotlin.String, endpointUpdate: EndpointUpdate, idempotencyKey: kotlin.String?) : ApiResponse<EndpointOut?> = withContext(Dispatchers.IO) {
        val localVariableConfig = updateEndpointApiV1AppAppIdEndpointEndpointIdPutRequestConfig(endpointId = endpointId, appId = appId, endpointUpdate = endpointUpdate, idempotencyKey = idempotencyKey)

        return@withContext request<EndpointUpdate, EndpointOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateEndpointApiV1AppAppIdEndpointEndpointIdPut
     *
     * @param endpointId 
     * @param appId 
     * @param endpointUpdate 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun updateEndpointApiV1AppAppIdEndpointEndpointIdPutRequestConfig(endpointId: kotlin.String, appId: kotlin.String, endpointUpdate: EndpointUpdate, idempotencyKey: kotlin.String?) : RequestConfig<EndpointUpdate> {
        val localVariableBody = endpointUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v1/app/{app_id}/endpoint/{endpoint_id}/".replace("{"+"endpoint_id"+"}", encodeURIComponent(endpointId.toString())).replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Update Endpoint Headers
     * Set the additional headers to be sent with the webhook
     * @param appId 
     * @param endpointId 
     * @param endpointHeadersIn 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updateEndpointHeadersApiV1AppAppIdEndpointEndpointIdHeadersPut(appId: kotlin.String, endpointId: kotlin.String, endpointHeadersIn: EndpointHeadersIn, idempotencyKey: kotlin.String? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = updateEndpointHeadersApiV1AppAppIdEndpointEndpointIdHeadersPutWithHttpInfo(appId = appId, endpointId = endpointId, endpointHeadersIn = endpointHeadersIn, idempotencyKey = idempotencyKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update Endpoint Headers
     * Set the additional headers to be sent with the webhook
     * @param appId 
     * @param endpointId 
     * @param endpointHeadersIn 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun updateEndpointHeadersApiV1AppAppIdEndpointEndpointIdHeadersPutWithHttpInfo(appId: kotlin.String, endpointId: kotlin.String, endpointHeadersIn: EndpointHeadersIn, idempotencyKey: kotlin.String?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = updateEndpointHeadersApiV1AppAppIdEndpointEndpointIdHeadersPutRequestConfig(appId = appId, endpointId = endpointId, endpointHeadersIn = endpointHeadersIn, idempotencyKey = idempotencyKey)

        return@withContext request<EndpointHeadersIn, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateEndpointHeadersApiV1AppAppIdEndpointEndpointIdHeadersPut
     *
     * @param appId 
     * @param endpointId 
     * @param endpointHeadersIn 
     * @param idempotencyKey The request&#39;s idempotency key (optional)
     * @return RequestConfig
     */
    fun updateEndpointHeadersApiV1AppAppIdEndpointEndpointIdHeadersPutRequestConfig(appId: kotlin.String, endpointId: kotlin.String, endpointHeadersIn: EndpointHeadersIn, idempotencyKey: kotlin.String?) : RequestConfig<EndpointHeadersIn> {
        val localVariableBody = endpointHeadersIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        idempotencyKey?.apply { localVariableHeaders["idempotency-key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v1/app/{app_id}/endpoint/{endpoint_id}/headers/".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())).replace("{"+"endpoint_id"+"}", encodeURIComponent(endpointId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
