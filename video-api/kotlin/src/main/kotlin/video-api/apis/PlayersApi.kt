/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package video-api.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.outmatchapi.video-api.BadMinusRequest
import com.outmatchapi.video-api.NotMinusFound
import com.outmatchapi.video-api.Player
import com.outmatchapi.video-api.PlayerCreationPayload
import com.outmatchapi.video-api.PlayerUpdatePayload
import com.outmatchapi.video-api.PlayersMinusListMinusResponse

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import video-api.infrastructure.ApiClient
import video-api.infrastructure.ApiResponse
import video-api.infrastructure.ClientException
import video-api.infrastructure.ClientError
import video-api.infrastructure.ServerException
import video-api.infrastructure.ServerError
import video-api.infrastructure.MultiValueMap
import video-api.infrastructure.PartConfig
import video-api.infrastructure.RequestConfig
import video-api.infrastructure.RequestMethod
import video-api.infrastructure.ResponseType
import video-api.infrastructure.Success
import video-api.infrastructure.toMultiValue

class PlayersApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://ws.api.video")
        }
    }

    /**
     * Delete a player
     * Delete a player if you no longer need it. You can delete any player that you have the player ID for.
     * @param playerId The unique identifier for the player you want to delete.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun dELETEPlayersPlayerId(playerId: kotlin.String) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = dELETEPlayersPlayerIdWithHttpInfo(playerId = playerId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete a player
     * Delete a player if you no longer need it. You can delete any player that you have the player ID for.
     * @param playerId The unique identifier for the player you want to delete.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun dELETEPlayersPlayerIdWithHttpInfo(playerId: kotlin.String) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = dELETEPlayersPlayerIdRequestConfig(playerId = playerId)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation dELETEPlayersPlayerId
     *
     * @param playerId The unique identifier for the player you want to delete.
     * @return RequestConfig
     */
    fun dELETEPlayersPlayerIdRequestConfig(playerId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/players/{playerId}".replace("{"+"playerId"+"}", encodeURIComponent(playerId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Delete logo
     * 
     * @param playerId The unique identifier for the player.
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun dELETEPlayersPlayerIdLogo(playerId: kotlin.String) : kotlin.Any = withContext(Dispatchers.IO) {
        val localVarResponse = dELETEPlayersPlayerIdLogoWithHttpInfo(playerId = playerId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete logo
     * 
     * @param playerId The unique identifier for the player.
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun dELETEPlayersPlayerIdLogoWithHttpInfo(playerId: kotlin.String) : ApiResponse<kotlin.Any?> = withContext(Dispatchers.IO) {
        val localVariableConfig = dELETEPlayersPlayerIdLogoRequestConfig(playerId = playerId)

        return@withContext request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation dELETEPlayersPlayerIdLogo
     *
     * @param playerId The unique identifier for the player.
     * @return RequestConfig
     */
    fun dELETEPlayersPlayerIdLogoRequestConfig(playerId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/players/{playerId}/logo".replace("{"+"playerId"+"}", encodeURIComponent(playerId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortBy
     */
     enum class SortBy_gETPlayers(val value: kotlin.String) {
         @Json(name = "createdAt") createdAt("createdAt"),
         @Json(name = "updatedAt") updatedAt("updatedAt")
     }

    /**
     * enum for parameter sortOrder
     */
     enum class SortOrder_gETPlayers(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc")
     }

    /**
     * List all players
     * Retrieve a list of all the players you created, as well as details about each one. Tutorials that use the [player endpoint](https://api.video/blog/endpoints/player).
     * @param sortBy createdAt is the time the player was created. updatedAt is the time the player was last updated. The time is presented in ISO-8601 format. (optional)
     * @param sortOrder Allowed: asc, desc. Ascending for date and time means that earlier values precede later ones. Descending means that later values preced earlier ones. (optional)
     * @param currentPage Choose the number of search results to return per page. Minimum value: 1 (optional, default to 1)
     * @param pageSize Results per page. Allowed values 1-100, default is 25. (optional, default to 25)
     * @return PlayersMinusListMinusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun gETPlayers(sortBy: SortBy_gETPlayers? = null, sortOrder: SortOrder_gETPlayers? = null, currentPage: kotlin.Int? = 1, pageSize: kotlin.Int? = 25) : PlayersMinusListMinusResponse = withContext(Dispatchers.IO) {
        val localVarResponse = gETPlayersWithHttpInfo(sortBy = sortBy, sortOrder = sortOrder, currentPage = currentPage, pageSize = pageSize)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PlayersMinusListMinusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List all players
     * Retrieve a list of all the players you created, as well as details about each one. Tutorials that use the [player endpoint](https://api.video/blog/endpoints/player).
     * @param sortBy createdAt is the time the player was created. updatedAt is the time the player was last updated. The time is presented in ISO-8601 format. (optional)
     * @param sortOrder Allowed: asc, desc. Ascending for date and time means that earlier values precede later ones. Descending means that later values preced earlier ones. (optional)
     * @param currentPage Choose the number of search results to return per page. Minimum value: 1 (optional, default to 1)
     * @param pageSize Results per page. Allowed values 1-100, default is 25. (optional, default to 25)
     * @return ApiResponse<PlayersMinusListMinusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun gETPlayersWithHttpInfo(sortBy: SortBy_gETPlayers?, sortOrder: SortOrder_gETPlayers?, currentPage: kotlin.Int?, pageSize: kotlin.Int?) : ApiResponse<PlayersMinusListMinusResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = gETPlayersRequestConfig(sortBy = sortBy, sortOrder = sortOrder, currentPage = currentPage, pageSize = pageSize)

        return@withContext request<Unit, PlayersMinusListMinusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation gETPlayers
     *
     * @param sortBy createdAt is the time the player was created. updatedAt is the time the player was last updated. The time is presented in ISO-8601 format. (optional)
     * @param sortOrder Allowed: asc, desc. Ascending for date and time means that earlier values precede later ones. Descending means that later values preced earlier ones. (optional)
     * @param currentPage Choose the number of search results to return per page. Minimum value: 1 (optional, default to 1)
     * @param pageSize Results per page. Allowed values 1-100, default is 25. (optional, default to 25)
     * @return RequestConfig
     */
    fun gETPlayersRequestConfig(sortBy: SortBy_gETPlayers?, sortOrder: SortOrder_gETPlayers?, currentPage: kotlin.Int?, pageSize: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (sortBy != null) {
                    put("sortBy", listOf(sortBy.toString()))
                }
                if (sortOrder != null) {
                    put("sortOrder", listOf(sortOrder.toString()))
                }
                if (currentPage != null) {
                    put("currentPage", listOf(currentPage.toString()))
                }
                if (pageSize != null) {
                    put("pageSize", listOf(pageSize.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/players",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Show a player
     * Use a player ID to retrieve details about the player and display it for viewers.
     * @param playerId The unique identifier for the player you want to retrieve. 
     * @return Player
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun gETPlayersPlayerId(playerId: kotlin.String) : Player = withContext(Dispatchers.IO) {
        val localVarResponse = gETPlayersPlayerIdWithHttpInfo(playerId = playerId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Player
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Show a player
     * Use a player ID to retrieve details about the player and display it for viewers.
     * @param playerId The unique identifier for the player you want to retrieve. 
     * @return ApiResponse<Player?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun gETPlayersPlayerIdWithHttpInfo(playerId: kotlin.String) : ApiResponse<Player?> = withContext(Dispatchers.IO) {
        val localVariableConfig = gETPlayersPlayerIdRequestConfig(playerId = playerId)

        return@withContext request<Unit, Player>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation gETPlayersPlayerId
     *
     * @param playerId The unique identifier for the player you want to retrieve. 
     * @return RequestConfig
     */
    fun gETPlayersPlayerIdRequestConfig(playerId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/players/{playerId}".replace("{"+"playerId"+"}", encodeURIComponent(playerId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Update a player
     * Use a player ID to update specific details for a player. NOTE: It may take up to 10 min before the new player configuration is available from our CDN.
     * @param playerId The unique identifier for the player.
     * @param playerUpdatePayload 
     * @return Player
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun pATCHPlayersPlayerId(playerId: kotlin.String, playerUpdatePayload: PlayerUpdatePayload) : Player = withContext(Dispatchers.IO) {
        val localVarResponse = pATCHPlayersPlayerIdWithHttpInfo(playerId = playerId, playerUpdatePayload = playerUpdatePayload)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Player
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update a player
     * Use a player ID to update specific details for a player. NOTE: It may take up to 10 min before the new player configuration is available from our CDN.
     * @param playerId The unique identifier for the player.
     * @param playerUpdatePayload 
     * @return ApiResponse<Player?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun pATCHPlayersPlayerIdWithHttpInfo(playerId: kotlin.String, playerUpdatePayload: PlayerUpdatePayload) : ApiResponse<Player?> = withContext(Dispatchers.IO) {
        val localVariableConfig = pATCHPlayersPlayerIdRequestConfig(playerId = playerId, playerUpdatePayload = playerUpdatePayload)

        return@withContext request<PlayerUpdatePayload, Player>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation pATCHPlayersPlayerId
     *
     * @param playerId The unique identifier for the player.
     * @param playerUpdatePayload 
     * @return RequestConfig
     */
    fun pATCHPlayersPlayerIdRequestConfig(playerId: kotlin.String, playerUpdatePayload: PlayerUpdatePayload) : RequestConfig<PlayerUpdatePayload> {
        val localVariableBody = playerUpdatePayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/players/{playerId}".replace("{"+"playerId"+"}", encodeURIComponent(playerId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Create a player
     * Create a player for your video, and customise it.
     * @param playerCreationPayload 
     * @return Player
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun pOSTPlayers(playerCreationPayload: PlayerCreationPayload) : Player = withContext(Dispatchers.IO) {
        val localVarResponse = pOSTPlayersWithHttpInfo(playerCreationPayload = playerCreationPayload)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Player
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create a player
     * Create a player for your video, and customise it.
     * @param playerCreationPayload 
     * @return ApiResponse<Player?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun pOSTPlayersWithHttpInfo(playerCreationPayload: PlayerCreationPayload) : ApiResponse<Player?> = withContext(Dispatchers.IO) {
        val localVariableConfig = pOSTPlayersRequestConfig(playerCreationPayload = playerCreationPayload)

        return@withContext request<PlayerCreationPayload, Player>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation pOSTPlayers
     *
     * @param playerCreationPayload 
     * @return RequestConfig
     */
    fun pOSTPlayersRequestConfig(playerCreationPayload: PlayerCreationPayload) : RequestConfig<PlayerCreationPayload> {
        val localVariableBody = playerCreationPayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/players",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Upload a logo
     * The uploaded image maximum size should be 200x100 and its weight should be 200KB.  It will be scaled down to 30px height and converted to PNG to be displayed in the player.
     * @param playerId The unique identifier for the player.
     * @param file The name of the file you want to use for your logo.
     * @param link The path to the file you want to upload and use as a logo.
     * @return Player
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun pOSTPlayersPlayerIdLogo(playerId: kotlin.String, file: java.io.File, link: kotlin.String) : Player = withContext(Dispatchers.IO) {
        val localVarResponse = pOSTPlayersPlayerIdLogoWithHttpInfo(playerId = playerId, file = file, link = link)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Player
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Upload a logo
     * The uploaded image maximum size should be 200x100 and its weight should be 200KB.  It will be scaled down to 30px height and converted to PNG to be displayed in the player.
     * @param playerId The unique identifier for the player.
     * @param file The name of the file you want to use for your logo.
     * @param link The path to the file you want to upload and use as a logo.
     * @return ApiResponse<Player?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun pOSTPlayersPlayerIdLogoWithHttpInfo(playerId: kotlin.String, file: java.io.File, link: kotlin.String) : ApiResponse<Player?> = withContext(Dispatchers.IO) {
        val localVariableConfig = pOSTPlayersPlayerIdLogoRequestConfig(playerId = playerId, file = file, link = link)

        return@withContext request<Map<String, PartConfig<*>>, Player>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation pOSTPlayersPlayerIdLogo
     *
     * @param playerId The unique identifier for the player.
     * @param file The name of the file you want to use for your logo.
     * @param link The path to the file you want to upload and use as a logo.
     * @return RequestConfig
     */
    fun pOSTPlayersPlayerIdLogoRequestConfig(playerId: kotlin.String, file: java.io.File, link: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "file" to PartConfig(body = file, headers = mutableMapOf()),
            "link" to PartConfig(body = link, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/players/{playerId}/logo".replace("{"+"playerId"+"}", encodeURIComponent(playerId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
