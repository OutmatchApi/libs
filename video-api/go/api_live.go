/*
api.video

api.video is an API that encodes on the go to facilitate immediate playback, enhancing viewer streaming experiences across multiple devices and platforms. You can stream live or on-demand online videos within minutes.

API version: 1.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package video-api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// LiveApiService LiveApi service
type LiveApiService service

type ApiDELETELiveStreamsLiveStreamIdRequest struct {
	ctx context.Context
	ApiService *LiveApiService
	liveStreamId string
}

func (r ApiDELETELiveStreamsLiveStreamIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DELETELiveStreamsLiveStreamIdExecute(r)
}

/*
DELETELiveStreamsLiveStreamId Delete a live stream

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param liveStreamId The unique ID for the live stream that you want to remove.
 @return ApiDELETELiveStreamsLiveStreamIdRequest
*/
func (a *LiveApiService) DELETELiveStreamsLiveStreamId(ctx context.Context, liveStreamId string) ApiDELETELiveStreamsLiveStreamIdRequest {
	return ApiDELETELiveStreamsLiveStreamIdRequest{
		ApiService: a,
		ctx: ctx,
		liveStreamId: liveStreamId,
	}
}

// Execute executes the request
func (a *LiveApiService) DELETELiveStreamsLiveStreamIdExecute(r ApiDELETELiveStreamsLiveStreamIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveApiService.DELETELiveStreamsLiveStreamId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/live-streams/{liveStreamId}"
	localVarPath = strings.Replace(localVarPath, "{"+"liveStreamId"+"}", url.PathEscape(parameterToString(r.liveStreamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDELETELiveStreamsLiveStreamIdThumbnailRequest struct {
	ctx context.Context
	ApiService *LiveApiService
	liveStreamId string
}

func (r ApiDELETELiveStreamsLiveStreamIdThumbnailRequest) Execute() (*LiveStream, *http.Response, error) {
	return r.ApiService.DELETELiveStreamsLiveStreamIdThumbnailExecute(r)
}

/*
DELETELiveStreamsLiveStreamIdThumbnail Delete a thumbnail

Send the unique identifier for a live stream to delete it from the system.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param liveStreamId The unique identifier for the live stream you want to delete. 
 @return ApiDELETELiveStreamsLiveStreamIdThumbnailRequest
*/
func (a *LiveApiService) DELETELiveStreamsLiveStreamIdThumbnail(ctx context.Context, liveStreamId string) ApiDELETELiveStreamsLiveStreamIdThumbnailRequest {
	return ApiDELETELiveStreamsLiveStreamIdThumbnailRequest{
		ApiService: a,
		ctx: ctx,
		liveStreamId: liveStreamId,
	}
}

// Execute executes the request
//  @return LiveStream
func (a *LiveApiService) DELETELiveStreamsLiveStreamIdThumbnailExecute(r ApiDELETELiveStreamsLiveStreamIdThumbnailRequest) (*LiveStream, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LiveStream
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveApiService.DELETELiveStreamsLiveStreamIdThumbnail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/live-streams/{liveStreamId}/thumbnail"
	localVarPath = strings.Replace(localVarPath, "{"+"liveStreamId"+"}", url.PathEscape(parameterToString(r.liveStreamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETLiveStreamsRequest struct {
	ctx context.Context
	ApiService *LiveApiService
	streamKey *string
	name *string
	sortBy *string
	sortOrder *string
	currentPage *int32
	pageSize *int32
}

// The unique stream key that allows you to stream videos.
func (r ApiGETLiveStreamsRequest) StreamKey(streamKey string) ApiGETLiveStreamsRequest {
	r.streamKey = &streamKey
	return r
}

// You can filter live streams by their name or a part of their name.
func (r ApiGETLiveStreamsRequest) Name(name string) ApiGETLiveStreamsRequest {
	r.name = &name
	return r
}

// Allowed: createdAt, publishedAt, name. createdAt - the time a livestream was created using the specified streamKey. publishedAt - the time a livestream was published using the specified streamKey. name - the name of the livestream. If you choose one of the time based options, the time is presented in ISO-8601 format.
func (r ApiGETLiveStreamsRequest) SortBy(sortBy string) ApiGETLiveStreamsRequest {
	r.sortBy = &sortBy
	return r
}

// Allowed: asc, desc. Ascending for date and time means that earlier values precede later ones. Descending means that later values preced earlier ones. For title, it is 0-9 and A-Z ascending and Z-A, 9-0 descending.
func (r ApiGETLiveStreamsRequest) SortOrder(sortOrder string) ApiGETLiveStreamsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Choose the number of search results to return per page. Minimum value: 1
func (r ApiGETLiveStreamsRequest) CurrentPage(currentPage int32) ApiGETLiveStreamsRequest {
	r.currentPage = &currentPage
	return r
}

// Results per page. Allowed values 1-100, default is 25.
func (r ApiGETLiveStreamsRequest) PageSize(pageSize int32) ApiGETLiveStreamsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGETLiveStreamsRequest) Execute() (*LiveStreamListResponse, *http.Response, error) {
	return r.ApiService.GETLiveStreamsExecute(r)
}

/*
GETLiveStreams List all live streams

With no parameters added to the url, this will return all livestreams. Query by name or key to limit the list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGETLiveStreamsRequest
*/
func (a *LiveApiService) GETLiveStreams(ctx context.Context) ApiGETLiveStreamsRequest {
	return ApiGETLiveStreamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LiveStreamListResponse
func (a *LiveApiService) GETLiveStreamsExecute(r ApiGETLiveStreamsRequest) (*LiveStreamListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LiveStreamListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveApiService.GETLiveStreams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/live-streams"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.streamKey != nil {
		localVarQueryParams.Add("streamKey", parameterToString(*r.streamKey, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("sortOrder", parameterToString(*r.sortOrder, ""))
	}
	if r.currentPage != nil {
		localVarQueryParams.Add("currentPage", parameterToString(*r.currentPage, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETLiveStreamsLiveStreamIdRequest struct {
	ctx context.Context
	ApiService *LiveApiService
	liveStreamId string
}

func (r ApiGETLiveStreamsLiveStreamIdRequest) Execute() (*LiveStream, *http.Response, error) {
	return r.ApiService.GETLiveStreamsLiveStreamIdExecute(r)
}

/*
GETLiveStreamsLiveStreamId Show live stream

Supply a LivestreamId, and you'll get all the details for streaming into, and watching the livestream. Tutorials that use the [show livestream endpoint](https://api.video/blog/endpoints/live-stream-status).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param liveStreamId The unique ID for the live stream you want to watch.
 @return ApiGETLiveStreamsLiveStreamIdRequest
*/
func (a *LiveApiService) GETLiveStreamsLiveStreamId(ctx context.Context, liveStreamId string) ApiGETLiveStreamsLiveStreamIdRequest {
	return ApiGETLiveStreamsLiveStreamIdRequest{
		ApiService: a,
		ctx: ctx,
		liveStreamId: liveStreamId,
	}
}

// Execute executes the request
//  @return LiveStream
func (a *LiveApiService) GETLiveStreamsLiveStreamIdExecute(r ApiGETLiveStreamsLiveStreamIdRequest) (*LiveStream, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LiveStream
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveApiService.GETLiveStreamsLiveStreamId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/live-streams/{liveStreamId}"
	localVarPath = strings.Replace(localVarPath, "{"+"liveStreamId"+"}", url.PathEscape(parameterToString(r.liveStreamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPATCHLiveStreamsLiveStreamIdRequest struct {
	ctx context.Context
	ApiService *LiveApiService
	liveStreamId string
	liveStreamUpdatePayload *LiveStreamUpdatePayload
}

func (r ApiPATCHLiveStreamsLiveStreamIdRequest) LiveStreamUpdatePayload(liveStreamUpdatePayload LiveStreamUpdatePayload) ApiPATCHLiveStreamsLiveStreamIdRequest {
	r.liveStreamUpdatePayload = &liveStreamUpdatePayload
	return r
}

func (r ApiPATCHLiveStreamsLiveStreamIdRequest) Execute() (*LiveStream, *http.Response, error) {
	return r.ApiService.PATCHLiveStreamsLiveStreamIdExecute(r)
}

/*
PATCHLiveStreamsLiveStreamId Update a live stream

Use this endpoint to update the player, or to turn recording on/off (saving a copy of the livestream). NOTE: If the livestream is actively streaming, changing the recording status will only affect the NEXT stream.    The public=false 'private livestream' is available as a BETA feature, and should be limited to livestreams of 3,000 viewers or fewer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param liveStreamId The unique ID for the live stream that you want to update information for such as player details, or whether you want the recording on or off.
 @return ApiPATCHLiveStreamsLiveStreamIdRequest
*/
func (a *LiveApiService) PATCHLiveStreamsLiveStreamId(ctx context.Context, liveStreamId string) ApiPATCHLiveStreamsLiveStreamIdRequest {
	return ApiPATCHLiveStreamsLiveStreamIdRequest{
		ApiService: a,
		ctx: ctx,
		liveStreamId: liveStreamId,
	}
}

// Execute executes the request
//  @return LiveStream
func (a *LiveApiService) PATCHLiveStreamsLiveStreamIdExecute(r ApiPATCHLiveStreamsLiveStreamIdRequest) (*LiveStream, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LiveStream
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveApiService.PATCHLiveStreamsLiveStreamId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/live-streams/{liveStreamId}"
	localVarPath = strings.Replace(localVarPath, "{"+"liveStreamId"+"}", url.PathEscape(parameterToString(r.liveStreamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.liveStreamUpdatePayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPOSTLiveStreamsRequest struct {
	ctx context.Context
	ApiService *LiveApiService
	liveStreamCreatePayload *LiveStreamCreatePayload
}

func (r ApiPOSTLiveStreamsRequest) LiveStreamCreatePayload(liveStreamCreatePayload LiveStreamCreatePayload) ApiPOSTLiveStreamsRequest {
	r.liveStreamCreatePayload = &liveStreamCreatePayload
	return r
}

func (r ApiPOSTLiveStreamsRequest) Execute() (*LiveStream, *http.Response, error) {
	return r.ApiService.POSTLiveStreamsExecute(r)
}

/*
POSTLiveStreams Create live stream

A live stream will give you the 'connection point' to RTMP your video stream to api.video. It will also give you the details for viewers to watch the same livestream.  The public=false 'private livestream' is available as a BETA feature, and should be limited to livestreams of 3,000 viewers or fewer. See our [Live Stream Tutorial](https://api.video/blog/tutorials/live-stream-tutorial) for a walkthrough of this API with OBS. Your RTMP endpoint for the livestream is rtmp://broadcast.api.video/s/{streamKey}
Tutorials that [create live streams](https://api.video/blog/endpoints/live-create).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPOSTLiveStreamsRequest
*/
func (a *LiveApiService) POSTLiveStreams(ctx context.Context) ApiPOSTLiveStreamsRequest {
	return ApiPOSTLiveStreamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LiveStream
func (a *LiveApiService) POSTLiveStreamsExecute(r ApiPOSTLiveStreamsRequest) (*LiveStream, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LiveStream
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveApiService.POSTLiveStreams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/live-streams"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.liveStreamCreatePayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPOSTLiveStreamsLiveStreamIdThumbnailRequest struct {
	ctx context.Context
	ApiService *LiveApiService
	liveStreamId string
	file **os.File
}

// The image to be added as a thumbnail.
func (r ApiPOSTLiveStreamsLiveStreamIdThumbnailRequest) File(file *os.File) ApiPOSTLiveStreamsLiveStreamIdThumbnailRequest {
	r.file = &file
	return r
}

func (r ApiPOSTLiveStreamsLiveStreamIdThumbnailRequest) Execute() (*LiveStream, *http.Response, error) {
	return r.ApiService.POSTLiveStreamsLiveStreamIdThumbnailExecute(r)
}

/*
POSTLiveStreamsLiveStreamIdThumbnail Upload a thumbnail

Upload an image to use as a backdrop for your livestream. Tutorials that [update live stream thumbnails](https://api.video/blog/endpoints/live-upload-a-thumbnail).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param liveStreamId The unique ID for the live stream you want to upload.
 @return ApiPOSTLiveStreamsLiveStreamIdThumbnailRequest
*/
func (a *LiveApiService) POSTLiveStreamsLiveStreamIdThumbnail(ctx context.Context, liveStreamId string) ApiPOSTLiveStreamsLiveStreamIdThumbnailRequest {
	return ApiPOSTLiveStreamsLiveStreamIdThumbnailRequest{
		ApiService: a,
		ctx: ctx,
		liveStreamId: liveStreamId,
	}
}

// Execute executes the request
//  @return LiveStream
func (a *LiveApiService) POSTLiveStreamsLiveStreamIdThumbnailExecute(r ApiPOSTLiveStreamsLiveStreamIdThumbnailRequest) (*LiveStream, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LiveStream
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveApiService.POSTLiveStreamsLiveStreamIdThumbnail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/live-streams/{liveStreamId}/thumbnail"
	localVarPath = strings.Replace(localVarPath, "{"+"liveStreamId"+"}", url.PathEscape(parameterToString(r.liveStreamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"

	fileLocalVarFile := *r.file
	if fileLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(fileLocalVarFile)
		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
