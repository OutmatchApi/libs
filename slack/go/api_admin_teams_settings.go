/*
Slack Web API

One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.

API version: 1.7.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package slack

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// AdminTeamsSettingsApiService AdminTeamsSettingsApi service
type AdminTeamsSettingsApiService service

type ApiAdminTeamsSettingsInfoRequest struct {
	ctx context.Context
	ApiService *AdminTeamsSettingsApiService
	token *string
	teamId *string
}

// Authentication token. Requires scope: &#x60;admin.teams:read&#x60;
func (r ApiAdminTeamsSettingsInfoRequest) Token(token string) ApiAdminTeamsSettingsInfoRequest {
	r.token = &token
	return r
}

func (r ApiAdminTeamsSettingsInfoRequest) TeamId(teamId string) ApiAdminTeamsSettingsInfoRequest {
	r.teamId = &teamId
	return r
}

func (r ApiAdminTeamsSettingsInfoRequest) Execute() (*DefaultSuccessTemplate, *http.Response, error) {
	return r.ApiService.AdminTeamsSettingsInfoExecute(r)
}

/*
AdminTeamsSettingsInfo Method for AdminTeamsSettingsInfo

Fetch information about settings in a workspace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminTeamsSettingsInfoRequest
*/
func (a *AdminTeamsSettingsApiService) AdminTeamsSettingsInfo(ctx context.Context) ApiAdminTeamsSettingsInfoRequest {
	return ApiAdminTeamsSettingsInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DefaultSuccessTemplate
func (a *AdminTeamsSettingsApiService) AdminTeamsSettingsInfoExecute(r ApiAdminTeamsSettingsInfoRequest) (*DefaultSuccessTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefaultSuccessTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminTeamsSettingsApiService.AdminTeamsSettingsInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin.teams.settings.info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.teamId == nil {
		return localVarReturnValue, nil, reportError("teamId is required and must be specified")
	}

	localVarQueryParams.Add("team_id", parameterToString(*r.teamId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v DefaultErrorTemplate
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminTeamsSettingsSetDefaultChannelsRequest struct {
	ctx context.Context
	ApiService *AdminTeamsSettingsApiService
	channelIds *string
	teamId *string
	token *string
}

// An array of channel IDs.
func (r ApiAdminTeamsSettingsSetDefaultChannelsRequest) ChannelIds(channelIds string) ApiAdminTeamsSettingsSetDefaultChannelsRequest {
	r.channelIds = &channelIds
	return r
}

// ID for the workspace to set the default channel for.
func (r ApiAdminTeamsSettingsSetDefaultChannelsRequest) TeamId(teamId string) ApiAdminTeamsSettingsSetDefaultChannelsRequest {
	r.teamId = &teamId
	return r
}

// Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
func (r ApiAdminTeamsSettingsSetDefaultChannelsRequest) Token(token string) ApiAdminTeamsSettingsSetDefaultChannelsRequest {
	r.token = &token
	return r
}

func (r ApiAdminTeamsSettingsSetDefaultChannelsRequest) Execute() (*DefaultSuccessTemplate, *http.Response, error) {
	return r.ApiService.AdminTeamsSettingsSetDefaultChannelsExecute(r)
}

/*
AdminTeamsSettingsSetDefaultChannels Method for AdminTeamsSettingsSetDefaultChannels

Set the default channels of a workspace.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminTeamsSettingsSetDefaultChannelsRequest
*/
func (a *AdminTeamsSettingsApiService) AdminTeamsSettingsSetDefaultChannels(ctx context.Context) ApiAdminTeamsSettingsSetDefaultChannelsRequest {
	return ApiAdminTeamsSettingsSetDefaultChannelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DefaultSuccessTemplate
func (a *AdminTeamsSettingsApiService) AdminTeamsSettingsSetDefaultChannelsExecute(r ApiAdminTeamsSettingsSetDefaultChannelsRequest) (*DefaultSuccessTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefaultSuccessTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminTeamsSettingsApiService.AdminTeamsSettingsSetDefaultChannels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin.teams.settings.setDefaultChannels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.channelIds == nil {
		return localVarReturnValue, nil, reportError("channelIds is required and must be specified")
	}
	if r.teamId == nil {
		return localVarReturnValue, nil, reportError("teamId is required and must be specified")
	}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("channel_ids", parameterToString(*r.channelIds, ""))
	localVarFormParams.Add("team_id", parameterToString(*r.teamId, ""))
	localVarFormParams.Add("token", parameterToString(*r.token, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v DefaultErrorTemplate
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminTeamsSettingsSetDescriptionRequest struct {
	ctx context.Context
	ApiService *AdminTeamsSettingsApiService
	token *string
	description *string
	teamId *string
}

// Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
func (r ApiAdminTeamsSettingsSetDescriptionRequest) Token(token string) ApiAdminTeamsSettingsSetDescriptionRequest {
	r.token = &token
	return r
}

// The new description for the workspace.
func (r ApiAdminTeamsSettingsSetDescriptionRequest) Description(description string) ApiAdminTeamsSettingsSetDescriptionRequest {
	r.description = &description
	return r
}

// ID for the workspace to set the description for.
func (r ApiAdminTeamsSettingsSetDescriptionRequest) TeamId(teamId string) ApiAdminTeamsSettingsSetDescriptionRequest {
	r.teamId = &teamId
	return r
}

func (r ApiAdminTeamsSettingsSetDescriptionRequest) Execute() (*DefaultSuccessTemplate, *http.Response, error) {
	return r.ApiService.AdminTeamsSettingsSetDescriptionExecute(r)
}

/*
AdminTeamsSettingsSetDescription Method for AdminTeamsSettingsSetDescription

Set the description of a given workspace.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminTeamsSettingsSetDescriptionRequest
*/
func (a *AdminTeamsSettingsApiService) AdminTeamsSettingsSetDescription(ctx context.Context) ApiAdminTeamsSettingsSetDescriptionRequest {
	return ApiAdminTeamsSettingsSetDescriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DefaultSuccessTemplate
func (a *AdminTeamsSettingsApiService) AdminTeamsSettingsSetDescriptionExecute(r ApiAdminTeamsSettingsSetDescriptionRequest) (*DefaultSuccessTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefaultSuccessTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminTeamsSettingsApiService.AdminTeamsSettingsSetDescription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin.teams.settings.setDescription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.description == nil {
		return localVarReturnValue, nil, reportError("description is required and must be specified")
	}
	if r.teamId == nil {
		return localVarReturnValue, nil, reportError("teamId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	localVarFormParams.Add("description", parameterToString(*r.description, ""))
	localVarFormParams.Add("team_id", parameterToString(*r.teamId, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v DefaultErrorTemplate
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminTeamsSettingsSetDiscoverabilityRequest struct {
	ctx context.Context
	ApiService *AdminTeamsSettingsApiService
	token *string
	discoverability *string
	teamId *string
}

// Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
func (r ApiAdminTeamsSettingsSetDiscoverabilityRequest) Token(token string) ApiAdminTeamsSettingsSetDiscoverabilityRequest {
	r.token = &token
	return r
}

// This workspace&#39;s discovery setting. It must be set to one of &#x60;open&#x60;, &#x60;invite_only&#x60;, &#x60;closed&#x60;, or &#x60;unlisted&#x60;.
func (r ApiAdminTeamsSettingsSetDiscoverabilityRequest) Discoverability(discoverability string) ApiAdminTeamsSettingsSetDiscoverabilityRequest {
	r.discoverability = &discoverability
	return r
}

// The ID of the workspace to set discoverability on.
func (r ApiAdminTeamsSettingsSetDiscoverabilityRequest) TeamId(teamId string) ApiAdminTeamsSettingsSetDiscoverabilityRequest {
	r.teamId = &teamId
	return r
}

func (r ApiAdminTeamsSettingsSetDiscoverabilityRequest) Execute() (*DefaultSuccessTemplate, *http.Response, error) {
	return r.ApiService.AdminTeamsSettingsSetDiscoverabilityExecute(r)
}

/*
AdminTeamsSettingsSetDiscoverability Method for AdminTeamsSettingsSetDiscoverability

An API method that allows admins to set the discoverability of a given workspace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminTeamsSettingsSetDiscoverabilityRequest
*/
func (a *AdminTeamsSettingsApiService) AdminTeamsSettingsSetDiscoverability(ctx context.Context) ApiAdminTeamsSettingsSetDiscoverabilityRequest {
	return ApiAdminTeamsSettingsSetDiscoverabilityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DefaultSuccessTemplate
func (a *AdminTeamsSettingsApiService) AdminTeamsSettingsSetDiscoverabilityExecute(r ApiAdminTeamsSettingsSetDiscoverabilityRequest) (*DefaultSuccessTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefaultSuccessTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminTeamsSettingsApiService.AdminTeamsSettingsSetDiscoverability")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin.teams.settings.setDiscoverability"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.discoverability == nil {
		return localVarReturnValue, nil, reportError("discoverability is required and must be specified")
	}
	if r.teamId == nil {
		return localVarReturnValue, nil, reportError("teamId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	localVarFormParams.Add("discoverability", parameterToString(*r.discoverability, ""))
	localVarFormParams.Add("team_id", parameterToString(*r.teamId, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v DefaultErrorTemplate
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminTeamsSettingsSetIconRequest struct {
	ctx context.Context
	ApiService *AdminTeamsSettingsApiService
	imageUrl *string
	teamId *string
	token *string
}

// Image URL for the icon
func (r ApiAdminTeamsSettingsSetIconRequest) ImageUrl(imageUrl string) ApiAdminTeamsSettingsSetIconRequest {
	r.imageUrl = &imageUrl
	return r
}

// ID for the workspace to set the icon for.
func (r ApiAdminTeamsSettingsSetIconRequest) TeamId(teamId string) ApiAdminTeamsSettingsSetIconRequest {
	r.teamId = &teamId
	return r
}

// Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
func (r ApiAdminTeamsSettingsSetIconRequest) Token(token string) ApiAdminTeamsSettingsSetIconRequest {
	r.token = &token
	return r
}

func (r ApiAdminTeamsSettingsSetIconRequest) Execute() (*DefaultSuccessTemplate, *http.Response, error) {
	return r.ApiService.AdminTeamsSettingsSetIconExecute(r)
}

/*
AdminTeamsSettingsSetIcon Method for AdminTeamsSettingsSetIcon

Sets the icon of a workspace.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminTeamsSettingsSetIconRequest
*/
func (a *AdminTeamsSettingsApiService) AdminTeamsSettingsSetIcon(ctx context.Context) ApiAdminTeamsSettingsSetIconRequest {
	return ApiAdminTeamsSettingsSetIconRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DefaultSuccessTemplate
func (a *AdminTeamsSettingsApiService) AdminTeamsSettingsSetIconExecute(r ApiAdminTeamsSettingsSetIconRequest) (*DefaultSuccessTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefaultSuccessTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminTeamsSettingsApiService.AdminTeamsSettingsSetIcon")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin.teams.settings.setIcon"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.imageUrl == nil {
		return localVarReturnValue, nil, reportError("imageUrl is required and must be specified")
	}
	if r.teamId == nil {
		return localVarReturnValue, nil, reportError("teamId is required and must be specified")
	}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("image_url", parameterToString(*r.imageUrl, ""))
	localVarFormParams.Add("team_id", parameterToString(*r.teamId, ""))
	localVarFormParams.Add("token", parameterToString(*r.token, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v DefaultErrorTemplate
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminTeamsSettingsSetNameRequest struct {
	ctx context.Context
	ApiService *AdminTeamsSettingsApiService
	token *string
	name *string
	teamId *string
}

// Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
func (r ApiAdminTeamsSettingsSetNameRequest) Token(token string) ApiAdminTeamsSettingsSetNameRequest {
	r.token = &token
	return r
}

// The new name of the workspace.
func (r ApiAdminTeamsSettingsSetNameRequest) Name(name string) ApiAdminTeamsSettingsSetNameRequest {
	r.name = &name
	return r
}

// ID for the workspace to set the name for.
func (r ApiAdminTeamsSettingsSetNameRequest) TeamId(teamId string) ApiAdminTeamsSettingsSetNameRequest {
	r.teamId = &teamId
	return r
}

func (r ApiAdminTeamsSettingsSetNameRequest) Execute() (*DefaultSuccessTemplate, *http.Response, error) {
	return r.ApiService.AdminTeamsSettingsSetNameExecute(r)
}

/*
AdminTeamsSettingsSetName Method for AdminTeamsSettingsSetName

Set the name of a given workspace.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminTeamsSettingsSetNameRequest
*/
func (a *AdminTeamsSettingsApiService) AdminTeamsSettingsSetName(ctx context.Context) ApiAdminTeamsSettingsSetNameRequest {
	return ApiAdminTeamsSettingsSetNameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DefaultSuccessTemplate
func (a *AdminTeamsSettingsApiService) AdminTeamsSettingsSetNameExecute(r ApiAdminTeamsSettingsSetNameRequest) (*DefaultSuccessTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefaultSuccessTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminTeamsSettingsApiService.AdminTeamsSettingsSetName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin.teams.settings.setName"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.teamId == nil {
		return localVarReturnValue, nil, reportError("teamId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	localVarFormParams.Add("name", parameterToString(*r.name, ""))
	localVarFormParams.Add("team_id", parameterToString(*r.teamId, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v DefaultErrorTemplate
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
