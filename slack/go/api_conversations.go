/*
Slack Web API

One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.

API version: 1.7.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package slack

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// ConversationsApiService ConversationsApi service
type ConversationsApiService service

type ApiConversationsArchiveRequest struct {
	ctx context.Context
	ApiService *ConversationsApiService
	token *string
	channel *string
}

// Authentication token. Requires scope: &#x60;conversations:write&#x60;
func (r ApiConversationsArchiveRequest) Token(token string) ApiConversationsArchiveRequest {
	r.token = &token
	return r
}

// ID of conversation to archive
func (r ApiConversationsArchiveRequest) Channel(channel string) ApiConversationsArchiveRequest {
	r.channel = &channel
	return r
}

func (r ApiConversationsArchiveRequest) Execute() (*ConversationsArchiveSuccessSchema, *http.Response, error) {
	return r.ApiService.ConversationsArchiveExecute(r)
}

/*
ConversationsArchive Method for ConversationsArchive

Archives a conversation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConversationsArchiveRequest
*/
func (a *ConversationsApiService) ConversationsArchive(ctx context.Context) ApiConversationsArchiveRequest {
	return ApiConversationsArchiveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationsArchiveSuccessSchema
func (a *ConversationsApiService) ConversationsArchiveExecute(r ApiConversationsArchiveRequest) (*ConversationsArchiveSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationsArchiveSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsApiService.ConversationsArchive")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations.archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.token != nil {
		localVarHeaderParams["token"] = parameterToString(*r.token, "")
	}
	if r.channel != nil {
		localVarFormParams.Add("channel", parameterToString(*r.channel, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ConversationsArchiveErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConversationsCloseRequest struct {
	ctx context.Context
	ApiService *ConversationsApiService
	token *string
	channel *string
}

// Authentication token. Requires scope: &#x60;conversations:write&#x60;
func (r ApiConversationsCloseRequest) Token(token string) ApiConversationsCloseRequest {
	r.token = &token
	return r
}

// Conversation to close.
func (r ApiConversationsCloseRequest) Channel(channel string) ApiConversationsCloseRequest {
	r.channel = &channel
	return r
}

func (r ApiConversationsCloseRequest) Execute() (*ConversationsCloseSuccessSchema, *http.Response, error) {
	return r.ApiService.ConversationsCloseExecute(r)
}

/*
ConversationsClose Method for ConversationsClose

Closes a direct message or multi-person direct message.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConversationsCloseRequest
*/
func (a *ConversationsApiService) ConversationsClose(ctx context.Context) ApiConversationsCloseRequest {
	return ApiConversationsCloseRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationsCloseSuccessSchema
func (a *ConversationsApiService) ConversationsCloseExecute(r ApiConversationsCloseRequest) (*ConversationsCloseSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationsCloseSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsApiService.ConversationsClose")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations.close"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.token != nil {
		localVarHeaderParams["token"] = parameterToString(*r.token, "")
	}
	if r.channel != nil {
		localVarFormParams.Add("channel", parameterToString(*r.channel, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ConversationsCloseErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConversationsCreateRequest struct {
	ctx context.Context
	ApiService *ConversationsApiService
	token *string
	isPrivate *bool
	name *string
}

// Authentication token. Requires scope: &#x60;conversations:write&#x60;
func (r ApiConversationsCreateRequest) Token(token string) ApiConversationsCreateRequest {
	r.token = &token
	return r
}

// Create a private channel instead of a public one
func (r ApiConversationsCreateRequest) IsPrivate(isPrivate bool) ApiConversationsCreateRequest {
	r.isPrivate = &isPrivate
	return r
}

// Name of the public or private channel to create
func (r ApiConversationsCreateRequest) Name(name string) ApiConversationsCreateRequest {
	r.name = &name
	return r
}

func (r ApiConversationsCreateRequest) Execute() (*ConversationsCreateSuccessSchema, *http.Response, error) {
	return r.ApiService.ConversationsCreateExecute(r)
}

/*
ConversationsCreate Method for ConversationsCreate

Initiates a public or private channel-based conversation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConversationsCreateRequest
*/
func (a *ConversationsApiService) ConversationsCreate(ctx context.Context) ApiConversationsCreateRequest {
	return ApiConversationsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationsCreateSuccessSchema
func (a *ConversationsApiService) ConversationsCreateExecute(r ApiConversationsCreateRequest) (*ConversationsCreateSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationsCreateSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsApiService.ConversationsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations.create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.token != nil {
		localVarHeaderParams["token"] = parameterToString(*r.token, "")
	}
	if r.isPrivate != nil {
		localVarFormParams.Add("is_private", parameterToString(*r.isPrivate, ""))
	}
	if r.name != nil {
		localVarFormParams.Add("name", parameterToString(*r.name, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ConversationsCreateErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConversationsHistoryRequest struct {
	ctx context.Context
	ApiService *ConversationsApiService
	token *string
	channel *string
	latest *float32
	oldest *float32
	inclusive *bool
	limit *int32
	cursor *string
}

// Authentication token. Requires scope: &#x60;conversations:history&#x60;
func (r ApiConversationsHistoryRequest) Token(token string) ApiConversationsHistoryRequest {
	r.token = &token
	return r
}

// Conversation ID to fetch history for.
func (r ApiConversationsHistoryRequest) Channel(channel string) ApiConversationsHistoryRequest {
	r.channel = &channel
	return r
}

// End of time range of messages to include in results.
func (r ApiConversationsHistoryRequest) Latest(latest float32) ApiConversationsHistoryRequest {
	r.latest = &latest
	return r
}

// Start of time range of messages to include in results.
func (r ApiConversationsHistoryRequest) Oldest(oldest float32) ApiConversationsHistoryRequest {
	r.oldest = &oldest
	return r
}

// Include messages with latest or oldest timestamp in results only when either timestamp is specified.
func (r ApiConversationsHistoryRequest) Inclusive(inclusive bool) ApiConversationsHistoryRequest {
	r.inclusive = &inclusive
	return r
}

// The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached.
func (r ApiConversationsHistoryRequest) Limit(limit int32) ApiConversationsHistoryRequest {
	r.limit = &limit
	return r
}

// Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail.
func (r ApiConversationsHistoryRequest) Cursor(cursor string) ApiConversationsHistoryRequest {
	r.cursor = &cursor
	return r
}

func (r ApiConversationsHistoryRequest) Execute() (*ConversationsHistorySuccessSchema, *http.Response, error) {
	return r.ApiService.ConversationsHistoryExecute(r)
}

/*
ConversationsHistory Method for ConversationsHistory

Fetches a conversation's history of messages and events.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConversationsHistoryRequest
*/
func (a *ConversationsApiService) ConversationsHistory(ctx context.Context) ApiConversationsHistoryRequest {
	return ApiConversationsHistoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationsHistorySuccessSchema
func (a *ConversationsApiService) ConversationsHistoryExecute(r ApiConversationsHistoryRequest) (*ConversationsHistorySuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationsHistorySuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsApiService.ConversationsHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations.history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.token != nil {
		localVarQueryParams.Add("token", parameterToString(*r.token, ""))
	}
	if r.channel != nil {
		localVarQueryParams.Add("channel", parameterToString(*r.channel, ""))
	}
	if r.latest != nil {
		localVarQueryParams.Add("latest", parameterToString(*r.latest, ""))
	}
	if r.oldest != nil {
		localVarQueryParams.Add("oldest", parameterToString(*r.oldest, ""))
	}
	if r.inclusive != nil {
		localVarQueryParams.Add("inclusive", parameterToString(*r.inclusive, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.cursor != nil {
		localVarQueryParams.Add("cursor", parameterToString(*r.cursor, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ConversationsHistoryErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConversationsInfoRequest struct {
	ctx context.Context
	ApiService *ConversationsApiService
	token *string
	channel *string
	includeLocale *bool
	includeNumMembers *bool
}

// Authentication token. Requires scope: &#x60;conversations:read&#x60;
func (r ApiConversationsInfoRequest) Token(token string) ApiConversationsInfoRequest {
	r.token = &token
	return r
}

// Conversation ID to learn more about
func (r ApiConversationsInfoRequest) Channel(channel string) ApiConversationsInfoRequest {
	r.channel = &channel
	return r
}

// Set this to &#x60;true&#x60; to receive the locale for this conversation. Defaults to &#x60;false&#x60;
func (r ApiConversationsInfoRequest) IncludeLocale(includeLocale bool) ApiConversationsInfoRequest {
	r.includeLocale = &includeLocale
	return r
}

// Set to &#x60;true&#x60; to include the member count for the specified conversation. Defaults to &#x60;false&#x60;
func (r ApiConversationsInfoRequest) IncludeNumMembers(includeNumMembers bool) ApiConversationsInfoRequest {
	r.includeNumMembers = &includeNumMembers
	return r
}

func (r ApiConversationsInfoRequest) Execute() (*ConversationsInfoSuccessSchema, *http.Response, error) {
	return r.ApiService.ConversationsInfoExecute(r)
}

/*
ConversationsInfo Method for ConversationsInfo

Retrieve information about a conversation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConversationsInfoRequest
*/
func (a *ConversationsApiService) ConversationsInfo(ctx context.Context) ApiConversationsInfoRequest {
	return ApiConversationsInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationsInfoSuccessSchema
func (a *ConversationsApiService) ConversationsInfoExecute(r ApiConversationsInfoRequest) (*ConversationsInfoSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationsInfoSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsApiService.ConversationsInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations.info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.token != nil {
		localVarQueryParams.Add("token", parameterToString(*r.token, ""))
	}
	if r.channel != nil {
		localVarQueryParams.Add("channel", parameterToString(*r.channel, ""))
	}
	if r.includeLocale != nil {
		localVarQueryParams.Add("include_locale", parameterToString(*r.includeLocale, ""))
	}
	if r.includeNumMembers != nil {
		localVarQueryParams.Add("include_num_members", parameterToString(*r.includeNumMembers, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ConversationsInfoErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConversationsInviteRequest struct {
	ctx context.Context
	ApiService *ConversationsApiService
	token *string
	channel *string
	users *string
}

// Authentication token. Requires scope: &#x60;conversations:write&#x60;
func (r ApiConversationsInviteRequest) Token(token string) ApiConversationsInviteRequest {
	r.token = &token
	return r
}

// The ID of the public or private channel to invite user(s) to.
func (r ApiConversationsInviteRequest) Channel(channel string) ApiConversationsInviteRequest {
	r.channel = &channel
	return r
}

// A comma separated list of user IDs. Up to 1000 users may be listed.
func (r ApiConversationsInviteRequest) Users(users string) ApiConversationsInviteRequest {
	r.users = &users
	return r
}

func (r ApiConversationsInviteRequest) Execute() (*ConversationsInviteErrorSchema, *http.Response, error) {
	return r.ApiService.ConversationsInviteExecute(r)
}

/*
ConversationsInvite Method for ConversationsInvite

Invites users to a channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConversationsInviteRequest
*/
func (a *ConversationsApiService) ConversationsInvite(ctx context.Context) ApiConversationsInviteRequest {
	return ApiConversationsInviteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationsInviteErrorSchema
func (a *ConversationsApiService) ConversationsInviteExecute(r ApiConversationsInviteRequest) (*ConversationsInviteErrorSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationsInviteErrorSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsApiService.ConversationsInvite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations.invite"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.token != nil {
		localVarHeaderParams["token"] = parameterToString(*r.token, "")
	}
	if r.channel != nil {
		localVarFormParams.Add("channel", parameterToString(*r.channel, ""))
	}
	if r.users != nil {
		localVarFormParams.Add("users", parameterToString(*r.users, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ConversationsInviteErrorSchema1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConversationsJoinRequest struct {
	ctx context.Context
	ApiService *ConversationsApiService
	token *string
	channel *string
}

// Authentication token. Requires scope: &#x60;channels:write&#x60;
func (r ApiConversationsJoinRequest) Token(token string) ApiConversationsJoinRequest {
	r.token = &token
	return r
}

// ID of conversation to join
func (r ApiConversationsJoinRequest) Channel(channel string) ApiConversationsJoinRequest {
	r.channel = &channel
	return r
}

func (r ApiConversationsJoinRequest) Execute() (*ConversationsJoinSuccessSchema, *http.Response, error) {
	return r.ApiService.ConversationsJoinExecute(r)
}

/*
ConversationsJoin Method for ConversationsJoin

Joins an existing conversation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConversationsJoinRequest
*/
func (a *ConversationsApiService) ConversationsJoin(ctx context.Context) ApiConversationsJoinRequest {
	return ApiConversationsJoinRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationsJoinSuccessSchema
func (a *ConversationsApiService) ConversationsJoinExecute(r ApiConversationsJoinRequest) (*ConversationsJoinSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationsJoinSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsApiService.ConversationsJoin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations.join"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.token != nil {
		localVarHeaderParams["token"] = parameterToString(*r.token, "")
	}
	if r.channel != nil {
		localVarFormParams.Add("channel", parameterToString(*r.channel, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ConversationsJoinErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConversationsKickRequest struct {
	ctx context.Context
	ApiService *ConversationsApiService
	token *string
	channel *string
	user *string
}

// Authentication token. Requires scope: &#x60;conversations:write&#x60;
func (r ApiConversationsKickRequest) Token(token string) ApiConversationsKickRequest {
	r.token = &token
	return r
}

// ID of conversation to remove user from.
func (r ApiConversationsKickRequest) Channel(channel string) ApiConversationsKickRequest {
	r.channel = &channel
	return r
}

// User ID to be removed.
func (r ApiConversationsKickRequest) User(user string) ApiConversationsKickRequest {
	r.user = &user
	return r
}

func (r ApiConversationsKickRequest) Execute() (*ConversationsKickSuccessSchema, *http.Response, error) {
	return r.ApiService.ConversationsKickExecute(r)
}

/*
ConversationsKick Method for ConversationsKick

Removes a user from a conversation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConversationsKickRequest
*/
func (a *ConversationsApiService) ConversationsKick(ctx context.Context) ApiConversationsKickRequest {
	return ApiConversationsKickRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationsKickSuccessSchema
func (a *ConversationsApiService) ConversationsKickExecute(r ApiConversationsKickRequest) (*ConversationsKickSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationsKickSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsApiService.ConversationsKick")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations.kick"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.token != nil {
		localVarHeaderParams["token"] = parameterToString(*r.token, "")
	}
	if r.channel != nil {
		localVarFormParams.Add("channel", parameterToString(*r.channel, ""))
	}
	if r.user != nil {
		localVarFormParams.Add("user", parameterToString(*r.user, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ConversationsKickErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConversationsLeaveRequest struct {
	ctx context.Context
	ApiService *ConversationsApiService
	token *string
	channel *string
}

// Authentication token. Requires scope: &#x60;conversations:write&#x60;
func (r ApiConversationsLeaveRequest) Token(token string) ApiConversationsLeaveRequest {
	r.token = &token
	return r
}

// Conversation to leave
func (r ApiConversationsLeaveRequest) Channel(channel string) ApiConversationsLeaveRequest {
	r.channel = &channel
	return r
}

func (r ApiConversationsLeaveRequest) Execute() (*ConversationsLeaveSuccessSchema, *http.Response, error) {
	return r.ApiService.ConversationsLeaveExecute(r)
}

/*
ConversationsLeave Method for ConversationsLeave

Leaves a conversation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConversationsLeaveRequest
*/
func (a *ConversationsApiService) ConversationsLeave(ctx context.Context) ApiConversationsLeaveRequest {
	return ApiConversationsLeaveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationsLeaveSuccessSchema
func (a *ConversationsApiService) ConversationsLeaveExecute(r ApiConversationsLeaveRequest) (*ConversationsLeaveSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationsLeaveSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsApiService.ConversationsLeave")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations.leave"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.token != nil {
		localVarHeaderParams["token"] = parameterToString(*r.token, "")
	}
	if r.channel != nil {
		localVarFormParams.Add("channel", parameterToString(*r.channel, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ConversationsLeaveErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConversationsListRequest struct {
	ctx context.Context
	ApiService *ConversationsApiService
	token *string
	excludeArchived *bool
	types *string
	limit *int32
	cursor *string
}

// Authentication token. Requires scope: &#x60;conversations:read&#x60;
func (r ApiConversationsListRequest) Token(token string) ApiConversationsListRequest {
	r.token = &token
	return r
}

// Set to &#x60;true&#x60; to exclude archived channels from the list
func (r ApiConversationsListRequest) ExcludeArchived(excludeArchived bool) ApiConversationsListRequest {
	r.excludeArchived = &excludeArchived
	return r
}

// Mix and match channel types by providing a comma-separated list of any combination of &#x60;public_channel&#x60;, &#x60;private_channel&#x60;, &#x60;mpim&#x60;, &#x60;im&#x60;
func (r ApiConversationsListRequest) Types(types string) ApiConversationsListRequest {
	r.types = &types
	return r
}

// The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn&#39;t been reached. Must be an integer no larger than 1000.
func (r ApiConversationsListRequest) Limit(limit int32) ApiConversationsListRequest {
	r.limit = &limit
	return r
}

// Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail.
func (r ApiConversationsListRequest) Cursor(cursor string) ApiConversationsListRequest {
	r.cursor = &cursor
	return r
}

func (r ApiConversationsListRequest) Execute() (*ConversationsListSuccessSchema, *http.Response, error) {
	return r.ApiService.ConversationsListExecute(r)
}

/*
ConversationsList Method for ConversationsList

Lists all channels in a Slack team.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConversationsListRequest
*/
func (a *ConversationsApiService) ConversationsList(ctx context.Context) ApiConversationsListRequest {
	return ApiConversationsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationsListSuccessSchema
func (a *ConversationsApiService) ConversationsListExecute(r ApiConversationsListRequest) (*ConversationsListSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationsListSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsApiService.ConversationsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations.list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.token != nil {
		localVarQueryParams.Add("token", parameterToString(*r.token, ""))
	}
	if r.excludeArchived != nil {
		localVarQueryParams.Add("exclude_archived", parameterToString(*r.excludeArchived, ""))
	}
	if r.types != nil {
		localVarQueryParams.Add("types", parameterToString(*r.types, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.cursor != nil {
		localVarQueryParams.Add("cursor", parameterToString(*r.cursor, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ConversationsListErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConversationsMarkRequest struct {
	ctx context.Context
	ApiService *ConversationsApiService
	token *string
	channel *string
	ts *float32
}

// Authentication token. Requires scope: &#x60;conversations:write&#x60;
func (r ApiConversationsMarkRequest) Token(token string) ApiConversationsMarkRequest {
	r.token = &token
	return r
}

// Channel or conversation to set the read cursor for.
func (r ApiConversationsMarkRequest) Channel(channel string) ApiConversationsMarkRequest {
	r.channel = &channel
	return r
}

// Unique identifier of message you want marked as most recently seen in this conversation.
func (r ApiConversationsMarkRequest) Ts(ts float32) ApiConversationsMarkRequest {
	r.ts = &ts
	return r
}

func (r ApiConversationsMarkRequest) Execute() (*ConversationsMarkSuccessSchema, *http.Response, error) {
	return r.ApiService.ConversationsMarkExecute(r)
}

/*
ConversationsMark Method for ConversationsMark

Sets the read cursor in a channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConversationsMarkRequest
*/
func (a *ConversationsApiService) ConversationsMark(ctx context.Context) ApiConversationsMarkRequest {
	return ApiConversationsMarkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationsMarkSuccessSchema
func (a *ConversationsApiService) ConversationsMarkExecute(r ApiConversationsMarkRequest) (*ConversationsMarkSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationsMarkSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsApiService.ConversationsMark")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations.mark"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.token != nil {
		localVarHeaderParams["token"] = parameterToString(*r.token, "")
	}
	if r.channel != nil {
		localVarFormParams.Add("channel", parameterToString(*r.channel, ""))
	}
	if r.ts != nil {
		localVarFormParams.Add("ts", parameterToString(*r.ts, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ConversationsMarkErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConversationsMembersRequest struct {
	ctx context.Context
	ApiService *ConversationsApiService
	token *string
	channel *string
	limit *int32
	cursor *string
}

// Authentication token. Requires scope: &#x60;conversations:read&#x60;
func (r ApiConversationsMembersRequest) Token(token string) ApiConversationsMembersRequest {
	r.token = &token
	return r
}

// ID of the conversation to retrieve members for
func (r ApiConversationsMembersRequest) Channel(channel string) ApiConversationsMembersRequest {
	r.channel = &channel
	return r
}

// The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached.
func (r ApiConversationsMembersRequest) Limit(limit int32) ApiConversationsMembersRequest {
	r.limit = &limit
	return r
}

// Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail.
func (r ApiConversationsMembersRequest) Cursor(cursor string) ApiConversationsMembersRequest {
	r.cursor = &cursor
	return r
}

func (r ApiConversationsMembersRequest) Execute() (*ConversationsMembersSuccessSchema, *http.Response, error) {
	return r.ApiService.ConversationsMembersExecute(r)
}

/*
ConversationsMembers Method for ConversationsMembers

Retrieve members of a conversation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConversationsMembersRequest
*/
func (a *ConversationsApiService) ConversationsMembers(ctx context.Context) ApiConversationsMembersRequest {
	return ApiConversationsMembersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationsMembersSuccessSchema
func (a *ConversationsApiService) ConversationsMembersExecute(r ApiConversationsMembersRequest) (*ConversationsMembersSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationsMembersSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsApiService.ConversationsMembers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations.members"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.token != nil {
		localVarQueryParams.Add("token", parameterToString(*r.token, ""))
	}
	if r.channel != nil {
		localVarQueryParams.Add("channel", parameterToString(*r.channel, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.cursor != nil {
		localVarQueryParams.Add("cursor", parameterToString(*r.cursor, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ConversationsMembersErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConversationsOpenRequest struct {
	ctx context.Context
	ApiService *ConversationsApiService
	token *string
	channel *string
	returnIm *bool
	users *string
}

// Authentication token. Requires scope: &#x60;conversations:write&#x60;
func (r ApiConversationsOpenRequest) Token(token string) ApiConversationsOpenRequest {
	r.token = &token
	return r
}

// Resume a conversation by supplying an &#x60;im&#x60; or &#x60;mpim&#x60;&#39;s ID. Or provide the &#x60;users&#x60; field instead.
func (r ApiConversationsOpenRequest) Channel(channel string) ApiConversationsOpenRequest {
	r.channel = &channel
	return r
}

// Boolean, indicates you want the full IM channel definition in the response.
func (r ApiConversationsOpenRequest) ReturnIm(returnIm bool) ApiConversationsOpenRequest {
	r.returnIm = &returnIm
	return r
}

// Comma separated lists of users. If only one user is included, this creates a 1:1 DM.  The ordering of the users is preserved whenever a multi-person direct message is returned. Supply a &#x60;channel&#x60; when not supplying &#x60;users&#x60;.
func (r ApiConversationsOpenRequest) Users(users string) ApiConversationsOpenRequest {
	r.users = &users
	return r
}

func (r ApiConversationsOpenRequest) Execute() (*ConversationsOpenSuccessSchema, *http.Response, error) {
	return r.ApiService.ConversationsOpenExecute(r)
}

/*
ConversationsOpen Method for ConversationsOpen

Opens or resumes a direct message or multi-person direct message.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConversationsOpenRequest
*/
func (a *ConversationsApiService) ConversationsOpen(ctx context.Context) ApiConversationsOpenRequest {
	return ApiConversationsOpenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationsOpenSuccessSchema
func (a *ConversationsApiService) ConversationsOpenExecute(r ApiConversationsOpenRequest) (*ConversationsOpenSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationsOpenSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsApiService.ConversationsOpen")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations.open"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.token != nil {
		localVarHeaderParams["token"] = parameterToString(*r.token, "")
	}
	if r.channel != nil {
		localVarFormParams.Add("channel", parameterToString(*r.channel, ""))
	}
	if r.returnIm != nil {
		localVarFormParams.Add("return_im", parameterToString(*r.returnIm, ""))
	}
	if r.users != nil {
		localVarFormParams.Add("users", parameterToString(*r.users, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ConversationsOpenErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConversationsRenameRequest struct {
	ctx context.Context
	ApiService *ConversationsApiService
	token *string
	channel *string
	name *string
}

// Authentication token. Requires scope: &#x60;conversations:write&#x60;
func (r ApiConversationsRenameRequest) Token(token string) ApiConversationsRenameRequest {
	r.token = &token
	return r
}

// ID of conversation to rename
func (r ApiConversationsRenameRequest) Channel(channel string) ApiConversationsRenameRequest {
	r.channel = &channel
	return r
}

// New name for conversation.
func (r ApiConversationsRenameRequest) Name(name string) ApiConversationsRenameRequest {
	r.name = &name
	return r
}

func (r ApiConversationsRenameRequest) Execute() (*ConversationsRenameSuccessSchema, *http.Response, error) {
	return r.ApiService.ConversationsRenameExecute(r)
}

/*
ConversationsRename Method for ConversationsRename

Renames a conversation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConversationsRenameRequest
*/
func (a *ConversationsApiService) ConversationsRename(ctx context.Context) ApiConversationsRenameRequest {
	return ApiConversationsRenameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationsRenameSuccessSchema
func (a *ConversationsApiService) ConversationsRenameExecute(r ApiConversationsRenameRequest) (*ConversationsRenameSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationsRenameSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsApiService.ConversationsRename")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations.rename"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.token != nil {
		localVarHeaderParams["token"] = parameterToString(*r.token, "")
	}
	if r.channel != nil {
		localVarFormParams.Add("channel", parameterToString(*r.channel, ""))
	}
	if r.name != nil {
		localVarFormParams.Add("name", parameterToString(*r.name, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ConversationsRenameErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConversationsRepliesRequest struct {
	ctx context.Context
	ApiService *ConversationsApiService
	token *string
	channel *string
	ts *float32
	latest *float32
	oldest *float32
	inclusive *bool
	limit *int32
	cursor *string
}

// Authentication token. Requires scope: &#x60;conversations:history&#x60;
func (r ApiConversationsRepliesRequest) Token(token string) ApiConversationsRepliesRequest {
	r.token = &token
	return r
}

// Conversation ID to fetch thread from.
func (r ApiConversationsRepliesRequest) Channel(channel string) ApiConversationsRepliesRequest {
	r.channel = &channel
	return r
}

// Unique identifier of a thread&#39;s parent message. &#x60;ts&#x60; must be the timestamp of an existing message with 0 or more replies. If there are no replies then just the single message referenced by &#x60;ts&#x60; will return - it is just an ordinary, unthreaded message.
func (r ApiConversationsRepliesRequest) Ts(ts float32) ApiConversationsRepliesRequest {
	r.ts = &ts
	return r
}

// End of time range of messages to include in results.
func (r ApiConversationsRepliesRequest) Latest(latest float32) ApiConversationsRepliesRequest {
	r.latest = &latest
	return r
}

// Start of time range of messages to include in results.
func (r ApiConversationsRepliesRequest) Oldest(oldest float32) ApiConversationsRepliesRequest {
	r.oldest = &oldest
	return r
}

// Include messages with latest or oldest timestamp in results only when either timestamp is specified.
func (r ApiConversationsRepliesRequest) Inclusive(inclusive bool) ApiConversationsRepliesRequest {
	r.inclusive = &inclusive
	return r
}

// The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached.
func (r ApiConversationsRepliesRequest) Limit(limit int32) ApiConversationsRepliesRequest {
	r.limit = &limit
	return r
}

// Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail.
func (r ApiConversationsRepliesRequest) Cursor(cursor string) ApiConversationsRepliesRequest {
	r.cursor = &cursor
	return r
}

func (r ApiConversationsRepliesRequest) Execute() (*ConversationsRepliesSuccessSchema, *http.Response, error) {
	return r.ApiService.ConversationsRepliesExecute(r)
}

/*
ConversationsReplies Method for ConversationsReplies

Retrieve a thread of messages posted to a conversation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConversationsRepliesRequest
*/
func (a *ConversationsApiService) ConversationsReplies(ctx context.Context) ApiConversationsRepliesRequest {
	return ApiConversationsRepliesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationsRepliesSuccessSchema
func (a *ConversationsApiService) ConversationsRepliesExecute(r ApiConversationsRepliesRequest) (*ConversationsRepliesSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationsRepliesSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsApiService.ConversationsReplies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations.replies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.token != nil {
		localVarQueryParams.Add("token", parameterToString(*r.token, ""))
	}
	if r.channel != nil {
		localVarQueryParams.Add("channel", parameterToString(*r.channel, ""))
	}
	if r.ts != nil {
		localVarQueryParams.Add("ts", parameterToString(*r.ts, ""))
	}
	if r.latest != nil {
		localVarQueryParams.Add("latest", parameterToString(*r.latest, ""))
	}
	if r.oldest != nil {
		localVarQueryParams.Add("oldest", parameterToString(*r.oldest, ""))
	}
	if r.inclusive != nil {
		localVarQueryParams.Add("inclusive", parameterToString(*r.inclusive, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.cursor != nil {
		localVarQueryParams.Add("cursor", parameterToString(*r.cursor, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ConversationsRepliesErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConversationsSetPurposeRequest struct {
	ctx context.Context
	ApiService *ConversationsApiService
	token *string
	channel *string
	purpose *string
}

// Authentication token. Requires scope: &#x60;conversations:write&#x60;
func (r ApiConversationsSetPurposeRequest) Token(token string) ApiConversationsSetPurposeRequest {
	r.token = &token
	return r
}

// Conversation to set the purpose of
func (r ApiConversationsSetPurposeRequest) Channel(channel string) ApiConversationsSetPurposeRequest {
	r.channel = &channel
	return r
}

// A new, specialer purpose
func (r ApiConversationsSetPurposeRequest) Purpose(purpose string) ApiConversationsSetPurposeRequest {
	r.purpose = &purpose
	return r
}

func (r ApiConversationsSetPurposeRequest) Execute() (*ConversationsSetPurposeSuccessSchema, *http.Response, error) {
	return r.ApiService.ConversationsSetPurposeExecute(r)
}

/*
ConversationsSetPurpose Method for ConversationsSetPurpose

Sets the purpose for a conversation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConversationsSetPurposeRequest
*/
func (a *ConversationsApiService) ConversationsSetPurpose(ctx context.Context) ApiConversationsSetPurposeRequest {
	return ApiConversationsSetPurposeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationsSetPurposeSuccessSchema
func (a *ConversationsApiService) ConversationsSetPurposeExecute(r ApiConversationsSetPurposeRequest) (*ConversationsSetPurposeSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationsSetPurposeSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsApiService.ConversationsSetPurpose")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations.setPurpose"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.token != nil {
		localVarHeaderParams["token"] = parameterToString(*r.token, "")
	}
	if r.channel != nil {
		localVarFormParams.Add("channel", parameterToString(*r.channel, ""))
	}
	if r.purpose != nil {
		localVarFormParams.Add("purpose", parameterToString(*r.purpose, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ConversationsSetPurposeErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConversationsSetTopicRequest struct {
	ctx context.Context
	ApiService *ConversationsApiService
	token *string
	channel *string
	topic *string
}

// Authentication token. Requires scope: &#x60;conversations:write&#x60;
func (r ApiConversationsSetTopicRequest) Token(token string) ApiConversationsSetTopicRequest {
	r.token = &token
	return r
}

// Conversation to set the topic of
func (r ApiConversationsSetTopicRequest) Channel(channel string) ApiConversationsSetTopicRequest {
	r.channel = &channel
	return r
}

// The new topic string. Does not support formatting or linkification.
func (r ApiConversationsSetTopicRequest) Topic(topic string) ApiConversationsSetTopicRequest {
	r.topic = &topic
	return r
}

func (r ApiConversationsSetTopicRequest) Execute() (*ConversationsSetTopicSuccessSchema, *http.Response, error) {
	return r.ApiService.ConversationsSetTopicExecute(r)
}

/*
ConversationsSetTopic Method for ConversationsSetTopic

Sets the topic for a conversation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConversationsSetTopicRequest
*/
func (a *ConversationsApiService) ConversationsSetTopic(ctx context.Context) ApiConversationsSetTopicRequest {
	return ApiConversationsSetTopicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationsSetTopicSuccessSchema
func (a *ConversationsApiService) ConversationsSetTopicExecute(r ApiConversationsSetTopicRequest) (*ConversationsSetTopicSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationsSetTopicSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsApiService.ConversationsSetTopic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations.setTopic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.token != nil {
		localVarHeaderParams["token"] = parameterToString(*r.token, "")
	}
	if r.channel != nil {
		localVarFormParams.Add("channel", parameterToString(*r.channel, ""))
	}
	if r.topic != nil {
		localVarFormParams.Add("topic", parameterToString(*r.topic, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ConversationsSetTopicErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConversationsUnarchiveRequest struct {
	ctx context.Context
	ApiService *ConversationsApiService
	token *string
	channel *string
}

// Authentication token. Requires scope: &#x60;conversations:write&#x60;
func (r ApiConversationsUnarchiveRequest) Token(token string) ApiConversationsUnarchiveRequest {
	r.token = &token
	return r
}

// ID of conversation to unarchive
func (r ApiConversationsUnarchiveRequest) Channel(channel string) ApiConversationsUnarchiveRequest {
	r.channel = &channel
	return r
}

func (r ApiConversationsUnarchiveRequest) Execute() (*ConversationsUnarchiveSuccessSchema, *http.Response, error) {
	return r.ApiService.ConversationsUnarchiveExecute(r)
}

/*
ConversationsUnarchive Method for ConversationsUnarchive

Reverses conversation archival.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConversationsUnarchiveRequest
*/
func (a *ConversationsApiService) ConversationsUnarchive(ctx context.Context) ApiConversationsUnarchiveRequest {
	return ApiConversationsUnarchiveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationsUnarchiveSuccessSchema
func (a *ConversationsApiService) ConversationsUnarchiveExecute(r ApiConversationsUnarchiveRequest) (*ConversationsUnarchiveSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationsUnarchiveSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsApiService.ConversationsUnarchive")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations.unarchive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.token != nil {
		localVarHeaderParams["token"] = parameterToString(*r.token, "")
	}
	if r.channel != nil {
		localVarFormParams.Add("channel", parameterToString(*r.channel, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ConversationsUnarchiveErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
