/*
Slack Web API

One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.

API version: 1.7.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package slack

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// ChatApiService ChatApi service
type ChatApiService service

type ApiChatDeleteRequest struct {
	ctx context.Context
	ApiService *ChatApiService
	token *string
	asUser *bool
	channel *string
	ts *float32
}

// Authentication token. Requires scope: &#x60;chat:write&#x60;
func (r ApiChatDeleteRequest) Token(token string) ApiChatDeleteRequest {
	r.token = &token
	return r
}

// Pass true to delete the message as the authed user with &#x60;chat:write:user&#x60; scope. [Bot users](/bot-users) in this context are considered authed users. If unused or false, the message will be deleted with &#x60;chat:write:bot&#x60; scope.
func (r ApiChatDeleteRequest) AsUser(asUser bool) ApiChatDeleteRequest {
	r.asUser = &asUser
	return r
}

// Channel containing the message to be deleted.
func (r ApiChatDeleteRequest) Channel(channel string) ApiChatDeleteRequest {
	r.channel = &channel
	return r
}

// Timestamp of the message to be deleted.
func (r ApiChatDeleteRequest) Ts(ts float32) ApiChatDeleteRequest {
	r.ts = &ts
	return r
}

func (r ApiChatDeleteRequest) Execute() (*ChatDeleteSuccessSchema, *http.Response, error) {
	return r.ApiService.ChatDeleteExecute(r)
}

/*
ChatDelete Method for ChatDelete

Deletes a message.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChatDeleteRequest
*/
func (a *ChatApiService) ChatDelete(ctx context.Context) ApiChatDeleteRequest {
	return ApiChatDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatDeleteSuccessSchema
func (a *ChatApiService) ChatDeleteExecute(r ApiChatDeleteRequest) (*ChatDeleteSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatDeleteSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatApiService.ChatDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chat.delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.token != nil {
		localVarHeaderParams["token"] = parameterToString(*r.token, "")
	}
	if r.asUser != nil {
		localVarFormParams.Add("as_user", parameterToString(*r.asUser, ""))
	}
	if r.channel != nil {
		localVarFormParams.Add("channel", parameterToString(*r.channel, ""))
	}
	if r.ts != nil {
		localVarFormParams.Add("ts", parameterToString(*r.ts, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ChatDeleteErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChatDeleteScheduledMessageRequest struct {
	ctx context.Context
	ApiService *ChatApiService
	token *string
	channel *string
	scheduledMessageId *string
	asUser *bool
}

// Authentication token. Requires scope: &#x60;chat:write&#x60;
func (r ApiChatDeleteScheduledMessageRequest) Token(token string) ApiChatDeleteScheduledMessageRequest {
	r.token = &token
	return r
}

// The channel the scheduled_message is posting to
func (r ApiChatDeleteScheduledMessageRequest) Channel(channel string) ApiChatDeleteScheduledMessageRequest {
	r.channel = &channel
	return r
}

// &#x60;scheduled_message_id&#x60; returned from call to chat.scheduleMessage
func (r ApiChatDeleteScheduledMessageRequest) ScheduledMessageId(scheduledMessageId string) ApiChatDeleteScheduledMessageRequest {
	r.scheduledMessageId = &scheduledMessageId
	return r
}

// Pass true to delete the message as the authed user with &#x60;chat:write:user&#x60; scope. [Bot users](/bot-users) in this context are considered authed users. If unused or false, the message will be deleted with &#x60;chat:write:bot&#x60; scope.
func (r ApiChatDeleteScheduledMessageRequest) AsUser(asUser bool) ApiChatDeleteScheduledMessageRequest {
	r.asUser = &asUser
	return r
}

func (r ApiChatDeleteScheduledMessageRequest) Execute() (*ChatDeleteScheduledMessageSchema, *http.Response, error) {
	return r.ApiService.ChatDeleteScheduledMessageExecute(r)
}

/*
ChatDeleteScheduledMessage Method for ChatDeleteScheduledMessage

Deletes a pending scheduled message from the queue.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChatDeleteScheduledMessageRequest
*/
func (a *ChatApiService) ChatDeleteScheduledMessage(ctx context.Context) ApiChatDeleteScheduledMessageRequest {
	return ApiChatDeleteScheduledMessageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatDeleteScheduledMessageSchema
func (a *ChatApiService) ChatDeleteScheduledMessageExecute(r ApiChatDeleteScheduledMessageRequest) (*ChatDeleteScheduledMessageSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatDeleteScheduledMessageSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatApiService.ChatDeleteScheduledMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chat.deleteScheduledMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.channel == nil {
		return localVarReturnValue, nil, reportError("channel is required and must be specified")
	}
	if r.scheduledMessageId == nil {
		return localVarReturnValue, nil, reportError("scheduledMessageId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	if r.asUser != nil {
		localVarFormParams.Add("as_user", parameterToString(*r.asUser, ""))
	}
	localVarFormParams.Add("channel", parameterToString(*r.channel, ""))
	localVarFormParams.Add("scheduled_message_id", parameterToString(*r.scheduledMessageId, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ChatDeleteScheduledMessageErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChatGetPermalinkRequest struct {
	ctx context.Context
	ApiService *ChatApiService
	token *string
	channel *string
	messageTs *string
}

// Authentication token. Requires scope: &#x60;none&#x60;
func (r ApiChatGetPermalinkRequest) Token(token string) ApiChatGetPermalinkRequest {
	r.token = &token
	return r
}

// The ID of the conversation or channel containing the message
func (r ApiChatGetPermalinkRequest) Channel(channel string) ApiChatGetPermalinkRequest {
	r.channel = &channel
	return r
}

// A message&#39;s &#x60;ts&#x60; value, uniquely identifying it within a channel
func (r ApiChatGetPermalinkRequest) MessageTs(messageTs string) ApiChatGetPermalinkRequest {
	r.messageTs = &messageTs
	return r
}

func (r ApiChatGetPermalinkRequest) Execute() (*ChatGetPermalinkSuccessSchema, *http.Response, error) {
	return r.ApiService.ChatGetPermalinkExecute(r)
}

/*
ChatGetPermalink Method for ChatGetPermalink

Retrieve a permalink URL for a specific extant message

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChatGetPermalinkRequest
*/
func (a *ChatApiService) ChatGetPermalink(ctx context.Context) ApiChatGetPermalinkRequest {
	return ApiChatGetPermalinkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatGetPermalinkSuccessSchema
func (a *ChatApiService) ChatGetPermalinkExecute(r ApiChatGetPermalinkRequest) (*ChatGetPermalinkSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatGetPermalinkSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatApiService.ChatGetPermalink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chat.getPermalink"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.channel == nil {
		return localVarReturnValue, nil, reportError("channel is required and must be specified")
	}
	if r.messageTs == nil {
		return localVarReturnValue, nil, reportError("messageTs is required and must be specified")
	}

	localVarQueryParams.Add("token", parameterToString(*r.token, ""))
	localVarQueryParams.Add("channel", parameterToString(*r.channel, ""))
	localVarQueryParams.Add("message_ts", parameterToString(*r.messageTs, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ChatGetPermalinkErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChatMeMessageRequest struct {
	ctx context.Context
	ApiService *ChatApiService
	token *string
	channel *string
	text *string
}

// Authentication token. Requires scope: &#x60;chat:write&#x60;
func (r ApiChatMeMessageRequest) Token(token string) ApiChatMeMessageRequest {
	r.token = &token
	return r
}

// Channel to send message to. Can be a public channel, private group or IM channel. Can be an encoded ID, or a name.
func (r ApiChatMeMessageRequest) Channel(channel string) ApiChatMeMessageRequest {
	r.channel = &channel
	return r
}

// Text of the message to send.
func (r ApiChatMeMessageRequest) Text(text string) ApiChatMeMessageRequest {
	r.text = &text
	return r
}

func (r ApiChatMeMessageRequest) Execute() (*ChatMeMessageSchema, *http.Response, error) {
	return r.ApiService.ChatMeMessageExecute(r)
}

/*
ChatMeMessage Method for ChatMeMessage

Share a me message into a channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChatMeMessageRequest
*/
func (a *ChatApiService) ChatMeMessage(ctx context.Context) ApiChatMeMessageRequest {
	return ApiChatMeMessageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatMeMessageSchema
func (a *ChatApiService) ChatMeMessageExecute(r ApiChatMeMessageRequest) (*ChatMeMessageSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatMeMessageSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatApiService.ChatMeMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chat.meMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.token != nil {
		localVarHeaderParams["token"] = parameterToString(*r.token, "")
	}
	if r.channel != nil {
		localVarFormParams.Add("channel", parameterToString(*r.channel, ""))
	}
	if r.text != nil {
		localVarFormParams.Add("text", parameterToString(*r.text, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ChatMeMessageErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChatPostEphemeralRequest struct {
	ctx context.Context
	ApiService *ChatApiService
	token *string
	channel *string
	user *string
	asUser *bool
	attachments *string
	blocks *string
	iconEmoji *string
	iconUrl *string
	linkNames *bool
	parse *string
	text *string
	threadTs *string
	username *string
}

// Authentication token. Requires scope: &#x60;chat:write&#x60;
func (r ApiChatPostEphemeralRequest) Token(token string) ApiChatPostEphemeralRequest {
	r.token = &token
	return r
}

// Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name.
func (r ApiChatPostEphemeralRequest) Channel(channel string) ApiChatPostEphemeralRequest {
	r.channel = &channel
	return r
}

// &#x60;id&#x60; of the user who will receive the ephemeral message. The user should be in the channel specified by the &#x60;channel&#x60; argument.
func (r ApiChatPostEphemeralRequest) User(user string) ApiChatPostEphemeralRequest {
	r.user = &user
	return r
}

// Pass true to post the message as the authed user. Defaults to true if the chat:write:bot scope is not included. Otherwise, defaults to false.
func (r ApiChatPostEphemeralRequest) AsUser(asUser bool) ApiChatPostEphemeralRequest {
	r.asUser = &asUser
	return r
}

// A JSON-based array of structured attachments, presented as a URL-encoded string.
func (r ApiChatPostEphemeralRequest) Attachments(attachments string) ApiChatPostEphemeralRequest {
	r.attachments = &attachments
	return r
}

// A JSON-based array of structured blocks, presented as a URL-encoded string.
func (r ApiChatPostEphemeralRequest) Blocks(blocks string) ApiChatPostEphemeralRequest {
	r.blocks = &blocks
	return r
}

// Emoji to use as the icon for this message. Overrides &#x60;icon_url&#x60;. Must be used in conjunction with &#x60;as_user&#x60; set to &#x60;false&#x60;, otherwise ignored. See [authorship](#authorship) below.
func (r ApiChatPostEphemeralRequest) IconEmoji(iconEmoji string) ApiChatPostEphemeralRequest {
	r.iconEmoji = &iconEmoji
	return r
}

// URL to an image to use as the icon for this message. Must be used in conjunction with &#x60;as_user&#x60; set to false, otherwise ignored. See [authorship](#authorship) below.
func (r ApiChatPostEphemeralRequest) IconUrl(iconUrl string) ApiChatPostEphemeralRequest {
	r.iconUrl = &iconUrl
	return r
}

// Find and link channel names and usernames.
func (r ApiChatPostEphemeralRequest) LinkNames(linkNames bool) ApiChatPostEphemeralRequest {
	r.linkNames = &linkNames
	return r
}

// Change how messages are treated. Defaults to &#x60;none&#x60;. See [below](#formatting).
func (r ApiChatPostEphemeralRequest) Parse(parse string) ApiChatPostEphemeralRequest {
	r.parse = &parse
	return r
}

// How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.
func (r ApiChatPostEphemeralRequest) Text(text string) ApiChatPostEphemeralRequest {
	r.text = &text
	return r
}

// Provide another message&#39;s &#x60;ts&#x60; value to post this message in a thread. Avoid using a reply&#39;s &#x60;ts&#x60; value; use its parent&#39;s value instead. Ephemeral messages in threads are only shown if there is already an active thread.
func (r ApiChatPostEphemeralRequest) ThreadTs(threadTs string) ApiChatPostEphemeralRequest {
	r.threadTs = &threadTs
	return r
}

// Set your bot&#39;s user name. Must be used in conjunction with &#x60;as_user&#x60; set to false, otherwise ignored. See [authorship](#authorship) below.
func (r ApiChatPostEphemeralRequest) Username(username string) ApiChatPostEphemeralRequest {
	r.username = &username
	return r
}

func (r ApiChatPostEphemeralRequest) Execute() (*ChatPostEphemeralSuccessSchema, *http.Response, error) {
	return r.ApiService.ChatPostEphemeralExecute(r)
}

/*
ChatPostEphemeral Method for ChatPostEphemeral

Sends an ephemeral message to a user in a channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChatPostEphemeralRequest
*/
func (a *ChatApiService) ChatPostEphemeral(ctx context.Context) ApiChatPostEphemeralRequest {
	return ApiChatPostEphemeralRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatPostEphemeralSuccessSchema
func (a *ChatApiService) ChatPostEphemeralExecute(r ApiChatPostEphemeralRequest) (*ChatPostEphemeralSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatPostEphemeralSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatApiService.ChatPostEphemeral")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chat.postEphemeral"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.channel == nil {
		return localVarReturnValue, nil, reportError("channel is required and must be specified")
	}
	if r.user == nil {
		return localVarReturnValue, nil, reportError("user is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	if r.asUser != nil {
		localVarFormParams.Add("as_user", parameterToString(*r.asUser, ""))
	}
	if r.attachments != nil {
		localVarFormParams.Add("attachments", parameterToString(*r.attachments, ""))
	}
	if r.blocks != nil {
		localVarFormParams.Add("blocks", parameterToString(*r.blocks, ""))
	}
	localVarFormParams.Add("channel", parameterToString(*r.channel, ""))
	if r.iconEmoji != nil {
		localVarFormParams.Add("icon_emoji", parameterToString(*r.iconEmoji, ""))
	}
	if r.iconUrl != nil {
		localVarFormParams.Add("icon_url", parameterToString(*r.iconUrl, ""))
	}
	if r.linkNames != nil {
		localVarFormParams.Add("link_names", parameterToString(*r.linkNames, ""))
	}
	if r.parse != nil {
		localVarFormParams.Add("parse", parameterToString(*r.parse, ""))
	}
	if r.text != nil {
		localVarFormParams.Add("text", parameterToString(*r.text, ""))
	}
	if r.threadTs != nil {
		localVarFormParams.Add("thread_ts", parameterToString(*r.threadTs, ""))
	}
	localVarFormParams.Add("user", parameterToString(*r.user, ""))
	if r.username != nil {
		localVarFormParams.Add("username", parameterToString(*r.username, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ChatPostEphemeralErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChatPostMessageRequest struct {
	ctx context.Context
	ApiService *ChatApiService
	token *string
	channel *string
	asUser *string
	attachments *string
	blocks *string
	iconEmoji *string
	iconUrl *string
	linkNames *bool
	mrkdwn *bool
	parse *string
	replyBroadcast *bool
	text *string
	threadTs *string
	unfurlLinks *bool
	unfurlMedia *bool
	username *string
}

// Authentication token. Requires scope: &#x60;chat:write&#x60;
func (r ApiChatPostMessageRequest) Token(token string) ApiChatPostMessageRequest {
	r.token = &token
	return r
}

// Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name. See [below](#channels) for more details.
func (r ApiChatPostMessageRequest) Channel(channel string) ApiChatPostMessageRequest {
	r.channel = &channel
	return r
}

// Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [authorship](#authorship) below.
func (r ApiChatPostMessageRequest) AsUser(asUser string) ApiChatPostMessageRequest {
	r.asUser = &asUser
	return r
}

// A JSON-based array of structured attachments, presented as a URL-encoded string.
func (r ApiChatPostMessageRequest) Attachments(attachments string) ApiChatPostMessageRequest {
	r.attachments = &attachments
	return r
}

// A JSON-based array of structured blocks, presented as a URL-encoded string.
func (r ApiChatPostMessageRequest) Blocks(blocks string) ApiChatPostMessageRequest {
	r.blocks = &blocks
	return r
}

// Emoji to use as the icon for this message. Overrides &#x60;icon_url&#x60;. Must be used in conjunction with &#x60;as_user&#x60; set to &#x60;false&#x60;, otherwise ignored. See [authorship](#authorship) below.
func (r ApiChatPostMessageRequest) IconEmoji(iconEmoji string) ApiChatPostMessageRequest {
	r.iconEmoji = &iconEmoji
	return r
}

// URL to an image to use as the icon for this message. Must be used in conjunction with &#x60;as_user&#x60; set to false, otherwise ignored. See [authorship](#authorship) below.
func (r ApiChatPostMessageRequest) IconUrl(iconUrl string) ApiChatPostMessageRequest {
	r.iconUrl = &iconUrl
	return r
}

// Find and link channel names and usernames.
func (r ApiChatPostMessageRequest) LinkNames(linkNames bool) ApiChatPostMessageRequest {
	r.linkNames = &linkNames
	return r
}

// Disable Slack markup parsing by setting to &#x60;false&#x60;. Enabled by default.
func (r ApiChatPostMessageRequest) Mrkdwn(mrkdwn bool) ApiChatPostMessageRequest {
	r.mrkdwn = &mrkdwn
	return r
}

// Change how messages are treated. Defaults to &#x60;none&#x60;. See [below](#formatting).
func (r ApiChatPostMessageRequest) Parse(parse string) ApiChatPostMessageRequest {
	r.parse = &parse
	return r
}

// Used in conjunction with &#x60;thread_ts&#x60; and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to &#x60;false&#x60;.
func (r ApiChatPostMessageRequest) ReplyBroadcast(replyBroadcast bool) ApiChatPostMessageRequest {
	r.replyBroadcast = &replyBroadcast
	return r
}

// How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.
func (r ApiChatPostMessageRequest) Text(text string) ApiChatPostMessageRequest {
	r.text = &text
	return r
}

// Provide another message&#39;s &#x60;ts&#x60; value to make this message a reply. Avoid using a reply&#39;s &#x60;ts&#x60; value; use its parent instead.
func (r ApiChatPostMessageRequest) ThreadTs(threadTs string) ApiChatPostMessageRequest {
	r.threadTs = &threadTs
	return r
}

// Pass true to enable unfurling of primarily text-based content.
func (r ApiChatPostMessageRequest) UnfurlLinks(unfurlLinks bool) ApiChatPostMessageRequest {
	r.unfurlLinks = &unfurlLinks
	return r
}

// Pass false to disable unfurling of media content.
func (r ApiChatPostMessageRequest) UnfurlMedia(unfurlMedia bool) ApiChatPostMessageRequest {
	r.unfurlMedia = &unfurlMedia
	return r
}

// Set your bot&#39;s user name. Must be used in conjunction with &#x60;as_user&#x60; set to false, otherwise ignored. See [authorship](#authorship) below.
func (r ApiChatPostMessageRequest) Username(username string) ApiChatPostMessageRequest {
	r.username = &username
	return r
}

func (r ApiChatPostMessageRequest) Execute() (*ChatPostMessageSuccessSchema, *http.Response, error) {
	return r.ApiService.ChatPostMessageExecute(r)
}

/*
ChatPostMessage Method for ChatPostMessage

Sends a message to a channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChatPostMessageRequest
*/
func (a *ChatApiService) ChatPostMessage(ctx context.Context) ApiChatPostMessageRequest {
	return ApiChatPostMessageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatPostMessageSuccessSchema
func (a *ChatApiService) ChatPostMessageExecute(r ApiChatPostMessageRequest) (*ChatPostMessageSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatPostMessageSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatApiService.ChatPostMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chat.postMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.channel == nil {
		return localVarReturnValue, nil, reportError("channel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	if r.asUser != nil {
		localVarFormParams.Add("as_user", parameterToString(*r.asUser, ""))
	}
	if r.attachments != nil {
		localVarFormParams.Add("attachments", parameterToString(*r.attachments, ""))
	}
	if r.blocks != nil {
		localVarFormParams.Add("blocks", parameterToString(*r.blocks, ""))
	}
	localVarFormParams.Add("channel", parameterToString(*r.channel, ""))
	if r.iconEmoji != nil {
		localVarFormParams.Add("icon_emoji", parameterToString(*r.iconEmoji, ""))
	}
	if r.iconUrl != nil {
		localVarFormParams.Add("icon_url", parameterToString(*r.iconUrl, ""))
	}
	if r.linkNames != nil {
		localVarFormParams.Add("link_names", parameterToString(*r.linkNames, ""))
	}
	if r.mrkdwn != nil {
		localVarFormParams.Add("mrkdwn", parameterToString(*r.mrkdwn, ""))
	}
	if r.parse != nil {
		localVarFormParams.Add("parse", parameterToString(*r.parse, ""))
	}
	if r.replyBroadcast != nil {
		localVarFormParams.Add("reply_broadcast", parameterToString(*r.replyBroadcast, ""))
	}
	if r.text != nil {
		localVarFormParams.Add("text", parameterToString(*r.text, ""))
	}
	if r.threadTs != nil {
		localVarFormParams.Add("thread_ts", parameterToString(*r.threadTs, ""))
	}
	if r.unfurlLinks != nil {
		localVarFormParams.Add("unfurl_links", parameterToString(*r.unfurlLinks, ""))
	}
	if r.unfurlMedia != nil {
		localVarFormParams.Add("unfurl_media", parameterToString(*r.unfurlMedia, ""))
	}
	if r.username != nil {
		localVarFormParams.Add("username", parameterToString(*r.username, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ChatPostMessageErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChatScheduleMessageRequest struct {
	ctx context.Context
	ApiService *ChatApiService
	token *string
	asUser *bool
	attachments *string
	blocks *string
	channel *string
	linkNames *bool
	parse *string
	postAt *string
	replyBroadcast *bool
	text *string
	threadTs *float32
	unfurlLinks *bool
	unfurlMedia *bool
}

// Authentication token. Requires scope: &#x60;chat:write&#x60;
func (r ApiChatScheduleMessageRequest) Token(token string) ApiChatScheduleMessageRequest {
	r.token = &token
	return r
}

// Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [chat.postMessage](chat.postMessage#authorship).
func (r ApiChatScheduleMessageRequest) AsUser(asUser bool) ApiChatScheduleMessageRequest {
	r.asUser = &asUser
	return r
}

// A JSON-based array of structured attachments, presented as a URL-encoded string.
func (r ApiChatScheduleMessageRequest) Attachments(attachments string) ApiChatScheduleMessageRequest {
	r.attachments = &attachments
	return r
}

// A JSON-based array of structured blocks, presented as a URL-encoded string.
func (r ApiChatScheduleMessageRequest) Blocks(blocks string) ApiChatScheduleMessageRequest {
	r.blocks = &blocks
	return r
}

// Channel, private group, or DM channel to send message to. Can be an encoded ID, or a name. See [below](#channels) for more details.
func (r ApiChatScheduleMessageRequest) Channel(channel string) ApiChatScheduleMessageRequest {
	r.channel = &channel
	return r
}

// Find and link channel names and usernames.
func (r ApiChatScheduleMessageRequest) LinkNames(linkNames bool) ApiChatScheduleMessageRequest {
	r.linkNames = &linkNames
	return r
}

// Change how messages are treated. Defaults to &#x60;none&#x60;. See [chat.postMessage](chat.postMessage#formatting).
func (r ApiChatScheduleMessageRequest) Parse(parse string) ApiChatScheduleMessageRequest {
	r.parse = &parse
	return r
}

// Unix EPOCH timestamp of time in future to send the message.
func (r ApiChatScheduleMessageRequest) PostAt(postAt string) ApiChatScheduleMessageRequest {
	r.postAt = &postAt
	return r
}

// Used in conjunction with &#x60;thread_ts&#x60; and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to &#x60;false&#x60;.
func (r ApiChatScheduleMessageRequest) ReplyBroadcast(replyBroadcast bool) ApiChatScheduleMessageRequest {
	r.replyBroadcast = &replyBroadcast
	return r
}

// How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.
func (r ApiChatScheduleMessageRequest) Text(text string) ApiChatScheduleMessageRequest {
	r.text = &text
	return r
}

// Provide another message&#39;s &#x60;ts&#x60; value to make this message a reply. Avoid using a reply&#39;s &#x60;ts&#x60; value; use its parent instead.
func (r ApiChatScheduleMessageRequest) ThreadTs(threadTs float32) ApiChatScheduleMessageRequest {
	r.threadTs = &threadTs
	return r
}

// Pass true to enable unfurling of primarily text-based content.
func (r ApiChatScheduleMessageRequest) UnfurlLinks(unfurlLinks bool) ApiChatScheduleMessageRequest {
	r.unfurlLinks = &unfurlLinks
	return r
}

// Pass false to disable unfurling of media content.
func (r ApiChatScheduleMessageRequest) UnfurlMedia(unfurlMedia bool) ApiChatScheduleMessageRequest {
	r.unfurlMedia = &unfurlMedia
	return r
}

func (r ApiChatScheduleMessageRequest) Execute() (*ChatScheduleMessageSuccessSchema, *http.Response, error) {
	return r.ApiService.ChatScheduleMessageExecute(r)
}

/*
ChatScheduleMessage Method for ChatScheduleMessage

Schedules a message to be sent to a channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChatScheduleMessageRequest
*/
func (a *ChatApiService) ChatScheduleMessage(ctx context.Context) ApiChatScheduleMessageRequest {
	return ApiChatScheduleMessageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatScheduleMessageSuccessSchema
func (a *ChatApiService) ChatScheduleMessageExecute(r ApiChatScheduleMessageRequest) (*ChatScheduleMessageSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatScheduleMessageSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatApiService.ChatScheduleMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chat.scheduleMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.token != nil {
		localVarHeaderParams["token"] = parameterToString(*r.token, "")
	}
	if r.asUser != nil {
		localVarFormParams.Add("as_user", parameterToString(*r.asUser, ""))
	}
	if r.attachments != nil {
		localVarFormParams.Add("attachments", parameterToString(*r.attachments, ""))
	}
	if r.blocks != nil {
		localVarFormParams.Add("blocks", parameterToString(*r.blocks, ""))
	}
	if r.channel != nil {
		localVarFormParams.Add("channel", parameterToString(*r.channel, ""))
	}
	if r.linkNames != nil {
		localVarFormParams.Add("link_names", parameterToString(*r.linkNames, ""))
	}
	if r.parse != nil {
		localVarFormParams.Add("parse", parameterToString(*r.parse, ""))
	}
	if r.postAt != nil {
		localVarFormParams.Add("post_at", parameterToString(*r.postAt, ""))
	}
	if r.replyBroadcast != nil {
		localVarFormParams.Add("reply_broadcast", parameterToString(*r.replyBroadcast, ""))
	}
	if r.text != nil {
		localVarFormParams.Add("text", parameterToString(*r.text, ""))
	}
	if r.threadTs != nil {
		localVarFormParams.Add("thread_ts", parameterToString(*r.threadTs, ""))
	}
	if r.unfurlLinks != nil {
		localVarFormParams.Add("unfurl_links", parameterToString(*r.unfurlLinks, ""))
	}
	if r.unfurlMedia != nil {
		localVarFormParams.Add("unfurl_media", parameterToString(*r.unfurlMedia, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ChatScheduleMessageErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChatScheduledMessagesListRequest struct {
	ctx context.Context
	ApiService *ChatApiService
	token *string
	channel *string
	latest *float32
	oldest *float32
	limit *int32
	cursor *string
}

// Authentication token. Requires scope: &#x60;none&#x60;
func (r ApiChatScheduledMessagesListRequest) Token(token string) ApiChatScheduledMessagesListRequest {
	r.token = &token
	return r
}

// The channel of the scheduled messages
func (r ApiChatScheduledMessagesListRequest) Channel(channel string) ApiChatScheduledMessagesListRequest {
	r.channel = &channel
	return r
}

// A UNIX timestamp of the latest value in the time range
func (r ApiChatScheduledMessagesListRequest) Latest(latest float32) ApiChatScheduledMessagesListRequest {
	r.latest = &latest
	return r
}

// A UNIX timestamp of the oldest value in the time range
func (r ApiChatScheduledMessagesListRequest) Oldest(oldest float32) ApiChatScheduledMessagesListRequest {
	r.oldest = &oldest
	return r
}

// Maximum number of original entries to return.
func (r ApiChatScheduledMessagesListRequest) Limit(limit int32) ApiChatScheduledMessagesListRequest {
	r.limit = &limit
	return r
}

// For pagination purposes, this is the &#x60;cursor&#x60; value returned from a previous call to &#x60;chat.scheduledmessages.list&#x60; indicating where you want to start this call from.
func (r ApiChatScheduledMessagesListRequest) Cursor(cursor string) ApiChatScheduledMessagesListRequest {
	r.cursor = &cursor
	return r
}

func (r ApiChatScheduledMessagesListRequest) Execute() (*ChatScheduledMessagesListSchema, *http.Response, error) {
	return r.ApiService.ChatScheduledMessagesListExecute(r)
}

/*
ChatScheduledMessagesList Method for ChatScheduledMessagesList

Returns a list of scheduled messages.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChatScheduledMessagesListRequest
*/
func (a *ChatApiService) ChatScheduledMessagesList(ctx context.Context) ApiChatScheduledMessagesListRequest {
	return ApiChatScheduledMessagesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatScheduledMessagesListSchema
func (a *ChatApiService) ChatScheduledMessagesListExecute(r ApiChatScheduledMessagesListRequest) (*ChatScheduledMessagesListSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatScheduledMessagesListSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatApiService.ChatScheduledMessagesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chat.scheduledMessages.list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.channel != nil {
		localVarQueryParams.Add("channel", parameterToString(*r.channel, ""))
	}
	if r.latest != nil {
		localVarQueryParams.Add("latest", parameterToString(*r.latest, ""))
	}
	if r.oldest != nil {
		localVarQueryParams.Add("oldest", parameterToString(*r.oldest, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.cursor != nil {
		localVarQueryParams.Add("cursor", parameterToString(*r.cursor, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.token != nil {
		localVarHeaderParams["token"] = parameterToString(*r.token, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ChatScheduledMessagesListErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChatUnfurlRequest struct {
	ctx context.Context
	ApiService *ChatApiService
	token *string
	channel *string
	ts *string
	unfurls *string
	userAuthMessage *string
	userAuthRequired *bool
	userAuthUrl *string
}

// Authentication token. Requires scope: &#x60;links:write&#x60;
func (r ApiChatUnfurlRequest) Token(token string) ApiChatUnfurlRequest {
	r.token = &token
	return r
}

// Channel ID of the message
func (r ApiChatUnfurlRequest) Channel(channel string) ApiChatUnfurlRequest {
	r.channel = &channel
	return r
}

// Timestamp of the message to add unfurl behavior to.
func (r ApiChatUnfurlRequest) Ts(ts string) ApiChatUnfurlRequest {
	r.ts = &ts
	return r
}

// URL-encoded JSON map with keys set to URLs featured in the the message, pointing to their unfurl blocks or message attachments.
func (r ApiChatUnfurlRequest) Unfurls(unfurls string) ApiChatUnfurlRequest {
	r.unfurls = &unfurls
	return r
}

// Provide a simply-formatted string to send as an ephemeral message to the user as invitation to authenticate further and enable full unfurling behavior
func (r ApiChatUnfurlRequest) UserAuthMessage(userAuthMessage string) ApiChatUnfurlRequest {
	r.userAuthMessage = &userAuthMessage
	return r
}

// Set to &#x60;true&#x60; or &#x60;1&#x60; to indicate the user must install your Slack app to trigger unfurls for this domain
func (r ApiChatUnfurlRequest) UserAuthRequired(userAuthRequired bool) ApiChatUnfurlRequest {
	r.userAuthRequired = &userAuthRequired
	return r
}

// Send users to this custom URL where they will complete authentication in your app to fully trigger unfurling. Value should be properly URL-encoded.
func (r ApiChatUnfurlRequest) UserAuthUrl(userAuthUrl string) ApiChatUnfurlRequest {
	r.userAuthUrl = &userAuthUrl
	return r
}

func (r ApiChatUnfurlRequest) Execute() (*ChatUnfurlSuccessSchema, *http.Response, error) {
	return r.ApiService.ChatUnfurlExecute(r)
}

/*
ChatUnfurl Method for ChatUnfurl

Provide custom unfurl behavior for user-posted URLs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChatUnfurlRequest
*/
func (a *ChatApiService) ChatUnfurl(ctx context.Context) ApiChatUnfurlRequest {
	return ApiChatUnfurlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatUnfurlSuccessSchema
func (a *ChatApiService) ChatUnfurlExecute(r ApiChatUnfurlRequest) (*ChatUnfurlSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatUnfurlSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatApiService.ChatUnfurl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chat.unfurl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.channel == nil {
		return localVarReturnValue, nil, reportError("channel is required and must be specified")
	}
	if r.ts == nil {
		return localVarReturnValue, nil, reportError("ts is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	localVarFormParams.Add("channel", parameterToString(*r.channel, ""))
	localVarFormParams.Add("ts", parameterToString(*r.ts, ""))
	if r.unfurls != nil {
		localVarFormParams.Add("unfurls", parameterToString(*r.unfurls, ""))
	}
	if r.userAuthMessage != nil {
		localVarFormParams.Add("user_auth_message", parameterToString(*r.userAuthMessage, ""))
	}
	if r.userAuthRequired != nil {
		localVarFormParams.Add("user_auth_required", parameterToString(*r.userAuthRequired, ""))
	}
	if r.userAuthUrl != nil {
		localVarFormParams.Add("user_auth_url", parameterToString(*r.userAuthUrl, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ChatUnfurlErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChatUpdateRequest struct {
	ctx context.Context
	ApiService *ChatApiService
	token *string
	channel *string
	ts *string
	asUser *string
	attachments *string
	blocks *string
	linkNames *string
	parse *string
	text *string
}

// Authentication token. Requires scope: &#x60;chat:write&#x60;
func (r ApiChatUpdateRequest) Token(token string) ApiChatUpdateRequest {
	r.token = &token
	return r
}

// Channel containing the message to be updated.
func (r ApiChatUpdateRequest) Channel(channel string) ApiChatUpdateRequest {
	r.channel = &channel
	return r
}

// Timestamp of the message to be updated.
func (r ApiChatUpdateRequest) Ts(ts string) ApiChatUpdateRequest {
	r.ts = &ts
	return r
}

// Pass true to update the message as the authed user. [Bot users](/bot-users) in this context are considered authed users.
func (r ApiChatUpdateRequest) AsUser(asUser string) ApiChatUpdateRequest {
	r.asUser = &asUser
	return r
}

// A JSON-based array of structured attachments, presented as a URL-encoded string. This field is required when not presenting &#x60;text&#x60;. If you don&#39;t include this field, the message&#39;s previous &#x60;attachments&#x60; will be retained. To remove previous &#x60;attachments&#x60;, include an empty array for this field.
func (r ApiChatUpdateRequest) Attachments(attachments string) ApiChatUpdateRequest {
	r.attachments = &attachments
	return r
}

// A JSON-based array of [structured blocks](/block-kit/building), presented as a URL-encoded string. If you don&#39;t include this field, the message&#39;s previous &#x60;blocks&#x60; will be retained. To remove previous &#x60;blocks&#x60;, include an empty array for this field.
func (r ApiChatUpdateRequest) Blocks(blocks string) ApiChatUpdateRequest {
	r.blocks = &blocks
	return r
}

// Find and link channel names and usernames. Defaults to &#x60;none&#x60;. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, &#x60;none&#x60;.
func (r ApiChatUpdateRequest) LinkNames(linkNames string) ApiChatUpdateRequest {
	r.linkNames = &linkNames
	return r
}

// Change how messages are treated. Defaults to &#x60;client&#x60;, unlike &#x60;chat.postMessage&#x60;. Accepts either &#x60;none&#x60; or &#x60;full&#x60;. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, &#x60;client&#x60;.
func (r ApiChatUpdateRequest) Parse(parse string) ApiChatUpdateRequest {
	r.parse = &parse
	return r
}

// New text for the message, using the [default formatting rules](/reference/surfaces/formatting). It&#39;s not required when presenting &#x60;blocks&#x60; or &#x60;attachments&#x60;.
func (r ApiChatUpdateRequest) Text(text string) ApiChatUpdateRequest {
	r.text = &text
	return r
}

func (r ApiChatUpdateRequest) Execute() (*ChatUpdateSuccessSchema, *http.Response, error) {
	return r.ApiService.ChatUpdateExecute(r)
}

/*
ChatUpdate Method for ChatUpdate

Updates a message.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChatUpdateRequest
*/
func (a *ChatApiService) ChatUpdate(ctx context.Context) ApiChatUpdateRequest {
	return ApiChatUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatUpdateSuccessSchema
func (a *ChatApiService) ChatUpdateExecute(r ApiChatUpdateRequest) (*ChatUpdateSuccessSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatUpdateSuccessSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatApiService.ChatUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chat.update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.channel == nil {
		return localVarReturnValue, nil, reportError("channel is required and must be specified")
	}
	if r.ts == nil {
		return localVarReturnValue, nil, reportError("ts is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	if r.asUser != nil {
		localVarFormParams.Add("as_user", parameterToString(*r.asUser, ""))
	}
	if r.attachments != nil {
		localVarFormParams.Add("attachments", parameterToString(*r.attachments, ""))
	}
	if r.blocks != nil {
		localVarFormParams.Add("blocks", parameterToString(*r.blocks, ""))
	}
	localVarFormParams.Add("channel", parameterToString(*r.channel, ""))
	if r.linkNames != nil {
		localVarFormParams.Add("link_names", parameterToString(*r.linkNames, ""))
	}
	if r.parse != nil {
		localVarFormParams.Add("parse", parameterToString(*r.parse, ""))
	}
	if r.text != nil {
		localVarFormParams.Add("text", parameterToString(*r.text, ""))
	}
	localVarFormParams.Add("ts", parameterToString(*r.ts, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ChatUpdateErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
