/*
Slack Web API

One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.

API version: 1.7.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package slack

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// AdminConversationsApiService AdminConversationsApi service
type AdminConversationsApiService service

type ApiAdminConversationsArchiveRequest struct {
	ctx context.Context
	ApiService *AdminConversationsApiService
	token *string
	channelId *string
}

// Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
func (r ApiAdminConversationsArchiveRequest) Token(token string) ApiAdminConversationsArchiveRequest {
	r.token = &token
	return r
}

// The channel to archive.
func (r ApiAdminConversationsArchiveRequest) ChannelId(channelId string) ApiAdminConversationsArchiveRequest {
	r.channelId = &channelId
	return r
}

func (r ApiAdminConversationsArchiveRequest) Execute() (*AdminConversationsArchiveSchema, *http.Response, error) {
	return r.ApiService.AdminConversationsArchiveExecute(r)
}

/*
AdminConversationsArchive Method for AdminConversationsArchive

Archive a public or private channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminConversationsArchiveRequest
*/
func (a *AdminConversationsApiService) AdminConversationsArchive(ctx context.Context) ApiAdminConversationsArchiveRequest {
	return ApiAdminConversationsArchiveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AdminConversationsArchiveSchema
func (a *AdminConversationsApiService) AdminConversationsArchiveExecute(r ApiAdminConversationsArchiveRequest) (*AdminConversationsArchiveSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdminConversationsArchiveSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminConversationsApiService.AdminConversationsArchive")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin.conversations.archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.channelId == nil {
		return localVarReturnValue, nil, reportError("channelId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	localVarFormParams.Add("channel_id", parameterToString(*r.channelId, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v AdminConversationsArchiveErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminConversationsConvertToPrivateRequest struct {
	ctx context.Context
	ApiService *AdminConversationsApiService
	token *string
	channelId *string
}

// Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
func (r ApiAdminConversationsConvertToPrivateRequest) Token(token string) ApiAdminConversationsConvertToPrivateRequest {
	r.token = &token
	return r
}

// The channel to convert to private.
func (r ApiAdminConversationsConvertToPrivateRequest) ChannelId(channelId string) ApiAdminConversationsConvertToPrivateRequest {
	r.channelId = &channelId
	return r
}

func (r ApiAdminConversationsConvertToPrivateRequest) Execute() (*AdminConversationsConvertToPrivateSchema, *http.Response, error) {
	return r.ApiService.AdminConversationsConvertToPrivateExecute(r)
}

/*
AdminConversationsConvertToPrivate Method for AdminConversationsConvertToPrivate

Convert a public channel to a private channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminConversationsConvertToPrivateRequest
*/
func (a *AdminConversationsApiService) AdminConversationsConvertToPrivate(ctx context.Context) ApiAdminConversationsConvertToPrivateRequest {
	return ApiAdminConversationsConvertToPrivateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AdminConversationsConvertToPrivateSchema
func (a *AdminConversationsApiService) AdminConversationsConvertToPrivateExecute(r ApiAdminConversationsConvertToPrivateRequest) (*AdminConversationsConvertToPrivateSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdminConversationsConvertToPrivateSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminConversationsApiService.AdminConversationsConvertToPrivate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin.conversations.convertToPrivate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.channelId == nil {
		return localVarReturnValue, nil, reportError("channelId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	localVarFormParams.Add("channel_id", parameterToString(*r.channelId, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v AdminConversationsConvertToPrivateErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminConversationsCreateRequest struct {
	ctx context.Context
	ApiService *AdminConversationsApiService
	token *string
	isPrivate *bool
	name *string
	description *string
	orgWide *bool
	teamId *string
}

// Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
func (r ApiAdminConversationsCreateRequest) Token(token string) ApiAdminConversationsCreateRequest {
	r.token = &token
	return r
}

// When &#x60;true&#x60;, creates a private channel instead of a public channel
func (r ApiAdminConversationsCreateRequest) IsPrivate(isPrivate bool) ApiAdminConversationsCreateRequest {
	r.isPrivate = &isPrivate
	return r
}

// Name of the public or private channel to create.
func (r ApiAdminConversationsCreateRequest) Name(name string) ApiAdminConversationsCreateRequest {
	r.name = &name
	return r
}

// Description of the public or private channel to create.
func (r ApiAdminConversationsCreateRequest) Description(description string) ApiAdminConversationsCreateRequest {
	r.description = &description
	return r
}

// When &#x60;true&#x60;, the channel will be available org-wide. Note: if the channel is not &#x60;org_wide&#x3D;true&#x60;, you must specify a &#x60;team_id&#x60; for this channel
func (r ApiAdminConversationsCreateRequest) OrgWide(orgWide bool) ApiAdminConversationsCreateRequest {
	r.orgWide = &orgWide
	return r
}

// The workspace to create the channel in. Note: this argument is required unless you set &#x60;org_wide&#x3D;true&#x60;.
func (r ApiAdminConversationsCreateRequest) TeamId(teamId string) ApiAdminConversationsCreateRequest {
	r.teamId = &teamId
	return r
}

func (r ApiAdminConversationsCreateRequest) Execute() (*AdminConversationsCreateSchema, *http.Response, error) {
	return r.ApiService.AdminConversationsCreateExecute(r)
}

/*
AdminConversationsCreate Method for AdminConversationsCreate

Create a public or private channel-based conversation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminConversationsCreateRequest
*/
func (a *AdminConversationsApiService) AdminConversationsCreate(ctx context.Context) ApiAdminConversationsCreateRequest {
	return ApiAdminConversationsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AdminConversationsCreateSchema
func (a *AdminConversationsApiService) AdminConversationsCreateExecute(r ApiAdminConversationsCreateRequest) (*AdminConversationsCreateSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdminConversationsCreateSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminConversationsApiService.AdminConversationsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin.conversations.create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.isPrivate == nil {
		return localVarReturnValue, nil, reportError("isPrivate is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	if r.description != nil {
		localVarFormParams.Add("description", parameterToString(*r.description, ""))
	}
	localVarFormParams.Add("is_private", parameterToString(*r.isPrivate, ""))
	localVarFormParams.Add("name", parameterToString(*r.name, ""))
	if r.orgWide != nil {
		localVarFormParams.Add("org_wide", parameterToString(*r.orgWide, ""))
	}
	if r.teamId != nil {
		localVarFormParams.Add("team_id", parameterToString(*r.teamId, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v AdminConversationsCreateErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminConversationsDeleteRequest struct {
	ctx context.Context
	ApiService *AdminConversationsApiService
	token *string
	channelId *string
}

// Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
func (r ApiAdminConversationsDeleteRequest) Token(token string) ApiAdminConversationsDeleteRequest {
	r.token = &token
	return r
}

// The channel to delete.
func (r ApiAdminConversationsDeleteRequest) ChannelId(channelId string) ApiAdminConversationsDeleteRequest {
	r.channelId = &channelId
	return r
}

func (r ApiAdminConversationsDeleteRequest) Execute() (*AdminConversationsDeleteSchema, *http.Response, error) {
	return r.ApiService.AdminConversationsDeleteExecute(r)
}

/*
AdminConversationsDelete Method for AdminConversationsDelete

Delete a public or private channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminConversationsDeleteRequest
*/
func (a *AdminConversationsApiService) AdminConversationsDelete(ctx context.Context) ApiAdminConversationsDeleteRequest {
	return ApiAdminConversationsDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AdminConversationsDeleteSchema
func (a *AdminConversationsApiService) AdminConversationsDeleteExecute(r ApiAdminConversationsDeleteRequest) (*AdminConversationsDeleteSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdminConversationsDeleteSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminConversationsApiService.AdminConversationsDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin.conversations.delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.channelId == nil {
		return localVarReturnValue, nil, reportError("channelId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	localVarFormParams.Add("channel_id", parameterToString(*r.channelId, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v AdminConversationsDeleteErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminConversationsDisconnectSharedRequest struct {
	ctx context.Context
	ApiService *AdminConversationsApiService
	token *string
	channelId *string
	leavingTeamIds *string
}

// Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
func (r ApiAdminConversationsDisconnectSharedRequest) Token(token string) ApiAdminConversationsDisconnectSharedRequest {
	r.token = &token
	return r
}

// The channel to be disconnected from some workspaces.
func (r ApiAdminConversationsDisconnectSharedRequest) ChannelId(channelId string) ApiAdminConversationsDisconnectSharedRequest {
	r.channelId = &channelId
	return r
}

// The team to be removed from the channel. Currently only a single team id can be specified.
func (r ApiAdminConversationsDisconnectSharedRequest) LeavingTeamIds(leavingTeamIds string) ApiAdminConversationsDisconnectSharedRequest {
	r.leavingTeamIds = &leavingTeamIds
	return r
}

func (r ApiAdminConversationsDisconnectSharedRequest) Execute() (*AdminConversationsRenameSchema, *http.Response, error) {
	return r.ApiService.AdminConversationsDisconnectSharedExecute(r)
}

/*
AdminConversationsDisconnectShared Method for AdminConversationsDisconnectShared

Disconnect a connected channel from one or more workspaces.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminConversationsDisconnectSharedRequest
*/
func (a *AdminConversationsApiService) AdminConversationsDisconnectShared(ctx context.Context) ApiAdminConversationsDisconnectSharedRequest {
	return ApiAdminConversationsDisconnectSharedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AdminConversationsRenameSchema
func (a *AdminConversationsApiService) AdminConversationsDisconnectSharedExecute(r ApiAdminConversationsDisconnectSharedRequest) (*AdminConversationsRenameSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdminConversationsRenameSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminConversationsApiService.AdminConversationsDisconnectShared")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin.conversations.disconnectShared"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.channelId == nil {
		return localVarReturnValue, nil, reportError("channelId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	localVarFormParams.Add("channel_id", parameterToString(*r.channelId, ""))
	if r.leavingTeamIds != nil {
		localVarFormParams.Add("leaving_team_ids", parameterToString(*r.leavingTeamIds, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v AdminConversationsDisconnectSharedErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminConversationsGetConversationPrefsRequest struct {
	ctx context.Context
	ApiService *AdminConversationsApiService
	token *string
	channelId *string
}

// Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
func (r ApiAdminConversationsGetConversationPrefsRequest) Token(token string) ApiAdminConversationsGetConversationPrefsRequest {
	r.token = &token
	return r
}

// The channel to get preferences for.
func (r ApiAdminConversationsGetConversationPrefsRequest) ChannelId(channelId string) ApiAdminConversationsGetConversationPrefsRequest {
	r.channelId = &channelId
	return r
}

func (r ApiAdminConversationsGetConversationPrefsRequest) Execute() (*AdminConversationsGetConversationPrefsSchema, *http.Response, error) {
	return r.ApiService.AdminConversationsGetConversationPrefsExecute(r)
}

/*
AdminConversationsGetConversationPrefs Method for AdminConversationsGetConversationPrefs

Get conversation preferences for a public or private channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminConversationsGetConversationPrefsRequest
*/
func (a *AdminConversationsApiService) AdminConversationsGetConversationPrefs(ctx context.Context) ApiAdminConversationsGetConversationPrefsRequest {
	return ApiAdminConversationsGetConversationPrefsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AdminConversationsGetConversationPrefsSchema
func (a *AdminConversationsApiService) AdminConversationsGetConversationPrefsExecute(r ApiAdminConversationsGetConversationPrefsRequest) (*AdminConversationsGetConversationPrefsSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdminConversationsGetConversationPrefsSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminConversationsApiService.AdminConversationsGetConversationPrefs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin.conversations.getConversationPrefs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.channelId == nil {
		return localVarReturnValue, nil, reportError("channelId is required and must be specified")
	}

	localVarQueryParams.Add("channel_id", parameterToString(*r.channelId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v AdminConversationsUnarchiveErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminConversationsGetTeamsRequest struct {
	ctx context.Context
	ApiService *AdminConversationsApiService
	token *string
	channelId *string
	cursor *string
	limit *int32
}

// Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
func (r ApiAdminConversationsGetTeamsRequest) Token(token string) ApiAdminConversationsGetTeamsRequest {
	r.token = &token
	return r
}

// The channel to determine connected workspaces within the organization for.
func (r ApiAdminConversationsGetTeamsRequest) ChannelId(channelId string) ApiAdminConversationsGetTeamsRequest {
	r.channelId = &channelId
	return r
}

// Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page
func (r ApiAdminConversationsGetTeamsRequest) Cursor(cursor string) ApiAdminConversationsGetTeamsRequest {
	r.cursor = &cursor
	return r
}

// The maximum number of items to return. Must be between 1 - 1000 both inclusive.
func (r ApiAdminConversationsGetTeamsRequest) Limit(limit int32) ApiAdminConversationsGetTeamsRequest {
	r.limit = &limit
	return r
}

func (r ApiAdminConversationsGetTeamsRequest) Execute() (*AdminConversationsGetTeamsSchema, *http.Response, error) {
	return r.ApiService.AdminConversationsGetTeamsExecute(r)
}

/*
AdminConversationsGetTeams Method for AdminConversationsGetTeams

Get all the workspaces a given public or private channel is connected to within this Enterprise org.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminConversationsGetTeamsRequest
*/
func (a *AdminConversationsApiService) AdminConversationsGetTeams(ctx context.Context) ApiAdminConversationsGetTeamsRequest {
	return ApiAdminConversationsGetTeamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AdminConversationsGetTeamsSchema
func (a *AdminConversationsApiService) AdminConversationsGetTeamsExecute(r ApiAdminConversationsGetTeamsRequest) (*AdminConversationsGetTeamsSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdminConversationsGetTeamsSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminConversationsApiService.AdminConversationsGetTeams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin.conversations.getTeams"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.channelId == nil {
		return localVarReturnValue, nil, reportError("channelId is required and must be specified")
	}

	localVarQueryParams.Add("channel_id", parameterToString(*r.channelId, ""))
	if r.cursor != nil {
		localVarQueryParams.Add("cursor", parameterToString(*r.cursor, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v AdminConversationsGetTeamsErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminConversationsInviteRequest struct {
	ctx context.Context
	ApiService *AdminConversationsApiService
	token *string
	channelId *string
	userIds *string
}

// Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
func (r ApiAdminConversationsInviteRequest) Token(token string) ApiAdminConversationsInviteRequest {
	r.token = &token
	return r
}

// The channel that the users will be invited to.
func (r ApiAdminConversationsInviteRequest) ChannelId(channelId string) ApiAdminConversationsInviteRequest {
	r.channelId = &channelId
	return r
}

// The users to invite.
func (r ApiAdminConversationsInviteRequest) UserIds(userIds string) ApiAdminConversationsInviteRequest {
	r.userIds = &userIds
	return r
}

func (r ApiAdminConversationsInviteRequest) Execute() (*AdminConversationsInviteSchema, *http.Response, error) {
	return r.ApiService.AdminConversationsInviteExecute(r)
}

/*
AdminConversationsInvite Method for AdminConversationsInvite

Invite a user to a public or private channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminConversationsInviteRequest
*/
func (a *AdminConversationsApiService) AdminConversationsInvite(ctx context.Context) ApiAdminConversationsInviteRequest {
	return ApiAdminConversationsInviteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AdminConversationsInviteSchema
func (a *AdminConversationsApiService) AdminConversationsInviteExecute(r ApiAdminConversationsInviteRequest) (*AdminConversationsInviteSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdminConversationsInviteSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminConversationsApiService.AdminConversationsInvite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin.conversations.invite"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.channelId == nil {
		return localVarReturnValue, nil, reportError("channelId is required and must be specified")
	}
	if r.userIds == nil {
		return localVarReturnValue, nil, reportError("userIds is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	localVarFormParams.Add("channel_id", parameterToString(*r.channelId, ""))
	localVarFormParams.Add("user_ids", parameterToString(*r.userIds, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v AdminConversationsInviteErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminConversationsRenameRequest struct {
	ctx context.Context
	ApiService *AdminConversationsApiService
	token *string
	channelId *string
	name *string
}

// Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
func (r ApiAdminConversationsRenameRequest) Token(token string) ApiAdminConversationsRenameRequest {
	r.token = &token
	return r
}

// The channel to rename.
func (r ApiAdminConversationsRenameRequest) ChannelId(channelId string) ApiAdminConversationsRenameRequest {
	r.channelId = &channelId
	return r
}

func (r ApiAdminConversationsRenameRequest) Name(name string) ApiAdminConversationsRenameRequest {
	r.name = &name
	return r
}

func (r ApiAdminConversationsRenameRequest) Execute() (*AdminConversationsRenameSchema1, *http.Response, error) {
	return r.ApiService.AdminConversationsRenameExecute(r)
}

/*
AdminConversationsRename Method for AdminConversationsRename

Rename a public or private channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminConversationsRenameRequest
*/
func (a *AdminConversationsApiService) AdminConversationsRename(ctx context.Context) ApiAdminConversationsRenameRequest {
	return ApiAdminConversationsRenameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AdminConversationsRenameSchema1
func (a *AdminConversationsApiService) AdminConversationsRenameExecute(r ApiAdminConversationsRenameRequest) (*AdminConversationsRenameSchema1, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdminConversationsRenameSchema1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminConversationsApiService.AdminConversationsRename")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin.conversations.rename"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.channelId == nil {
		return localVarReturnValue, nil, reportError("channelId is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	localVarFormParams.Add("channel_id", parameterToString(*r.channelId, ""))
	localVarFormParams.Add("name", parameterToString(*r.name, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v AdminConversationsUnarchiveErrorSchema1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminConversationsSearchRequest struct {
	ctx context.Context
	ApiService *AdminConversationsApiService
	token *string
	teamIds *string
	query *string
	limit *int32
	cursor *string
	searchChannelTypes *string
	sort *string
	sortDir *string
}

// Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
func (r ApiAdminConversationsSearchRequest) Token(token string) ApiAdminConversationsSearchRequest {
	r.token = &token
	return r
}

// Comma separated string of team IDs, signifying the workspaces to search through.
func (r ApiAdminConversationsSearchRequest) TeamIds(teamIds string) ApiAdminConversationsSearchRequest {
	r.teamIds = &teamIds
	return r
}

// Name of the the channel to query by.
func (r ApiAdminConversationsSearchRequest) Query(query string) ApiAdminConversationsSearchRequest {
	r.query = &query
	return r
}

// Maximum number of items to be returned. Must be between 1 - 20 both inclusive. Default is 10.
func (r ApiAdminConversationsSearchRequest) Limit(limit int32) ApiAdminConversationsSearchRequest {
	r.limit = &limit
	return r
}

// Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page.
func (r ApiAdminConversationsSearchRequest) Cursor(cursor string) ApiAdminConversationsSearchRequest {
	r.cursor = &cursor
	return r
}

// The type of channel to include or exclude in the search. For example &#x60;private&#x60; will search private channels, while &#x60;private_exclude&#x60; will exclude them. For a full list of types, check the [Types section](#types).
func (r ApiAdminConversationsSearchRequest) SearchChannelTypes(searchChannelTypes string) ApiAdminConversationsSearchRequest {
	r.searchChannelTypes = &searchChannelTypes
	return r
}

// Possible values are &#x60;relevant&#x60; (search ranking based on what we think is closest), &#x60;name&#x60; (alphabetical), &#x60;member_count&#x60; (number of users in the channel), and &#x60;created&#x60; (date channel was created). You can optionally pair this with the &#x60;sort_dir&#x60; arg to change how it is sorted 
func (r ApiAdminConversationsSearchRequest) Sort(sort string) ApiAdminConversationsSearchRequest {
	r.sort = &sort
	return r
}

// Sort direction. Possible values are &#x60;asc&#x60; for ascending order like (1, 2, 3) or (a, b, c), and &#x60;desc&#x60; for descending order like (3, 2, 1) or (c, b, a)
func (r ApiAdminConversationsSearchRequest) SortDir(sortDir string) ApiAdminConversationsSearchRequest {
	r.sortDir = &sortDir
	return r
}

func (r ApiAdminConversationsSearchRequest) Execute() (*AdminConversationsSearchSchema, *http.Response, error) {
	return r.ApiService.AdminConversationsSearchExecute(r)
}

/*
AdminConversationsSearch Method for AdminConversationsSearch

Search for public or private channels in an Enterprise organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminConversationsSearchRequest
*/
func (a *AdminConversationsApiService) AdminConversationsSearch(ctx context.Context) ApiAdminConversationsSearchRequest {
	return ApiAdminConversationsSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AdminConversationsSearchSchema
func (a *AdminConversationsApiService) AdminConversationsSearchExecute(r ApiAdminConversationsSearchRequest) (*AdminConversationsSearchSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdminConversationsSearchSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminConversationsApiService.AdminConversationsSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin.conversations.search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}

	if r.teamIds != nil {
		localVarQueryParams.Add("team_ids", parameterToString(*r.teamIds, ""))
	}
	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.cursor != nil {
		localVarQueryParams.Add("cursor", parameterToString(*r.cursor, ""))
	}
	if r.searchChannelTypes != nil {
		localVarQueryParams.Add("search_channel_types", parameterToString(*r.searchChannelTypes, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.sortDir != nil {
		localVarQueryParams.Add("sort_dir", parameterToString(*r.sortDir, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v AdminConversationsSearchErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminConversationsSetConversationPrefsRequest struct {
	ctx context.Context
	ApiService *AdminConversationsApiService
	token *string
	channelId *string
	prefs *string
}

// Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
func (r ApiAdminConversationsSetConversationPrefsRequest) Token(token string) ApiAdminConversationsSetConversationPrefsRequest {
	r.token = &token
	return r
}

// The channel to set the prefs for
func (r ApiAdminConversationsSetConversationPrefsRequest) ChannelId(channelId string) ApiAdminConversationsSetConversationPrefsRequest {
	r.channelId = &channelId
	return r
}

// The prefs for this channel in a stringified JSON format.
func (r ApiAdminConversationsSetConversationPrefsRequest) Prefs(prefs string) ApiAdminConversationsSetConversationPrefsRequest {
	r.prefs = &prefs
	return r
}

func (r ApiAdminConversationsSetConversationPrefsRequest) Execute() (*AdminConversationsSetConversationPrefsSchema, *http.Response, error) {
	return r.ApiService.AdminConversationsSetConversationPrefsExecute(r)
}

/*
AdminConversationsSetConversationPrefs Method for AdminConversationsSetConversationPrefs

Set the posting permissions for a public or private channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminConversationsSetConversationPrefsRequest
*/
func (a *AdminConversationsApiService) AdminConversationsSetConversationPrefs(ctx context.Context) ApiAdminConversationsSetConversationPrefsRequest {
	return ApiAdminConversationsSetConversationPrefsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AdminConversationsSetConversationPrefsSchema
func (a *AdminConversationsApiService) AdminConversationsSetConversationPrefsExecute(r ApiAdminConversationsSetConversationPrefsRequest) (*AdminConversationsSetConversationPrefsSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdminConversationsSetConversationPrefsSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminConversationsApiService.AdminConversationsSetConversationPrefs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin.conversations.setConversationPrefs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.channelId == nil {
		return localVarReturnValue, nil, reportError("channelId is required and must be specified")
	}
	if r.prefs == nil {
		return localVarReturnValue, nil, reportError("prefs is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	localVarFormParams.Add("channel_id", parameterToString(*r.channelId, ""))
	localVarFormParams.Add("prefs", parameterToString(*r.prefs, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v AdminConversationsSetConversationPrefsErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminConversationsSetTeamsRequest struct {
	ctx context.Context
	ApiService *AdminConversationsApiService
	token *string
	channelId *string
	orgChannel *bool
	targetTeamIds *string
	teamId *string
}

// Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
func (r ApiAdminConversationsSetTeamsRequest) Token(token string) ApiAdminConversationsSetTeamsRequest {
	r.token = &token
	return r
}

// The encoded &#x60;channel_id&#x60; to add or remove to workspaces.
func (r ApiAdminConversationsSetTeamsRequest) ChannelId(channelId string) ApiAdminConversationsSetTeamsRequest {
	r.channelId = &channelId
	return r
}

// True if channel has to be converted to an org channel
func (r ApiAdminConversationsSetTeamsRequest) OrgChannel(orgChannel bool) ApiAdminConversationsSetTeamsRequest {
	r.orgChannel = &orgChannel
	return r
}

// A comma-separated list of workspaces to which the channel should be shared. Not required if the channel is being shared org-wide.
func (r ApiAdminConversationsSetTeamsRequest) TargetTeamIds(targetTeamIds string) ApiAdminConversationsSetTeamsRequest {
	r.targetTeamIds = &targetTeamIds
	return r
}

// The workspace to which the channel belongs. Omit this argument if the channel is a cross-workspace shared channel.
func (r ApiAdminConversationsSetTeamsRequest) TeamId(teamId string) ApiAdminConversationsSetTeamsRequest {
	r.teamId = &teamId
	return r
}

func (r ApiAdminConversationsSetTeamsRequest) Execute() (*DefaultSuccessTemplate, *http.Response, error) {
	return r.ApiService.AdminConversationsSetTeamsExecute(r)
}

/*
AdminConversationsSetTeams Method for AdminConversationsSetTeams

Set the workspaces in an Enterprise grid org that connect to a public or private channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminConversationsSetTeamsRequest
*/
func (a *AdminConversationsApiService) AdminConversationsSetTeams(ctx context.Context) ApiAdminConversationsSetTeamsRequest {
	return ApiAdminConversationsSetTeamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DefaultSuccessTemplate
func (a *AdminConversationsApiService) AdminConversationsSetTeamsExecute(r ApiAdminConversationsSetTeamsRequest) (*DefaultSuccessTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefaultSuccessTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminConversationsApiService.AdminConversationsSetTeams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin.conversations.setTeams"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.channelId == nil {
		return localVarReturnValue, nil, reportError("channelId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	localVarFormParams.Add("channel_id", parameterToString(*r.channelId, ""))
	if r.orgChannel != nil {
		localVarFormParams.Add("org_channel", parameterToString(*r.orgChannel, ""))
	}
	if r.targetTeamIds != nil {
		localVarFormParams.Add("target_team_ids", parameterToString(*r.targetTeamIds, ""))
	}
	if r.teamId != nil {
		localVarFormParams.Add("team_id", parameterToString(*r.teamId, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v DefaultErrorTemplate
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminConversationsUnarchiveRequest struct {
	ctx context.Context
	ApiService *AdminConversationsApiService
	token *string
	channelId *string
}

// Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
func (r ApiAdminConversationsUnarchiveRequest) Token(token string) ApiAdminConversationsUnarchiveRequest {
	r.token = &token
	return r
}

// The channel to unarchive.
func (r ApiAdminConversationsUnarchiveRequest) ChannelId(channelId string) ApiAdminConversationsUnarchiveRequest {
	r.channelId = &channelId
	return r
}

func (r ApiAdminConversationsUnarchiveRequest) Execute() (*AdminConversationsUnarchiveSchema, *http.Response, error) {
	return r.ApiService.AdminConversationsUnarchiveExecute(r)
}

/*
AdminConversationsUnarchive Method for AdminConversationsUnarchive

Unarchive a public or private channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminConversationsUnarchiveRequest
*/
func (a *AdminConversationsApiService) AdminConversationsUnarchive(ctx context.Context) ApiAdminConversationsUnarchiveRequest {
	return ApiAdminConversationsUnarchiveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AdminConversationsUnarchiveSchema
func (a *AdminConversationsApiService) AdminConversationsUnarchiveExecute(r ApiAdminConversationsUnarchiveRequest) (*AdminConversationsUnarchiveSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdminConversationsUnarchiveSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdminConversationsApiService.AdminConversationsUnarchive")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin.conversations.unarchive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.channelId == nil {
		return localVarReturnValue, nil, reportError("channelId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["token"] = parameterToString(*r.token, "")
	localVarFormParams.Add("channel_id", parameterToString(*r.channelId, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v AdminConversationsUnarchiveErrorSchema2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
