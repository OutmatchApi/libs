/*
 * Slack Web API
 *
 * One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.
 *
 * The version of the OpenAPI document: 1.7.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`conversations_archive`]
#[derive(Clone, Debug, Default)]
pub struct ConversationsArchiveParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// ID of conversation to archive
    pub channel: Option<String>
}

/// struct for passing parameters to the method [`conversations_close`]
#[derive(Clone, Debug, Default)]
pub struct ConversationsCloseParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// Conversation to close.
    pub channel: Option<String>
}

/// struct for passing parameters to the method [`conversations_create`]
#[derive(Clone, Debug, Default)]
pub struct ConversationsCreateParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// Create a private channel instead of a public one
    pub is_private: Option<bool>,
    /// Name of the public or private channel to create
    pub name: Option<String>
}

/// struct for passing parameters to the method [`conversations_history`]
#[derive(Clone, Debug, Default)]
pub struct ConversationsHistoryParams {
    /// Authentication token. Requires scope: `conversations:history`
    pub token: Option<String>,
    /// Conversation ID to fetch history for.
    pub channel: Option<String>,
    /// End of time range of messages to include in results.
    pub latest: Option<f32>,
    /// Start of time range of messages to include in results.
    pub oldest: Option<f32>,
    /// Include messages with latest or oldest timestamp in results only when either timestamp is specified.
    pub inclusive: Option<bool>,
    /// The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached.
    pub limit: Option<i32>,
    /// Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail.
    pub cursor: Option<String>
}

/// struct for passing parameters to the method [`conversations_info`]
#[derive(Clone, Debug, Default)]
pub struct ConversationsInfoParams {
    /// Authentication token. Requires scope: `conversations:read`
    pub token: Option<String>,
    /// Conversation ID to learn more about
    pub channel: Option<String>,
    /// Set this to `true` to receive the locale for this conversation. Defaults to `false`
    pub include_locale: Option<bool>,
    /// Set to `true` to include the member count for the specified conversation. Defaults to `false`
    pub include_num_members: Option<bool>
}

/// struct for passing parameters to the method [`conversations_invite`]
#[derive(Clone, Debug, Default)]
pub struct ConversationsInviteParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// The ID of the public or private channel to invite user(s) to.
    pub channel: Option<String>,
    /// A comma separated list of user IDs. Up to 1000 users may be listed.
    pub users: Option<String>
}

/// struct for passing parameters to the method [`conversations_join`]
#[derive(Clone, Debug, Default)]
pub struct ConversationsJoinParams {
    /// Authentication token. Requires scope: `channels:write`
    pub token: Option<String>,
    /// ID of conversation to join
    pub channel: Option<String>
}

/// struct for passing parameters to the method [`conversations_kick`]
#[derive(Clone, Debug, Default)]
pub struct ConversationsKickParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// ID of conversation to remove user from.
    pub channel: Option<String>,
    /// User ID to be removed.
    pub user: Option<String>
}

/// struct for passing parameters to the method [`conversations_leave`]
#[derive(Clone, Debug, Default)]
pub struct ConversationsLeaveParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// Conversation to leave
    pub channel: Option<String>
}

/// struct for passing parameters to the method [`conversations_list`]
#[derive(Clone, Debug, Default)]
pub struct ConversationsListParams {
    /// Authentication token. Requires scope: `conversations:read`
    pub token: Option<String>,
    /// Set to `true` to exclude archived channels from the list
    pub exclude_archived: Option<bool>,
    /// Mix and match channel types by providing a comma-separated list of any combination of `public_channel`, `private_channel`, `mpim`, `im`
    pub types: Option<String>,
    /// The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached. Must be an integer no larger than 1000.
    pub limit: Option<i32>,
    /// Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail.
    pub cursor: Option<String>
}

/// struct for passing parameters to the method [`conversations_mark`]
#[derive(Clone, Debug, Default)]
pub struct ConversationsMarkParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// Channel or conversation to set the read cursor for.
    pub channel: Option<String>,
    /// Unique identifier of message you want marked as most recently seen in this conversation.
    pub ts: Option<f32>
}

/// struct for passing parameters to the method [`conversations_members`]
#[derive(Clone, Debug, Default)]
pub struct ConversationsMembersParams {
    /// Authentication token. Requires scope: `conversations:read`
    pub token: Option<String>,
    /// ID of the conversation to retrieve members for
    pub channel: Option<String>,
    /// The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached.
    pub limit: Option<i32>,
    /// Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail.
    pub cursor: Option<String>
}

/// struct for passing parameters to the method [`conversations_open`]
#[derive(Clone, Debug, Default)]
pub struct ConversationsOpenParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// Resume a conversation by supplying an `im` or `mpim`'s ID. Or provide the `users` field instead.
    pub channel: Option<String>,
    /// Boolean, indicates you want the full IM channel definition in the response.
    pub return_im: Option<bool>,
    /// Comma separated lists of users. If only one user is included, this creates a 1:1 DM.  The ordering of the users is preserved whenever a multi-person direct message is returned. Supply a `channel` when not supplying `users`.
    pub users: Option<String>
}

/// struct for passing parameters to the method [`conversations_rename`]
#[derive(Clone, Debug, Default)]
pub struct ConversationsRenameParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// ID of conversation to rename
    pub channel: Option<String>,
    /// New name for conversation.
    pub name: Option<String>
}

/// struct for passing parameters to the method [`conversations_replies`]
#[derive(Clone, Debug, Default)]
pub struct ConversationsRepliesParams {
    /// Authentication token. Requires scope: `conversations:history`
    pub token: Option<String>,
    /// Conversation ID to fetch thread from.
    pub channel: Option<String>,
    /// Unique identifier of a thread's parent message. `ts` must be the timestamp of an existing message with 0 or more replies. If there are no replies then just the single message referenced by `ts` will return - it is just an ordinary, unthreaded message.
    pub ts: Option<f32>,
    /// End of time range of messages to include in results.
    pub latest: Option<f32>,
    /// Start of time range of messages to include in results.
    pub oldest: Option<f32>,
    /// Include messages with latest or oldest timestamp in results only when either timestamp is specified.
    pub inclusive: Option<bool>,
    /// The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached.
    pub limit: Option<i32>,
    /// Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail.
    pub cursor: Option<String>
}

/// struct for passing parameters to the method [`conversations_set_purpose`]
#[derive(Clone, Debug, Default)]
pub struct ConversationsSetPurposeParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// Conversation to set the purpose of
    pub channel: Option<String>,
    /// A new, specialer purpose
    pub purpose: Option<String>
}

/// struct for passing parameters to the method [`conversations_set_topic`]
#[derive(Clone, Debug, Default)]
pub struct ConversationsSetTopicParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// Conversation to set the topic of
    pub channel: Option<String>,
    /// The new topic string. Does not support formatting or linkification.
    pub topic: Option<String>
}

/// struct for passing parameters to the method [`conversations_unarchive`]
#[derive(Clone, Debug, Default)]
pub struct ConversationsUnarchiveParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// ID of conversation to unarchive
    pub channel: Option<String>
}


/// struct for typed errors of method [`conversations_archive`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConversationsArchiveError {
    DefaultResponse(crate::models::ConversationsArchiveErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`conversations_close`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConversationsCloseError {
    DefaultResponse(crate::models::ConversationsCloseErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`conversations_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConversationsCreateError {
    DefaultResponse(crate::models::ConversationsCreateErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`conversations_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConversationsHistoryError {
    DefaultResponse(crate::models::ConversationsHistoryErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`conversations_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConversationsInfoError {
    DefaultResponse(crate::models::ConversationsInfoErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`conversations_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConversationsInviteError {
    DefaultResponse(crate::models::ConversationsInviteErrorSchema1),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`conversations_join`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConversationsJoinError {
    DefaultResponse(crate::models::ConversationsJoinErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`conversations_kick`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConversationsKickError {
    DefaultResponse(crate::models::ConversationsKickErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`conversations_leave`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConversationsLeaveError {
    DefaultResponse(crate::models::ConversationsLeaveErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`conversations_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConversationsListError {
    DefaultResponse(crate::models::ConversationsListErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`conversations_mark`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConversationsMarkError {
    DefaultResponse(crate::models::ConversationsMarkErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`conversations_members`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConversationsMembersError {
    DefaultResponse(crate::models::ConversationsMembersErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`conversations_open`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConversationsOpenError {
    DefaultResponse(crate::models::ConversationsOpenErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`conversations_rename`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConversationsRenameError {
    DefaultResponse(crate::models::ConversationsRenameErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`conversations_replies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConversationsRepliesError {
    DefaultResponse(crate::models::ConversationsRepliesErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`conversations_set_purpose`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConversationsSetPurposeError {
    DefaultResponse(crate::models::ConversationsSetPurposeErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`conversations_set_topic`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConversationsSetTopicError {
    DefaultResponse(crate::models::ConversationsSetTopicErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`conversations_unarchive`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConversationsUnarchiveError {
    DefaultResponse(crate::models::ConversationsUnarchiveErrorSchema),
    UnknownValue(serde_json::Value),
}


/// Archives a conversation.
pub async fn conversations_archive(configuration: &configuration::Configuration, params: ConversationsArchiveParams) -> Result<crate::models::ConversationsArchiveSuccessSchema, Error<ConversationsArchiveError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let channel = params.channel;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/conversations.archive", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = token {
        local_var_req_builder = local_var_req_builder.header("token", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = channel {
        local_var_form_params.insert("channel", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConversationsArchiveError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Closes a direct message or multi-person direct message.
pub async fn conversations_close(configuration: &configuration::Configuration, params: ConversationsCloseParams) -> Result<crate::models::ConversationsCloseSuccessSchema, Error<ConversationsCloseError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let channel = params.channel;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/conversations.close", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = token {
        local_var_req_builder = local_var_req_builder.header("token", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = channel {
        local_var_form_params.insert("channel", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConversationsCloseError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Initiates a public or private channel-based conversation
pub async fn conversations_create(configuration: &configuration::Configuration, params: ConversationsCreateParams) -> Result<crate::models::ConversationsCreateSuccessSchema, Error<ConversationsCreateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let is_private = params.is_private;
    let name = params.name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/conversations.create", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = token {
        local_var_req_builder = local_var_req_builder.header("token", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = is_private {
        local_var_form_params.insert("is_private", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = name {
        local_var_form_params.insert("name", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConversationsCreateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetches a conversation's history of messages and events.
pub async fn conversations_history(configuration: &configuration::Configuration, params: ConversationsHistoryParams) -> Result<crate::models::ConversationsHistorySuccessSchema, Error<ConversationsHistoryError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let channel = params.channel;
    let latest = params.latest;
    let oldest = params.oldest;
    let inclusive = params.inclusive;
    let limit = params.limit;
    let cursor = params.cursor;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/conversations.history", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = token {
        local_var_req_builder = local_var_req_builder.query(&[("token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = channel {
        local_var_req_builder = local_var_req_builder.query(&[("channel", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = latest {
        local_var_req_builder = local_var_req_builder.query(&[("latest", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = oldest {
        local_var_req_builder = local_var_req_builder.query(&[("oldest", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = inclusive {
        local_var_req_builder = local_var_req_builder.query(&[("inclusive", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = cursor {
        local_var_req_builder = local_var_req_builder.query(&[("cursor", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConversationsHistoryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve information about a conversation.
pub async fn conversations_info(configuration: &configuration::Configuration, params: ConversationsInfoParams) -> Result<crate::models::ConversationsInfoSuccessSchema, Error<ConversationsInfoError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let channel = params.channel;
    let include_locale = params.include_locale;
    let include_num_members = params.include_num_members;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/conversations.info", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = token {
        local_var_req_builder = local_var_req_builder.query(&[("token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = channel {
        local_var_req_builder = local_var_req_builder.query(&[("channel", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_locale {
        local_var_req_builder = local_var_req_builder.query(&[("include_locale", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_num_members {
        local_var_req_builder = local_var_req_builder.query(&[("include_num_members", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConversationsInfoError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Invites users to a channel.
pub async fn conversations_invite(configuration: &configuration::Configuration, params: ConversationsInviteParams) -> Result<crate::models::ConversationsInviteErrorSchema, Error<ConversationsInviteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let channel = params.channel;
    let users = params.users;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/conversations.invite", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = token {
        local_var_req_builder = local_var_req_builder.header("token", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = channel {
        local_var_form_params.insert("channel", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = users {
        local_var_form_params.insert("users", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConversationsInviteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Joins an existing conversation.
pub async fn conversations_join(configuration: &configuration::Configuration, params: ConversationsJoinParams) -> Result<crate::models::ConversationsJoinSuccessSchema, Error<ConversationsJoinError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let channel = params.channel;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/conversations.join", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = token {
        local_var_req_builder = local_var_req_builder.header("token", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = channel {
        local_var_form_params.insert("channel", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConversationsJoinError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Removes a user from a conversation.
pub async fn conversations_kick(configuration: &configuration::Configuration, params: ConversationsKickParams) -> Result<crate::models::ConversationsKickSuccessSchema, Error<ConversationsKickError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let channel = params.channel;
    let user = params.user;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/conversations.kick", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = token {
        local_var_req_builder = local_var_req_builder.header("token", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = channel {
        local_var_form_params.insert("channel", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = user {
        local_var_form_params.insert("user", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConversationsKickError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Leaves a conversation.
pub async fn conversations_leave(configuration: &configuration::Configuration, params: ConversationsLeaveParams) -> Result<crate::models::ConversationsLeaveSuccessSchema, Error<ConversationsLeaveError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let channel = params.channel;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/conversations.leave", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = token {
        local_var_req_builder = local_var_req_builder.header("token", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = channel {
        local_var_form_params.insert("channel", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConversationsLeaveError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists all channels in a Slack team.
pub async fn conversations_list(configuration: &configuration::Configuration, params: ConversationsListParams) -> Result<crate::models::ConversationsListSuccessSchema, Error<ConversationsListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let exclude_archived = params.exclude_archived;
    let types = params.types;
    let limit = params.limit;
    let cursor = params.cursor;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/conversations.list", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = token {
        local_var_req_builder = local_var_req_builder.query(&[("token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_archived {
        local_var_req_builder = local_var_req_builder.query(&[("exclude_archived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = types {
        local_var_req_builder = local_var_req_builder.query(&[("types", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = cursor {
        local_var_req_builder = local_var_req_builder.query(&[("cursor", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConversationsListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Sets the read cursor in a channel.
pub async fn conversations_mark(configuration: &configuration::Configuration, params: ConversationsMarkParams) -> Result<crate::models::ConversationsMarkSuccessSchema, Error<ConversationsMarkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let channel = params.channel;
    let ts = params.ts;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/conversations.mark", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = token {
        local_var_req_builder = local_var_req_builder.header("token", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = channel {
        local_var_form_params.insert("channel", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = ts {
        local_var_form_params.insert("ts", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConversationsMarkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve members of a conversation.
pub async fn conversations_members(configuration: &configuration::Configuration, params: ConversationsMembersParams) -> Result<crate::models::ConversationsMembersSuccessSchema, Error<ConversationsMembersError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let channel = params.channel;
    let limit = params.limit;
    let cursor = params.cursor;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/conversations.members", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = token {
        local_var_req_builder = local_var_req_builder.query(&[("token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = channel {
        local_var_req_builder = local_var_req_builder.query(&[("channel", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = cursor {
        local_var_req_builder = local_var_req_builder.query(&[("cursor", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConversationsMembersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Opens or resumes a direct message or multi-person direct message.
pub async fn conversations_open(configuration: &configuration::Configuration, params: ConversationsOpenParams) -> Result<crate::models::ConversationsOpenSuccessSchema, Error<ConversationsOpenError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let channel = params.channel;
    let return_im = params.return_im;
    let users = params.users;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/conversations.open", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = token {
        local_var_req_builder = local_var_req_builder.header("token", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = channel {
        local_var_form_params.insert("channel", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = return_im {
        local_var_form_params.insert("return_im", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = users {
        local_var_form_params.insert("users", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConversationsOpenError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Renames a conversation.
pub async fn conversations_rename(configuration: &configuration::Configuration, params: ConversationsRenameParams) -> Result<crate::models::ConversationsRenameSuccessSchema, Error<ConversationsRenameError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let channel = params.channel;
    let name = params.name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/conversations.rename", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = token {
        local_var_req_builder = local_var_req_builder.header("token", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = channel {
        local_var_form_params.insert("channel", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = name {
        local_var_form_params.insert("name", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConversationsRenameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a thread of messages posted to a conversation
pub async fn conversations_replies(configuration: &configuration::Configuration, params: ConversationsRepliesParams) -> Result<crate::models::ConversationsRepliesSuccessSchema, Error<ConversationsRepliesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let channel = params.channel;
    let ts = params.ts;
    let latest = params.latest;
    let oldest = params.oldest;
    let inclusive = params.inclusive;
    let limit = params.limit;
    let cursor = params.cursor;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/conversations.replies", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = token {
        local_var_req_builder = local_var_req_builder.query(&[("token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = channel {
        local_var_req_builder = local_var_req_builder.query(&[("channel", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ts {
        local_var_req_builder = local_var_req_builder.query(&[("ts", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = latest {
        local_var_req_builder = local_var_req_builder.query(&[("latest", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = oldest {
        local_var_req_builder = local_var_req_builder.query(&[("oldest", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = inclusive {
        local_var_req_builder = local_var_req_builder.query(&[("inclusive", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = cursor {
        local_var_req_builder = local_var_req_builder.query(&[("cursor", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConversationsRepliesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Sets the purpose for a conversation.
pub async fn conversations_set_purpose(configuration: &configuration::Configuration, params: ConversationsSetPurposeParams) -> Result<crate::models::ConversationsSetPurposeSuccessSchema, Error<ConversationsSetPurposeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let channel = params.channel;
    let purpose = params.purpose;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/conversations.setPurpose", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = token {
        local_var_req_builder = local_var_req_builder.header("token", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = channel {
        local_var_form_params.insert("channel", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = purpose {
        local_var_form_params.insert("purpose", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConversationsSetPurposeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Sets the topic for a conversation.
pub async fn conversations_set_topic(configuration: &configuration::Configuration, params: ConversationsSetTopicParams) -> Result<crate::models::ConversationsSetTopicSuccessSchema, Error<ConversationsSetTopicError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let channel = params.channel;
    let topic = params.topic;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/conversations.setTopic", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = token {
        local_var_req_builder = local_var_req_builder.header("token", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = channel {
        local_var_form_params.insert("channel", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = topic {
        local_var_form_params.insert("topic", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConversationsSetTopicError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Reverses conversation archival.
pub async fn conversations_unarchive(configuration: &configuration::Configuration, params: ConversationsUnarchiveParams) -> Result<crate::models::ConversationsUnarchiveSuccessSchema, Error<ConversationsUnarchiveError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let channel = params.channel;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/conversations.unarchive", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = token {
        local_var_req_builder = local_var_req_builder.header("token", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = channel {
        local_var_form_params.insert("channel", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConversationsUnarchiveError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

