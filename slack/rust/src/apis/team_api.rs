/*
 * Slack Web API
 *
 * One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.
 *
 * The version of the OpenAPI document: 1.7.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`team_access_logs`]
#[derive(Clone, Debug, Default)]
pub struct TeamAccessLogsParams {
    /// Authentication token. Requires scope: `admin`
    pub token: String,
    /// End of time range of logs to include in results (inclusive).
    pub before: Option<String>,
    pub count: Option<String>,
    pub page: Option<String>
}

/// struct for passing parameters to the method [`team_billable_info`]
#[derive(Clone, Debug, Default)]
pub struct TeamBillableInfoParams {
    /// Authentication token. Requires scope: `admin`
    pub token: String,
    /// A user to retrieve the billable information for. Defaults to all users.
    pub user: Option<String>
}

/// struct for passing parameters to the method [`team_info`]
#[derive(Clone, Debug, Default)]
pub struct TeamInfoParams {
    /// Authentication token. Requires scope: `team:read`
    pub token: String,
    /// Team to get info on, if omitted, will return information about the current team. Will only return team that the authenticated token is allowed to see through external shared channels
    pub team: Option<String>
}

/// struct for passing parameters to the method [`team_integration_logs`]
#[derive(Clone, Debug, Default)]
pub struct TeamIntegrationLogsParams {
    /// Authentication token. Requires scope: `admin`
    pub token: String,
    /// Filter logs to this Slack app. Defaults to all logs.
    pub app_id: Option<String>,
    /// Filter logs with this change type. Defaults to all logs.
    pub change_type: Option<String>,
    pub count: Option<String>,
    pub page: Option<String>,
    /// Filter logs to this service. Defaults to all logs.
    pub service_id: Option<String>,
    /// Filter logs generated by this userâ€™s actions. Defaults to all logs.
    pub user: Option<String>
}

/// struct for passing parameters to the method [`team_profile_get`]
#[derive(Clone, Debug, Default)]
pub struct TeamProfileGetParams {
    /// Authentication token. Requires scope: `users.profile:read`
    pub token: String,
    /// Filter by visibility.
    pub visibility: Option<String>
}


/// struct for typed errors of method [`team_access_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamAccessLogsError {
    DefaultResponse(crate::models::TeamAccessLogsErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_billable_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamBillableInfoError {
    DefaultResponse(crate::models::DefaultErrorTemplate),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamInfoError {
    DefaultResponse(crate::models::TeamInfoErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_integration_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamIntegrationLogsError {
    DefaultResponse(crate::models::TeamIntegrationLogsErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_profile_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamProfileGetError {
    DefaultResponse(crate::models::TeamProfileGetErrorSchema),
    UnknownValue(serde_json::Value),
}


/// Gets the access logs for the current team.
pub async fn team_access_logs(configuration: &configuration::Configuration, params: TeamAccessLogsParams) -> Result<crate::models::TeamAccessLogsSchema, Error<TeamAccessLogsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let before = params.before;
    let count = params.count;
    let page = params.page;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team.accessLogs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("token", &token.to_string())]);
    if let Some(ref local_var_str) = before {
        local_var_req_builder = local_var_req_builder.query(&[("before", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = count {
        local_var_req_builder = local_var_req_builder.query(&[("count", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamAccessLogsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets billable users information for the current team.
pub async fn team_billable_info(configuration: &configuration::Configuration, params: TeamBillableInfoParams) -> Result<crate::models::DefaultSuccessTemplate, Error<TeamBillableInfoError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let user = params.user;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team.billableInfo", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("token", &token.to_string())]);
    if let Some(ref local_var_str) = user {
        local_var_req_builder = local_var_req_builder.query(&[("user", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamBillableInfoError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets information about the current team.
pub async fn team_info(configuration: &configuration::Configuration, params: TeamInfoParams) -> Result<crate::models::TeamInfoSchema, Error<TeamInfoError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let team = params.team;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team.info", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("token", &token.to_string())]);
    if let Some(ref local_var_str) = team {
        local_var_req_builder = local_var_req_builder.query(&[("team", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamInfoError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets the integration logs for the current team.
pub async fn team_integration_logs(configuration: &configuration::Configuration, params: TeamIntegrationLogsParams) -> Result<crate::models::TeamIntegrationLogsSchema, Error<TeamIntegrationLogsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let app_id = params.app_id;
    let change_type = params.change_type;
    let count = params.count;
    let page = params.page;
    let service_id = params.service_id;
    let user = params.user;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team.integrationLogs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("token", &token.to_string())]);
    if let Some(ref local_var_str) = app_id {
        local_var_req_builder = local_var_req_builder.query(&[("app_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = change_type {
        local_var_req_builder = local_var_req_builder.query(&[("change_type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = count {
        local_var_req_builder = local_var_req_builder.query(&[("count", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = service_id {
        local_var_req_builder = local_var_req_builder.query(&[("service_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user {
        local_var_req_builder = local_var_req_builder.query(&[("user", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamIntegrationLogsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a team's profile.
pub async fn team_profile_get(configuration: &configuration::Configuration, params: TeamProfileGetParams) -> Result<crate::models::TeamProfileGetSuccessSchema, Error<TeamProfileGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let visibility = params.visibility;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team.profile.get", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("token", &token.to_string())]);
    if let Some(ref local_var_str) = visibility {
        local_var_req_builder = local_var_req_builder.query(&[("visibility", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamProfileGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

