/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package slack.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.outmatchapi.slack.DefaultErrorTemplate
import com.outmatchapi.slack.DefaultSuccessTemplate
import com.outmatchapi.slack.FilesCommentsDeleteErrorSchema
import com.outmatchapi.slack.FilesCommentsDeleteSchema
import com.outmatchapi.slack.FilesDeleteErrorSchema
import com.outmatchapi.slack.FilesDeleteSchema
import com.outmatchapi.slack.FilesInfoErrorSchema
import com.outmatchapi.slack.FilesInfoSchema
import com.outmatchapi.slack.FilesListErrorSchema
import com.outmatchapi.slack.FilesListSchema
import com.outmatchapi.slack.FilesRevokePublicURLErrorSchema
import com.outmatchapi.slack.FilesRevokePublicURLSchema
import com.outmatchapi.slack.FilesSharedPublicURLErrorSchema
import com.outmatchapi.slack.FilesSharedPublicURLSchema
import com.outmatchapi.slack.FilesUploadErrorSchema
import com.outmatchapi.slack.FilesUploadSchema

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import slack.infrastructure.ApiClient
import slack.infrastructure.ApiResponse
import slack.infrastructure.ClientException
import slack.infrastructure.ClientError
import slack.infrastructure.ServerException
import slack.infrastructure.ServerError
import slack.infrastructure.MultiValueMap
import slack.infrastructure.PartConfig
import slack.infrastructure.RequestConfig
import slack.infrastructure.RequestMethod
import slack.infrastructure.ResponseType
import slack.infrastructure.Success
import slack.infrastructure.toMultiValue

class FilesApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://slack.com/api")
        }
    }

    /**
     * 
     * Deletes an existing comment on a file.
     * @param token Authentication token. Requires scope: &#x60;files:write:user&#x60; (optional)
     * @param file File to delete a comment from. (optional)
     * @param id The comment to delete. (optional)
     * @return FilesCommentsDeleteSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filesCommentsDelete(token: kotlin.String? = null, file: kotlin.String? = null, id: kotlin.String? = null) : FilesCommentsDeleteSchema = withContext(Dispatchers.IO) {
        val localVarResponse = filesCommentsDeleteWithHttpInfo(token = token, file = file, id = id)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FilesCommentsDeleteSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Deletes an existing comment on a file.
     * @param token Authentication token. Requires scope: &#x60;files:write:user&#x60; (optional)
     * @param file File to delete a comment from. (optional)
     * @param id The comment to delete. (optional)
     * @return ApiResponse<FilesCommentsDeleteSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun filesCommentsDeleteWithHttpInfo(token: kotlin.String?, file: kotlin.String?, id: kotlin.String?) : ApiResponse<FilesCommentsDeleteSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = filesCommentsDeleteRequestConfig(token = token, file = file, id = id)

        return@withContext request<Map<String, PartConfig<*>>, FilesCommentsDeleteSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation filesCommentsDelete
     *
     * @param token Authentication token. Requires scope: &#x60;files:write:user&#x60; (optional)
     * @param file File to delete a comment from. (optional)
     * @param id The comment to delete. (optional)
     * @return RequestConfig
     */
    fun filesCommentsDeleteRequestConfig(token: kotlin.String?, file: kotlin.String?, id: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "file" to PartConfig(body = file, headers = mutableMapOf()),
            "id" to PartConfig(body = id, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token?.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/files.comments.delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Deletes a file.
     * @param token Authentication token. Requires scope: &#x60;files:write:user&#x60; (optional)
     * @param file ID of file to delete. (optional)
     * @return FilesDeleteSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filesDelete(token: kotlin.String? = null, file: kotlin.String? = null) : FilesDeleteSchema = withContext(Dispatchers.IO) {
        val localVarResponse = filesDeleteWithHttpInfo(token = token, file = file)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FilesDeleteSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Deletes a file.
     * @param token Authentication token. Requires scope: &#x60;files:write:user&#x60; (optional)
     * @param file ID of file to delete. (optional)
     * @return ApiResponse<FilesDeleteSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun filesDeleteWithHttpInfo(token: kotlin.String?, file: kotlin.String?) : ApiResponse<FilesDeleteSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = filesDeleteRequestConfig(token = token, file = file)

        return@withContext request<Map<String, PartConfig<*>>, FilesDeleteSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation filesDelete
     *
     * @param token Authentication token. Requires scope: &#x60;files:write:user&#x60; (optional)
     * @param file ID of file to delete. (optional)
     * @return RequestConfig
     */
    fun filesDeleteRequestConfig(token: kotlin.String?, file: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "file" to PartConfig(body = file, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token?.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/files.delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Gets information about a file.
     * @param token Authentication token. Requires scope: &#x60;files:read&#x60; (optional)
     * @param file Specify a file by providing its ID. (optional)
     * @param count  (optional)
     * @param page  (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn&#39;t been reached. (optional)
     * @param cursor Parameter for pagination. File comments are paginated for a single file. Set &#x60;cursor&#x60; equal to the &#x60;next_cursor&#x60; attribute returned by the previous request&#39;s &#x60;response_metadata&#x60;. This parameter is optional, but pagination is mandatory: the default value simply fetches the first \&quot;page\&quot; of the collection of comments. See [pagination](/docs/pagination) for more details. (optional)
     * @return FilesInfoSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filesInfo(token: kotlin.String? = null, file: kotlin.String? = null, count: kotlin.String? = null, page: kotlin.String? = null, limit: kotlin.Int? = null, cursor: kotlin.String? = null) : FilesInfoSchema = withContext(Dispatchers.IO) {
        val localVarResponse = filesInfoWithHttpInfo(token = token, file = file, count = count, page = page, limit = limit, cursor = cursor)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FilesInfoSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Gets information about a file.
     * @param token Authentication token. Requires scope: &#x60;files:read&#x60; (optional)
     * @param file Specify a file by providing its ID. (optional)
     * @param count  (optional)
     * @param page  (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn&#39;t been reached. (optional)
     * @param cursor Parameter for pagination. File comments are paginated for a single file. Set &#x60;cursor&#x60; equal to the &#x60;next_cursor&#x60; attribute returned by the previous request&#39;s &#x60;response_metadata&#x60;. This parameter is optional, but pagination is mandatory: the default value simply fetches the first \&quot;page\&quot; of the collection of comments. See [pagination](/docs/pagination) for more details. (optional)
     * @return ApiResponse<FilesInfoSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun filesInfoWithHttpInfo(token: kotlin.String?, file: kotlin.String?, count: kotlin.String?, page: kotlin.String?, limit: kotlin.Int?, cursor: kotlin.String?) : ApiResponse<FilesInfoSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = filesInfoRequestConfig(token = token, file = file, count = count, page = page, limit = limit, cursor = cursor)

        return@withContext request<Unit, FilesInfoSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation filesInfo
     *
     * @param token Authentication token. Requires scope: &#x60;files:read&#x60; (optional)
     * @param file Specify a file by providing its ID. (optional)
     * @param count  (optional)
     * @param page  (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn&#39;t been reached. (optional)
     * @param cursor Parameter for pagination. File comments are paginated for a single file. Set &#x60;cursor&#x60; equal to the &#x60;next_cursor&#x60; attribute returned by the previous request&#39;s &#x60;response_metadata&#x60;. This parameter is optional, but pagination is mandatory: the default value simply fetches the first \&quot;page\&quot; of the collection of comments. See [pagination](/docs/pagination) for more details. (optional)
     * @return RequestConfig
     */
    fun filesInfoRequestConfig(token: kotlin.String?, file: kotlin.String?, count: kotlin.String?, page: kotlin.String?, limit: kotlin.Int?, cursor: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (token != null) {
                    put("token", listOf(token.toString()))
                }
                if (file != null) {
                    put("file", listOf(file.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/files.info",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * List for a team, in a channel, or from a user with applied filters.
     * @param token Authentication token. Requires scope: &#x60;files:read&#x60; (optional)
     * @param user Filter files created by a single user. (optional)
     * @param channel Filter files appearing in a specific channel, indicated by its ID. (optional)
     * @param tsFrom Filter files created after this timestamp (inclusive). (optional)
     * @param tsTo Filter files created before this timestamp (inclusive). (optional)
     * @param types Filter files by type ([see below](#file_types)). You can pass multiple values in the types argument, like &#x60;types&#x3D;spaces,snippets&#x60;.The default value is &#x60;all&#x60;, which does not filter the list. (optional)
     * @param count  (optional)
     * @param page  (optional)
     * @param showFilesHiddenByLimit Show truncated file info for files hidden due to being too old, and the team who owns the file being over the file limit. (optional)
     * @return FilesListSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filesList(token: kotlin.String? = null, user: kotlin.String? = null, channel: kotlin.String? = null, tsFrom: java.math.BigDecimal? = null, tsTo: java.math.BigDecimal? = null, types: kotlin.String? = null, count: kotlin.String? = null, page: kotlin.String? = null, showFilesHiddenByLimit: kotlin.Boolean? = null) : FilesListSchema = withContext(Dispatchers.IO) {
        val localVarResponse = filesListWithHttpInfo(token = token, user = user, channel = channel, tsFrom = tsFrom, tsTo = tsTo, types = types, count = count, page = page, showFilesHiddenByLimit = showFilesHiddenByLimit)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FilesListSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * List for a team, in a channel, or from a user with applied filters.
     * @param token Authentication token. Requires scope: &#x60;files:read&#x60; (optional)
     * @param user Filter files created by a single user. (optional)
     * @param channel Filter files appearing in a specific channel, indicated by its ID. (optional)
     * @param tsFrom Filter files created after this timestamp (inclusive). (optional)
     * @param tsTo Filter files created before this timestamp (inclusive). (optional)
     * @param types Filter files by type ([see below](#file_types)). You can pass multiple values in the types argument, like &#x60;types&#x3D;spaces,snippets&#x60;.The default value is &#x60;all&#x60;, which does not filter the list. (optional)
     * @param count  (optional)
     * @param page  (optional)
     * @param showFilesHiddenByLimit Show truncated file info for files hidden due to being too old, and the team who owns the file being over the file limit. (optional)
     * @return ApiResponse<FilesListSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun filesListWithHttpInfo(token: kotlin.String?, user: kotlin.String?, channel: kotlin.String?, tsFrom: java.math.BigDecimal?, tsTo: java.math.BigDecimal?, types: kotlin.String?, count: kotlin.String?, page: kotlin.String?, showFilesHiddenByLimit: kotlin.Boolean?) : ApiResponse<FilesListSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = filesListRequestConfig(token = token, user = user, channel = channel, tsFrom = tsFrom, tsTo = tsTo, types = types, count = count, page = page, showFilesHiddenByLimit = showFilesHiddenByLimit)

        return@withContext request<Unit, FilesListSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation filesList
     *
     * @param token Authentication token. Requires scope: &#x60;files:read&#x60; (optional)
     * @param user Filter files created by a single user. (optional)
     * @param channel Filter files appearing in a specific channel, indicated by its ID. (optional)
     * @param tsFrom Filter files created after this timestamp (inclusive). (optional)
     * @param tsTo Filter files created before this timestamp (inclusive). (optional)
     * @param types Filter files by type ([see below](#file_types)). You can pass multiple values in the types argument, like &#x60;types&#x3D;spaces,snippets&#x60;.The default value is &#x60;all&#x60;, which does not filter the list. (optional)
     * @param count  (optional)
     * @param page  (optional)
     * @param showFilesHiddenByLimit Show truncated file info for files hidden due to being too old, and the team who owns the file being over the file limit. (optional)
     * @return RequestConfig
     */
    fun filesListRequestConfig(token: kotlin.String?, user: kotlin.String?, channel: kotlin.String?, tsFrom: java.math.BigDecimal?, tsTo: java.math.BigDecimal?, types: kotlin.String?, count: kotlin.String?, page: kotlin.String?, showFilesHiddenByLimit: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (token != null) {
                    put("token", listOf(token.toString()))
                }
                if (user != null) {
                    put("user", listOf(user.toString()))
                }
                if (channel != null) {
                    put("channel", listOf(channel.toString()))
                }
                if (tsFrom != null) {
                    put("ts_from", listOf(tsFrom.toString()))
                }
                if (tsTo != null) {
                    put("ts_to", listOf(tsTo.toString()))
                }
                if (types != null) {
                    put("types", listOf(types.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (showFilesHiddenByLimit != null) {
                    put("show_files_hidden_by_limit", listOf(showFilesHiddenByLimit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/files.list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Adds a file from a remote service
     * @param externalId Creator defined GUID for the file. (optional)
     * @param externalUrl URL of the remote file. (optional)
     * @param filetype type of file (optional)
     * @param indexableFileContents A text file (txt, pdf, doc, etc.) containing textual search terms that are used to improve discovery of the remote file. (optional)
     * @param previewImage Preview of the document via &#x60;multipart/form-data&#x60;. (optional)
     * @param title Title of the file being shared. (optional)
     * @param token Authentication token. Requires scope: &#x60;remote_files:write&#x60; (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filesRemoteAdd(externalId: kotlin.String? = null, externalUrl: kotlin.String? = null, filetype: kotlin.String? = null, indexableFileContents: kotlin.String? = null, previewImage: kotlin.String? = null, title: kotlin.String? = null, token: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = filesRemoteAddWithHttpInfo(externalId = externalId, externalUrl = externalUrl, filetype = filetype, indexableFileContents = indexableFileContents, previewImage = previewImage, title = title, token = token)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Adds a file from a remote service
     * @param externalId Creator defined GUID for the file. (optional)
     * @param externalUrl URL of the remote file. (optional)
     * @param filetype type of file (optional)
     * @param indexableFileContents A text file (txt, pdf, doc, etc.) containing textual search terms that are used to improve discovery of the remote file. (optional)
     * @param previewImage Preview of the document via &#x60;multipart/form-data&#x60;. (optional)
     * @param title Title of the file being shared. (optional)
     * @param token Authentication token. Requires scope: &#x60;remote_files:write&#x60; (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun filesRemoteAddWithHttpInfo(externalId: kotlin.String?, externalUrl: kotlin.String?, filetype: kotlin.String?, indexableFileContents: kotlin.String?, previewImage: kotlin.String?, title: kotlin.String?, token: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = filesRemoteAddRequestConfig(externalId = externalId, externalUrl = externalUrl, filetype = filetype, indexableFileContents = indexableFileContents, previewImage = previewImage, title = title, token = token)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation filesRemoteAdd
     *
     * @param externalId Creator defined GUID for the file. (optional)
     * @param externalUrl URL of the remote file. (optional)
     * @param filetype type of file (optional)
     * @param indexableFileContents A text file (txt, pdf, doc, etc.) containing textual search terms that are used to improve discovery of the remote file. (optional)
     * @param previewImage Preview of the document via &#x60;multipart/form-data&#x60;. (optional)
     * @param title Title of the file being shared. (optional)
     * @param token Authentication token. Requires scope: &#x60;remote_files:write&#x60; (optional)
     * @return RequestConfig
     */
    fun filesRemoteAddRequestConfig(externalId: kotlin.String?, externalUrl: kotlin.String?, filetype: kotlin.String?, indexableFileContents: kotlin.String?, previewImage: kotlin.String?, title: kotlin.String?, token: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "external_id" to PartConfig(body = externalId, headers = mutableMapOf()),
            "external_url" to PartConfig(body = externalUrl, headers = mutableMapOf()),
            "filetype" to PartConfig(body = filetype, headers = mutableMapOf()),
            "indexable_file_contents" to PartConfig(body = indexableFileContents, headers = mutableMapOf()),
            "preview_image" to PartConfig(body = previewImage, headers = mutableMapOf()),
            "title" to PartConfig(body = title, headers = mutableMapOf()),
            "token" to PartConfig(body = token, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/files.remote.add",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve information about a remote file added to Slack
     * @param token Authentication token. Requires scope: &#x60;remote_files:read&#x60; (optional)
     * @param file Specify a file by providing its ID. (optional)
     * @param externalId Creator defined GUID for the file. (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filesRemoteInfo(token: kotlin.String? = null, file: kotlin.String? = null, externalId: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = filesRemoteInfoWithHttpInfo(token = token, file = file, externalId = externalId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve information about a remote file added to Slack
     * @param token Authentication token. Requires scope: &#x60;remote_files:read&#x60; (optional)
     * @param file Specify a file by providing its ID. (optional)
     * @param externalId Creator defined GUID for the file. (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun filesRemoteInfoWithHttpInfo(token: kotlin.String?, file: kotlin.String?, externalId: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = filesRemoteInfoRequestConfig(token = token, file = file, externalId = externalId)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation filesRemoteInfo
     *
     * @param token Authentication token. Requires scope: &#x60;remote_files:read&#x60; (optional)
     * @param file Specify a file by providing its ID. (optional)
     * @param externalId Creator defined GUID for the file. (optional)
     * @return RequestConfig
     */
    fun filesRemoteInfoRequestConfig(token: kotlin.String?, file: kotlin.String?, externalId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (token != null) {
                    put("token", listOf(token.toString()))
                }
                if (file != null) {
                    put("file", listOf(file.toString()))
                }
                if (externalId != null) {
                    put("external_id", listOf(externalId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/files.remote.info",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve information about a remote file added to Slack
     * @param token Authentication token. Requires scope: &#x60;remote_files:read&#x60; (optional)
     * @param channel Filter files appearing in a specific channel, indicated by its ID. (optional)
     * @param tsFrom Filter files created after this timestamp (inclusive). (optional)
     * @param tsTo Filter files created before this timestamp (inclusive). (optional)
     * @param limit The maximum number of items to return. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filesRemoteList(token: kotlin.String? = null, channel: kotlin.String? = null, tsFrom: java.math.BigDecimal? = null, tsTo: java.math.BigDecimal? = null, limit: kotlin.Int? = null, cursor: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = filesRemoteListWithHttpInfo(token = token, channel = channel, tsFrom = tsFrom, tsTo = tsTo, limit = limit, cursor = cursor)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve information about a remote file added to Slack
     * @param token Authentication token. Requires scope: &#x60;remote_files:read&#x60; (optional)
     * @param channel Filter files appearing in a specific channel, indicated by its ID. (optional)
     * @param tsFrom Filter files created after this timestamp (inclusive). (optional)
     * @param tsTo Filter files created before this timestamp (inclusive). (optional)
     * @param limit The maximum number of items to return. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun filesRemoteListWithHttpInfo(token: kotlin.String?, channel: kotlin.String?, tsFrom: java.math.BigDecimal?, tsTo: java.math.BigDecimal?, limit: kotlin.Int?, cursor: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = filesRemoteListRequestConfig(token = token, channel = channel, tsFrom = tsFrom, tsTo = tsTo, limit = limit, cursor = cursor)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation filesRemoteList
     *
     * @param token Authentication token. Requires scope: &#x60;remote_files:read&#x60; (optional)
     * @param channel Filter files appearing in a specific channel, indicated by its ID. (optional)
     * @param tsFrom Filter files created after this timestamp (inclusive). (optional)
     * @param tsTo Filter files created before this timestamp (inclusive). (optional)
     * @param limit The maximum number of items to return. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return RequestConfig
     */
    fun filesRemoteListRequestConfig(token: kotlin.String?, channel: kotlin.String?, tsFrom: java.math.BigDecimal?, tsTo: java.math.BigDecimal?, limit: kotlin.Int?, cursor: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (token != null) {
                    put("token", listOf(token.toString()))
                }
                if (channel != null) {
                    put("channel", listOf(channel.toString()))
                }
                if (tsFrom != null) {
                    put("ts_from", listOf(tsFrom.toString()))
                }
                if (tsTo != null) {
                    put("ts_to", listOf(tsTo.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/files.remote.list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Remove a remote file.
     * @param externalId Creator defined GUID for the file. (optional)
     * @param file Specify a file by providing its ID. (optional)
     * @param token Authentication token. Requires scope: &#x60;remote_files:write&#x60; (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filesRemoteRemove(externalId: kotlin.String? = null, file: kotlin.String? = null, token: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = filesRemoteRemoveWithHttpInfo(externalId = externalId, file = file, token = token)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Remove a remote file.
     * @param externalId Creator defined GUID for the file. (optional)
     * @param file Specify a file by providing its ID. (optional)
     * @param token Authentication token. Requires scope: &#x60;remote_files:write&#x60; (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun filesRemoteRemoveWithHttpInfo(externalId: kotlin.String?, file: kotlin.String?, token: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = filesRemoteRemoveRequestConfig(externalId = externalId, file = file, token = token)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation filesRemoteRemove
     *
     * @param externalId Creator defined GUID for the file. (optional)
     * @param file Specify a file by providing its ID. (optional)
     * @param token Authentication token. Requires scope: &#x60;remote_files:write&#x60; (optional)
     * @return RequestConfig
     */
    fun filesRemoteRemoveRequestConfig(externalId: kotlin.String?, file: kotlin.String?, token: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "external_id" to PartConfig(body = externalId, headers = mutableMapOf()),
            "file" to PartConfig(body = file, headers = mutableMapOf()),
            "token" to PartConfig(body = token, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/files.remote.remove",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Share a remote file into a channel.
     * @param token Authentication token. Requires scope: &#x60;remote_files:share&#x60; (optional)
     * @param file Specify a file registered with Slack by providing its ID. Either this field or &#x60;external_id&#x60; or both are required. (optional)
     * @param externalId The globally unique identifier (GUID) for the file, as set by the app registering the file with Slack.  Either this field or &#x60;file&#x60; or both are required. (optional)
     * @param channels Comma-separated list of channel IDs where the file will be shared. (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filesRemoteShare(token: kotlin.String? = null, file: kotlin.String? = null, externalId: kotlin.String? = null, channels: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = filesRemoteShareWithHttpInfo(token = token, file = file, externalId = externalId, channels = channels)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Share a remote file into a channel.
     * @param token Authentication token. Requires scope: &#x60;remote_files:share&#x60; (optional)
     * @param file Specify a file registered with Slack by providing its ID. Either this field or &#x60;external_id&#x60; or both are required. (optional)
     * @param externalId The globally unique identifier (GUID) for the file, as set by the app registering the file with Slack.  Either this field or &#x60;file&#x60; or both are required. (optional)
     * @param channels Comma-separated list of channel IDs where the file will be shared. (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun filesRemoteShareWithHttpInfo(token: kotlin.String?, file: kotlin.String?, externalId: kotlin.String?, channels: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = filesRemoteShareRequestConfig(token = token, file = file, externalId = externalId, channels = channels)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation filesRemoteShare
     *
     * @param token Authentication token. Requires scope: &#x60;remote_files:share&#x60; (optional)
     * @param file Specify a file registered with Slack by providing its ID. Either this field or &#x60;external_id&#x60; or both are required. (optional)
     * @param externalId The globally unique identifier (GUID) for the file, as set by the app registering the file with Slack.  Either this field or &#x60;file&#x60; or both are required. (optional)
     * @param channels Comma-separated list of channel IDs where the file will be shared. (optional)
     * @return RequestConfig
     */
    fun filesRemoteShareRequestConfig(token: kotlin.String?, file: kotlin.String?, externalId: kotlin.String?, channels: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (token != null) {
                    put("token", listOf(token.toString()))
                }
                if (file != null) {
                    put("file", listOf(file.toString()))
                }
                if (externalId != null) {
                    put("external_id", listOf(externalId.toString()))
                }
                if (channels != null) {
                    put("channels", listOf(channels.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/files.remote.share",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Updates an existing remote file.
     * @param externalId Creator defined GUID for the file. (optional)
     * @param externalUrl URL of the remote file. (optional)
     * @param file Specify a file by providing its ID. (optional)
     * @param filetype type of file (optional)
     * @param indexableFileContents File containing contents that can be used to improve searchability for the remote file. (optional)
     * @param previewImage Preview of the document via &#x60;multipart/form-data&#x60;. (optional)
     * @param title Title of the file being shared. (optional)
     * @param token Authentication token. Requires scope: &#x60;remote_files:write&#x60; (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filesRemoteUpdate(externalId: kotlin.String? = null, externalUrl: kotlin.String? = null, file: kotlin.String? = null, filetype: kotlin.String? = null, indexableFileContents: kotlin.String? = null, previewImage: kotlin.String? = null, title: kotlin.String? = null, token: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = filesRemoteUpdateWithHttpInfo(externalId = externalId, externalUrl = externalUrl, file = file, filetype = filetype, indexableFileContents = indexableFileContents, previewImage = previewImage, title = title, token = token)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Updates an existing remote file.
     * @param externalId Creator defined GUID for the file. (optional)
     * @param externalUrl URL of the remote file. (optional)
     * @param file Specify a file by providing its ID. (optional)
     * @param filetype type of file (optional)
     * @param indexableFileContents File containing contents that can be used to improve searchability for the remote file. (optional)
     * @param previewImage Preview of the document via &#x60;multipart/form-data&#x60;. (optional)
     * @param title Title of the file being shared. (optional)
     * @param token Authentication token. Requires scope: &#x60;remote_files:write&#x60; (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun filesRemoteUpdateWithHttpInfo(externalId: kotlin.String?, externalUrl: kotlin.String?, file: kotlin.String?, filetype: kotlin.String?, indexableFileContents: kotlin.String?, previewImage: kotlin.String?, title: kotlin.String?, token: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = filesRemoteUpdateRequestConfig(externalId = externalId, externalUrl = externalUrl, file = file, filetype = filetype, indexableFileContents = indexableFileContents, previewImage = previewImage, title = title, token = token)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation filesRemoteUpdate
     *
     * @param externalId Creator defined GUID for the file. (optional)
     * @param externalUrl URL of the remote file. (optional)
     * @param file Specify a file by providing its ID. (optional)
     * @param filetype type of file (optional)
     * @param indexableFileContents File containing contents that can be used to improve searchability for the remote file. (optional)
     * @param previewImage Preview of the document via &#x60;multipart/form-data&#x60;. (optional)
     * @param title Title of the file being shared. (optional)
     * @param token Authentication token. Requires scope: &#x60;remote_files:write&#x60; (optional)
     * @return RequestConfig
     */
    fun filesRemoteUpdateRequestConfig(externalId: kotlin.String?, externalUrl: kotlin.String?, file: kotlin.String?, filetype: kotlin.String?, indexableFileContents: kotlin.String?, previewImage: kotlin.String?, title: kotlin.String?, token: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "external_id" to PartConfig(body = externalId, headers = mutableMapOf()),
            "external_url" to PartConfig(body = externalUrl, headers = mutableMapOf()),
            "file" to PartConfig(body = file, headers = mutableMapOf()),
            "filetype" to PartConfig(body = filetype, headers = mutableMapOf()),
            "indexable_file_contents" to PartConfig(body = indexableFileContents, headers = mutableMapOf()),
            "preview_image" to PartConfig(body = previewImage, headers = mutableMapOf()),
            "title" to PartConfig(body = title, headers = mutableMapOf()),
            "token" to PartConfig(body = token, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/files.remote.update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Revokes public/external sharing access for a file
     * @param token Authentication token. Requires scope: &#x60;files:write:user&#x60; (optional)
     * @param file File to revoke (optional)
     * @return FilesRevokePublicURLSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filesRevokePublicURL(token: kotlin.String? = null, file: kotlin.String? = null) : FilesRevokePublicURLSchema = withContext(Dispatchers.IO) {
        val localVarResponse = filesRevokePublicURLWithHttpInfo(token = token, file = file)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FilesRevokePublicURLSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Revokes public/external sharing access for a file
     * @param token Authentication token. Requires scope: &#x60;files:write:user&#x60; (optional)
     * @param file File to revoke (optional)
     * @return ApiResponse<FilesRevokePublicURLSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun filesRevokePublicURLWithHttpInfo(token: kotlin.String?, file: kotlin.String?) : ApiResponse<FilesRevokePublicURLSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = filesRevokePublicURLRequestConfig(token = token, file = file)

        return@withContext request<Map<String, PartConfig<*>>, FilesRevokePublicURLSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation filesRevokePublicURL
     *
     * @param token Authentication token. Requires scope: &#x60;files:write:user&#x60; (optional)
     * @param file File to revoke (optional)
     * @return RequestConfig
     */
    fun filesRevokePublicURLRequestConfig(token: kotlin.String?, file: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "file" to PartConfig(body = file, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token?.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/files.revokePublicURL",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Enables a file for public/external sharing.
     * @param token Authentication token. Requires scope: &#x60;files:write:user&#x60; (optional)
     * @param file File to share (optional)
     * @return FilesSharedPublicURLSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filesSharedPublicURL(token: kotlin.String? = null, file: kotlin.String? = null) : FilesSharedPublicURLSchema = withContext(Dispatchers.IO) {
        val localVarResponse = filesSharedPublicURLWithHttpInfo(token = token, file = file)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FilesSharedPublicURLSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Enables a file for public/external sharing.
     * @param token Authentication token. Requires scope: &#x60;files:write:user&#x60; (optional)
     * @param file File to share (optional)
     * @return ApiResponse<FilesSharedPublicURLSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun filesSharedPublicURLWithHttpInfo(token: kotlin.String?, file: kotlin.String?) : ApiResponse<FilesSharedPublicURLSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = filesSharedPublicURLRequestConfig(token = token, file = file)

        return@withContext request<Map<String, PartConfig<*>>, FilesSharedPublicURLSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation filesSharedPublicURL
     *
     * @param token Authentication token. Requires scope: &#x60;files:write:user&#x60; (optional)
     * @param file File to share (optional)
     * @return RequestConfig
     */
    fun filesSharedPublicURLRequestConfig(token: kotlin.String?, file: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "file" to PartConfig(body = file, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token?.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/files.sharedPublicURL",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Uploads or creates a file.
     * @param channels Comma-separated list of channel names or IDs where the file will be shared. (optional)
     * @param content File contents via a POST variable. If omitting this parameter, you must provide a &#x60;file&#x60;. (optional)
     * @param file File contents via &#x60;multipart/form-data&#x60;. If omitting this parameter, you must submit &#x60;content&#x60;. (optional)
     * @param filename Filename of file. (optional)
     * @param filetype A [file type](/types/file#file_types) identifier. (optional)
     * @param initialComment The message text introducing the file in specified &#x60;channels&#x60;. (optional)
     * @param threadTs Provide another message&#39;s &#x60;ts&#x60; value to upload this file as a reply. Never use a reply&#39;s &#x60;ts&#x60; value; use its parent instead. (optional)
     * @param title Title of file. (optional)
     * @param token Authentication token. Requires scope: &#x60;files:write:user&#x60; (optional)
     * @return FilesUploadSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filesUpload(channels: kotlin.String? = null, content: kotlin.String? = null, file: kotlin.String? = null, filename: kotlin.String? = null, filetype: kotlin.String? = null, initialComment: kotlin.String? = null, threadTs: java.math.BigDecimal? = null, title: kotlin.String? = null, token: kotlin.String? = null) : FilesUploadSchema = withContext(Dispatchers.IO) {
        val localVarResponse = filesUploadWithHttpInfo(channels = channels, content = content, file = file, filename = filename, filetype = filetype, initialComment = initialComment, threadTs = threadTs, title = title, token = token)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FilesUploadSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Uploads or creates a file.
     * @param channels Comma-separated list of channel names or IDs where the file will be shared. (optional)
     * @param content File contents via a POST variable. If omitting this parameter, you must provide a &#x60;file&#x60;. (optional)
     * @param file File contents via &#x60;multipart/form-data&#x60;. If omitting this parameter, you must submit &#x60;content&#x60;. (optional)
     * @param filename Filename of file. (optional)
     * @param filetype A [file type](/types/file#file_types) identifier. (optional)
     * @param initialComment The message text introducing the file in specified &#x60;channels&#x60;. (optional)
     * @param threadTs Provide another message&#39;s &#x60;ts&#x60; value to upload this file as a reply. Never use a reply&#39;s &#x60;ts&#x60; value; use its parent instead. (optional)
     * @param title Title of file. (optional)
     * @param token Authentication token. Requires scope: &#x60;files:write:user&#x60; (optional)
     * @return ApiResponse<FilesUploadSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun filesUploadWithHttpInfo(channels: kotlin.String?, content: kotlin.String?, file: kotlin.String?, filename: kotlin.String?, filetype: kotlin.String?, initialComment: kotlin.String?, threadTs: java.math.BigDecimal?, title: kotlin.String?, token: kotlin.String?) : ApiResponse<FilesUploadSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = filesUploadRequestConfig(channels = channels, content = content, file = file, filename = filename, filetype = filetype, initialComment = initialComment, threadTs = threadTs, title = title, token = token)

        return@withContext request<Map<String, PartConfig<*>>, FilesUploadSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation filesUpload
     *
     * @param channels Comma-separated list of channel names or IDs where the file will be shared. (optional)
     * @param content File contents via a POST variable. If omitting this parameter, you must provide a &#x60;file&#x60;. (optional)
     * @param file File contents via &#x60;multipart/form-data&#x60;. If omitting this parameter, you must submit &#x60;content&#x60;. (optional)
     * @param filename Filename of file. (optional)
     * @param filetype A [file type](/types/file#file_types) identifier. (optional)
     * @param initialComment The message text introducing the file in specified &#x60;channels&#x60;. (optional)
     * @param threadTs Provide another message&#39;s &#x60;ts&#x60; value to upload this file as a reply. Never use a reply&#39;s &#x60;ts&#x60; value; use its parent instead. (optional)
     * @param title Title of file. (optional)
     * @param token Authentication token. Requires scope: &#x60;files:write:user&#x60; (optional)
     * @return RequestConfig
     */
    fun filesUploadRequestConfig(channels: kotlin.String?, content: kotlin.String?, file: kotlin.String?, filename: kotlin.String?, filetype: kotlin.String?, initialComment: kotlin.String?, threadTs: java.math.BigDecimal?, title: kotlin.String?, token: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channels" to PartConfig(body = channels, headers = mutableMapOf()),
            "content" to PartConfig(body = content, headers = mutableMapOf()),
            "file" to PartConfig(body = file, headers = mutableMapOf()),
            "filename" to PartConfig(body = filename, headers = mutableMapOf()),
            "filetype" to PartConfig(body = filetype, headers = mutableMapOf()),
            "initial_comment" to PartConfig(body = initialComment, headers = mutableMapOf()),
            "thread_ts" to PartConfig(body = threadTs, headers = mutableMapOf()),
            "title" to PartConfig(body = title, headers = mutableMapOf()),
            "token" to PartConfig(body = token, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/files.upload",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
