/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package slack.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.outmatchapi.slack.DefaultErrorTemplate
import com.outmatchapi.slack.DefaultSuccessTemplate
import com.outmatchapi.slack.DndEndDndErrorSchema
import com.outmatchapi.slack.DndEndDndSchema
import com.outmatchapi.slack.DndEndSnoozeErrorSchema
import com.outmatchapi.slack.DndEndSnoozeSchema
import com.outmatchapi.slack.DndInfoErrorSchema
import com.outmatchapi.slack.DndInfoSchema
import com.outmatchapi.slack.DndSetSnoozeErrorSchema
import com.outmatchapi.slack.DndSetSnoozeSchema

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import slack.infrastructure.ApiClient
import slack.infrastructure.ApiResponse
import slack.infrastructure.ClientException
import slack.infrastructure.ClientError
import slack.infrastructure.ServerException
import slack.infrastructure.ServerError
import slack.infrastructure.MultiValueMap
import slack.infrastructure.PartConfig
import slack.infrastructure.RequestConfig
import slack.infrastructure.RequestMethod
import slack.infrastructure.ResponseType
import slack.infrastructure.Success
import slack.infrastructure.toMultiValue

class DndApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://slack.com/api")
        }
    }

    /**
     * 
     * Ends the current user&#39;s Do Not Disturb session immediately.
     * @param token Authentication token. Requires scope: &#x60;dnd:write&#x60;
     * @return DndEndDndSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun dndEndDnd(token: kotlin.String) : DndEndDndSchema = withContext(Dispatchers.IO) {
        val localVarResponse = dndEndDndWithHttpInfo(token = token)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DndEndDndSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Ends the current user&#39;s Do Not Disturb session immediately.
     * @param token Authentication token. Requires scope: &#x60;dnd:write&#x60;
     * @return ApiResponse<DndEndDndSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun dndEndDndWithHttpInfo(token: kotlin.String) : ApiResponse<DndEndDndSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = dndEndDndRequestConfig(token = token)

        return@withContext request<Unit, DndEndDndSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation dndEndDnd
     *
     * @param token Authentication token. Requires scope: &#x60;dnd:write&#x60;
     * @return RequestConfig
     */
    fun dndEndDndRequestConfig(token: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/dnd.endDnd",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Ends the current user&#39;s snooze mode immediately.
     * @param token Authentication token. Requires scope: &#x60;dnd:write&#x60;
     * @return DndEndSnoozeSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun dndEndSnooze(token: kotlin.String) : DndEndSnoozeSchema = withContext(Dispatchers.IO) {
        val localVarResponse = dndEndSnoozeWithHttpInfo(token = token)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DndEndSnoozeSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Ends the current user&#39;s snooze mode immediately.
     * @param token Authentication token. Requires scope: &#x60;dnd:write&#x60;
     * @return ApiResponse<DndEndSnoozeSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun dndEndSnoozeWithHttpInfo(token: kotlin.String) : ApiResponse<DndEndSnoozeSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = dndEndSnoozeRequestConfig(token = token)

        return@withContext request<Unit, DndEndSnoozeSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation dndEndSnooze
     *
     * @param token Authentication token. Requires scope: &#x60;dnd:write&#x60;
     * @return RequestConfig
     */
    fun dndEndSnoozeRequestConfig(token: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/dnd.endSnooze",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieves a user&#39;s current Do Not Disturb status.
     * @param token Authentication token. Requires scope: &#x60;dnd:read&#x60; (optional)
     * @param user User to fetch status for (defaults to current user) (optional)
     * @return DndInfoSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun dndInfo(token: kotlin.String? = null, user: kotlin.String? = null) : DndInfoSchema = withContext(Dispatchers.IO) {
        val localVarResponse = dndInfoWithHttpInfo(token = token, user = user)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DndInfoSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieves a user&#39;s current Do Not Disturb status.
     * @param token Authentication token. Requires scope: &#x60;dnd:read&#x60; (optional)
     * @param user User to fetch status for (defaults to current user) (optional)
     * @return ApiResponse<DndInfoSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun dndInfoWithHttpInfo(token: kotlin.String?, user: kotlin.String?) : ApiResponse<DndInfoSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = dndInfoRequestConfig(token = token, user = user)

        return@withContext request<Unit, DndInfoSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation dndInfo
     *
     * @param token Authentication token. Requires scope: &#x60;dnd:read&#x60; (optional)
     * @param user User to fetch status for (defaults to current user) (optional)
     * @return RequestConfig
     */
    fun dndInfoRequestConfig(token: kotlin.String?, user: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (token != null) {
                    put("token", listOf(token.toString()))
                }
                if (user != null) {
                    put("user", listOf(user.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dnd.info",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Turns on Do Not Disturb mode for the current user, or changes its duration.
     * @param numMinutes Number of minutes, from now, to snooze until.
     * @param token Authentication token. Requires scope: &#x60;dnd:write&#x60;
     * @return DndSetSnoozeSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun dndSetSnooze(numMinutes: kotlin.String, token: kotlin.String) : DndSetSnoozeSchema = withContext(Dispatchers.IO) {
        val localVarResponse = dndSetSnoozeWithHttpInfo(numMinutes = numMinutes, token = token)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DndSetSnoozeSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Turns on Do Not Disturb mode for the current user, or changes its duration.
     * @param numMinutes Number of minutes, from now, to snooze until.
     * @param token Authentication token. Requires scope: &#x60;dnd:write&#x60;
     * @return ApiResponse<DndSetSnoozeSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun dndSetSnoozeWithHttpInfo(numMinutes: kotlin.String, token: kotlin.String) : ApiResponse<DndSetSnoozeSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = dndSetSnoozeRequestConfig(numMinutes = numMinutes, token = token)

        return@withContext request<Map<String, PartConfig<*>>, DndSetSnoozeSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation dndSetSnooze
     *
     * @param numMinutes Number of minutes, from now, to snooze until.
     * @param token Authentication token. Requires scope: &#x60;dnd:write&#x60;
     * @return RequestConfig
     */
    fun dndSetSnoozeRequestConfig(numMinutes: kotlin.String, token: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "num_minutes" to PartConfig(body = numMinutes, headers = mutableMapOf()),
            "token" to PartConfig(body = token, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/dnd.setSnooze",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieves the Do Not Disturb status for up to 50 users on a team.
     * @param token Authentication token. Requires scope: &#x60;dnd:read&#x60; (optional)
     * @param users Comma-separated list of users to fetch Do Not Disturb status for (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun dndTeamInfo(token: kotlin.String? = null, users: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = dndTeamInfoWithHttpInfo(token = token, users = users)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieves the Do Not Disturb status for up to 50 users on a team.
     * @param token Authentication token. Requires scope: &#x60;dnd:read&#x60; (optional)
     * @param users Comma-separated list of users to fetch Do Not Disturb status for (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun dndTeamInfoWithHttpInfo(token: kotlin.String?, users: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = dndTeamInfoRequestConfig(token = token, users = users)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation dndTeamInfo
     *
     * @param token Authentication token. Requires scope: &#x60;dnd:read&#x60; (optional)
     * @param users Comma-separated list of users to fetch Do Not Disturb status for (optional)
     * @return RequestConfig
     */
    fun dndTeamInfoRequestConfig(token: kotlin.String?, users: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (token != null) {
                    put("token", listOf(token.toString()))
                }
                if (users != null) {
                    put("users", listOf(users.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dnd.teamInfo",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
