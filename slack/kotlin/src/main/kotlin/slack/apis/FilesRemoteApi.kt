/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package slack.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.outmatchapi.slack.DefaultErrorTemplate
import com.outmatchapi.slack.DefaultSuccessTemplate

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import slack.infrastructure.ApiClient
import slack.infrastructure.ApiResponse
import slack.infrastructure.ClientException
import slack.infrastructure.ClientError
import slack.infrastructure.ServerException
import slack.infrastructure.ServerError
import slack.infrastructure.MultiValueMap
import slack.infrastructure.PartConfig
import slack.infrastructure.RequestConfig
import slack.infrastructure.RequestMethod
import slack.infrastructure.ResponseType
import slack.infrastructure.Success
import slack.infrastructure.toMultiValue

class FilesRemoteApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://slack.com/api")
        }
    }

    /**
     * 
     * Adds a file from a remote service
     * @param externalId Creator defined GUID for the file. (optional)
     * @param externalUrl URL of the remote file. (optional)
     * @param filetype type of file (optional)
     * @param indexableFileContents A text file (txt, pdf, doc, etc.) containing textual search terms that are used to improve discovery of the remote file. (optional)
     * @param previewImage Preview of the document via &#x60;multipart/form-data&#x60;. (optional)
     * @param title Title of the file being shared. (optional)
     * @param token Authentication token. Requires scope: &#x60;remote_files:write&#x60; (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filesRemoteAdd(externalId: kotlin.String? = null, externalUrl: kotlin.String? = null, filetype: kotlin.String? = null, indexableFileContents: kotlin.String? = null, previewImage: kotlin.String? = null, title: kotlin.String? = null, token: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = filesRemoteAddWithHttpInfo(externalId = externalId, externalUrl = externalUrl, filetype = filetype, indexableFileContents = indexableFileContents, previewImage = previewImage, title = title, token = token)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Adds a file from a remote service
     * @param externalId Creator defined GUID for the file. (optional)
     * @param externalUrl URL of the remote file. (optional)
     * @param filetype type of file (optional)
     * @param indexableFileContents A text file (txt, pdf, doc, etc.) containing textual search terms that are used to improve discovery of the remote file. (optional)
     * @param previewImage Preview of the document via &#x60;multipart/form-data&#x60;. (optional)
     * @param title Title of the file being shared. (optional)
     * @param token Authentication token. Requires scope: &#x60;remote_files:write&#x60; (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun filesRemoteAddWithHttpInfo(externalId: kotlin.String?, externalUrl: kotlin.String?, filetype: kotlin.String?, indexableFileContents: kotlin.String?, previewImage: kotlin.String?, title: kotlin.String?, token: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = filesRemoteAddRequestConfig(externalId = externalId, externalUrl = externalUrl, filetype = filetype, indexableFileContents = indexableFileContents, previewImage = previewImage, title = title, token = token)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation filesRemoteAdd
     *
     * @param externalId Creator defined GUID for the file. (optional)
     * @param externalUrl URL of the remote file. (optional)
     * @param filetype type of file (optional)
     * @param indexableFileContents A text file (txt, pdf, doc, etc.) containing textual search terms that are used to improve discovery of the remote file. (optional)
     * @param previewImage Preview of the document via &#x60;multipart/form-data&#x60;. (optional)
     * @param title Title of the file being shared. (optional)
     * @param token Authentication token. Requires scope: &#x60;remote_files:write&#x60; (optional)
     * @return RequestConfig
     */
    fun filesRemoteAddRequestConfig(externalId: kotlin.String?, externalUrl: kotlin.String?, filetype: kotlin.String?, indexableFileContents: kotlin.String?, previewImage: kotlin.String?, title: kotlin.String?, token: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "external_id" to PartConfig(body = externalId, headers = mutableMapOf()),
            "external_url" to PartConfig(body = externalUrl, headers = mutableMapOf()),
            "filetype" to PartConfig(body = filetype, headers = mutableMapOf()),
            "indexable_file_contents" to PartConfig(body = indexableFileContents, headers = mutableMapOf()),
            "preview_image" to PartConfig(body = previewImage, headers = mutableMapOf()),
            "title" to PartConfig(body = title, headers = mutableMapOf()),
            "token" to PartConfig(body = token, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/files.remote.add",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve information about a remote file added to Slack
     * @param token Authentication token. Requires scope: &#x60;remote_files:read&#x60; (optional)
     * @param file Specify a file by providing its ID. (optional)
     * @param externalId Creator defined GUID for the file. (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filesRemoteInfo(token: kotlin.String? = null, file: kotlin.String? = null, externalId: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = filesRemoteInfoWithHttpInfo(token = token, file = file, externalId = externalId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve information about a remote file added to Slack
     * @param token Authentication token. Requires scope: &#x60;remote_files:read&#x60; (optional)
     * @param file Specify a file by providing its ID. (optional)
     * @param externalId Creator defined GUID for the file. (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun filesRemoteInfoWithHttpInfo(token: kotlin.String?, file: kotlin.String?, externalId: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = filesRemoteInfoRequestConfig(token = token, file = file, externalId = externalId)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation filesRemoteInfo
     *
     * @param token Authentication token. Requires scope: &#x60;remote_files:read&#x60; (optional)
     * @param file Specify a file by providing its ID. (optional)
     * @param externalId Creator defined GUID for the file. (optional)
     * @return RequestConfig
     */
    fun filesRemoteInfoRequestConfig(token: kotlin.String?, file: kotlin.String?, externalId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (token != null) {
                    put("token", listOf(token.toString()))
                }
                if (file != null) {
                    put("file", listOf(file.toString()))
                }
                if (externalId != null) {
                    put("external_id", listOf(externalId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/files.remote.info",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve information about a remote file added to Slack
     * @param token Authentication token. Requires scope: &#x60;remote_files:read&#x60; (optional)
     * @param channel Filter files appearing in a specific channel, indicated by its ID. (optional)
     * @param tsFrom Filter files created after this timestamp (inclusive). (optional)
     * @param tsTo Filter files created before this timestamp (inclusive). (optional)
     * @param limit The maximum number of items to return. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filesRemoteList(token: kotlin.String? = null, channel: kotlin.String? = null, tsFrom: java.math.BigDecimal? = null, tsTo: java.math.BigDecimal? = null, limit: kotlin.Int? = null, cursor: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = filesRemoteListWithHttpInfo(token = token, channel = channel, tsFrom = tsFrom, tsTo = tsTo, limit = limit, cursor = cursor)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve information about a remote file added to Slack
     * @param token Authentication token. Requires scope: &#x60;remote_files:read&#x60; (optional)
     * @param channel Filter files appearing in a specific channel, indicated by its ID. (optional)
     * @param tsFrom Filter files created after this timestamp (inclusive). (optional)
     * @param tsTo Filter files created before this timestamp (inclusive). (optional)
     * @param limit The maximum number of items to return. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun filesRemoteListWithHttpInfo(token: kotlin.String?, channel: kotlin.String?, tsFrom: java.math.BigDecimal?, tsTo: java.math.BigDecimal?, limit: kotlin.Int?, cursor: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = filesRemoteListRequestConfig(token = token, channel = channel, tsFrom = tsFrom, tsTo = tsTo, limit = limit, cursor = cursor)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation filesRemoteList
     *
     * @param token Authentication token. Requires scope: &#x60;remote_files:read&#x60; (optional)
     * @param channel Filter files appearing in a specific channel, indicated by its ID. (optional)
     * @param tsFrom Filter files created after this timestamp (inclusive). (optional)
     * @param tsTo Filter files created before this timestamp (inclusive). (optional)
     * @param limit The maximum number of items to return. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return RequestConfig
     */
    fun filesRemoteListRequestConfig(token: kotlin.String?, channel: kotlin.String?, tsFrom: java.math.BigDecimal?, tsTo: java.math.BigDecimal?, limit: kotlin.Int?, cursor: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (token != null) {
                    put("token", listOf(token.toString()))
                }
                if (channel != null) {
                    put("channel", listOf(channel.toString()))
                }
                if (tsFrom != null) {
                    put("ts_from", listOf(tsFrom.toString()))
                }
                if (tsTo != null) {
                    put("ts_to", listOf(tsTo.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/files.remote.list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Remove a remote file.
     * @param externalId Creator defined GUID for the file. (optional)
     * @param file Specify a file by providing its ID. (optional)
     * @param token Authentication token. Requires scope: &#x60;remote_files:write&#x60; (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filesRemoteRemove(externalId: kotlin.String? = null, file: kotlin.String? = null, token: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = filesRemoteRemoveWithHttpInfo(externalId = externalId, file = file, token = token)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Remove a remote file.
     * @param externalId Creator defined GUID for the file. (optional)
     * @param file Specify a file by providing its ID. (optional)
     * @param token Authentication token. Requires scope: &#x60;remote_files:write&#x60; (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun filesRemoteRemoveWithHttpInfo(externalId: kotlin.String?, file: kotlin.String?, token: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = filesRemoteRemoveRequestConfig(externalId = externalId, file = file, token = token)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation filesRemoteRemove
     *
     * @param externalId Creator defined GUID for the file. (optional)
     * @param file Specify a file by providing its ID. (optional)
     * @param token Authentication token. Requires scope: &#x60;remote_files:write&#x60; (optional)
     * @return RequestConfig
     */
    fun filesRemoteRemoveRequestConfig(externalId: kotlin.String?, file: kotlin.String?, token: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "external_id" to PartConfig(body = externalId, headers = mutableMapOf()),
            "file" to PartConfig(body = file, headers = mutableMapOf()),
            "token" to PartConfig(body = token, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/files.remote.remove",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Share a remote file into a channel.
     * @param token Authentication token. Requires scope: &#x60;remote_files:share&#x60; (optional)
     * @param file Specify a file registered with Slack by providing its ID. Either this field or &#x60;external_id&#x60; or both are required. (optional)
     * @param externalId The globally unique identifier (GUID) for the file, as set by the app registering the file with Slack.  Either this field or &#x60;file&#x60; or both are required. (optional)
     * @param channels Comma-separated list of channel IDs where the file will be shared. (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filesRemoteShare(token: kotlin.String? = null, file: kotlin.String? = null, externalId: kotlin.String? = null, channels: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = filesRemoteShareWithHttpInfo(token = token, file = file, externalId = externalId, channels = channels)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Share a remote file into a channel.
     * @param token Authentication token. Requires scope: &#x60;remote_files:share&#x60; (optional)
     * @param file Specify a file registered with Slack by providing its ID. Either this field or &#x60;external_id&#x60; or both are required. (optional)
     * @param externalId The globally unique identifier (GUID) for the file, as set by the app registering the file with Slack.  Either this field or &#x60;file&#x60; or both are required. (optional)
     * @param channels Comma-separated list of channel IDs where the file will be shared. (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun filesRemoteShareWithHttpInfo(token: kotlin.String?, file: kotlin.String?, externalId: kotlin.String?, channels: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = filesRemoteShareRequestConfig(token = token, file = file, externalId = externalId, channels = channels)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation filesRemoteShare
     *
     * @param token Authentication token. Requires scope: &#x60;remote_files:share&#x60; (optional)
     * @param file Specify a file registered with Slack by providing its ID. Either this field or &#x60;external_id&#x60; or both are required. (optional)
     * @param externalId The globally unique identifier (GUID) for the file, as set by the app registering the file with Slack.  Either this field or &#x60;file&#x60; or both are required. (optional)
     * @param channels Comma-separated list of channel IDs where the file will be shared. (optional)
     * @return RequestConfig
     */
    fun filesRemoteShareRequestConfig(token: kotlin.String?, file: kotlin.String?, externalId: kotlin.String?, channels: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (token != null) {
                    put("token", listOf(token.toString()))
                }
                if (file != null) {
                    put("file", listOf(file.toString()))
                }
                if (externalId != null) {
                    put("external_id", listOf(externalId.toString()))
                }
                if (channels != null) {
                    put("channels", listOf(channels.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/files.remote.share",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Updates an existing remote file.
     * @param externalId Creator defined GUID for the file. (optional)
     * @param externalUrl URL of the remote file. (optional)
     * @param file Specify a file by providing its ID. (optional)
     * @param filetype type of file (optional)
     * @param indexableFileContents File containing contents that can be used to improve searchability for the remote file. (optional)
     * @param previewImage Preview of the document via &#x60;multipart/form-data&#x60;. (optional)
     * @param title Title of the file being shared. (optional)
     * @param token Authentication token. Requires scope: &#x60;remote_files:write&#x60; (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filesRemoteUpdate(externalId: kotlin.String? = null, externalUrl: kotlin.String? = null, file: kotlin.String? = null, filetype: kotlin.String? = null, indexableFileContents: kotlin.String? = null, previewImage: kotlin.String? = null, title: kotlin.String? = null, token: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = filesRemoteUpdateWithHttpInfo(externalId = externalId, externalUrl = externalUrl, file = file, filetype = filetype, indexableFileContents = indexableFileContents, previewImage = previewImage, title = title, token = token)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Updates an existing remote file.
     * @param externalId Creator defined GUID for the file. (optional)
     * @param externalUrl URL of the remote file. (optional)
     * @param file Specify a file by providing its ID. (optional)
     * @param filetype type of file (optional)
     * @param indexableFileContents File containing contents that can be used to improve searchability for the remote file. (optional)
     * @param previewImage Preview of the document via &#x60;multipart/form-data&#x60;. (optional)
     * @param title Title of the file being shared. (optional)
     * @param token Authentication token. Requires scope: &#x60;remote_files:write&#x60; (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun filesRemoteUpdateWithHttpInfo(externalId: kotlin.String?, externalUrl: kotlin.String?, file: kotlin.String?, filetype: kotlin.String?, indexableFileContents: kotlin.String?, previewImage: kotlin.String?, title: kotlin.String?, token: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = filesRemoteUpdateRequestConfig(externalId = externalId, externalUrl = externalUrl, file = file, filetype = filetype, indexableFileContents = indexableFileContents, previewImage = previewImage, title = title, token = token)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation filesRemoteUpdate
     *
     * @param externalId Creator defined GUID for the file. (optional)
     * @param externalUrl URL of the remote file. (optional)
     * @param file Specify a file by providing its ID. (optional)
     * @param filetype type of file (optional)
     * @param indexableFileContents File containing contents that can be used to improve searchability for the remote file. (optional)
     * @param previewImage Preview of the document via &#x60;multipart/form-data&#x60;. (optional)
     * @param title Title of the file being shared. (optional)
     * @param token Authentication token. Requires scope: &#x60;remote_files:write&#x60; (optional)
     * @return RequestConfig
     */
    fun filesRemoteUpdateRequestConfig(externalId: kotlin.String?, externalUrl: kotlin.String?, file: kotlin.String?, filetype: kotlin.String?, indexableFileContents: kotlin.String?, previewImage: kotlin.String?, title: kotlin.String?, token: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "external_id" to PartConfig(body = externalId, headers = mutableMapOf()),
            "external_url" to PartConfig(body = externalUrl, headers = mutableMapOf()),
            "file" to PartConfig(body = file, headers = mutableMapOf()),
            "filetype" to PartConfig(body = filetype, headers = mutableMapOf()),
            "indexable_file_contents" to PartConfig(body = indexableFileContents, headers = mutableMapOf()),
            "preview_image" to PartConfig(body = previewImage, headers = mutableMapOf()),
            "title" to PartConfig(body = title, headers = mutableMapOf()),
            "token" to PartConfig(body = token, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/files.remote.update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
