/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package slack.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.outmatchapi.slack.AdminConversationsArchiveErrorSchema
import com.outmatchapi.slack.AdminConversationsArchiveSchema
import com.outmatchapi.slack.AdminConversationsConvertToPrivateErrorSchema
import com.outmatchapi.slack.AdminConversationsConvertToPrivateSchema
import com.outmatchapi.slack.AdminConversationsCreateErrorSchema
import com.outmatchapi.slack.AdminConversationsCreateSchema
import com.outmatchapi.slack.AdminConversationsDeleteErrorSchema
import com.outmatchapi.slack.AdminConversationsDeleteSchema
import com.outmatchapi.slack.AdminConversationsDisconnectSharedErrorSchema
import com.outmatchapi.slack.AdminConversationsGetConversationPrefsSchema
import com.outmatchapi.slack.AdminConversationsGetTeamsErrorSchema
import com.outmatchapi.slack.AdminConversationsGetTeamsSchema
import com.outmatchapi.slack.AdminConversationsInviteErrorSchema
import com.outmatchapi.slack.AdminConversationsInviteSchema
import com.outmatchapi.slack.AdminConversationsRenameSchema
import com.outmatchapi.slack.AdminConversationsRenameSchema1
import com.outmatchapi.slack.AdminConversationsSearchErrorSchema
import com.outmatchapi.slack.AdminConversationsSearchSchema
import com.outmatchapi.slack.AdminConversationsSetConversationPrefsErrorSchema
import com.outmatchapi.slack.AdminConversationsSetConversationPrefsSchema
import com.outmatchapi.slack.AdminConversationsUnarchiveErrorSchema
import com.outmatchapi.slack.AdminConversationsUnarchiveErrorSchema1
import com.outmatchapi.slack.AdminConversationsUnarchiveErrorSchema2
import com.outmatchapi.slack.AdminConversationsUnarchiveSchema
import com.outmatchapi.slack.AdminInviteRequestsApproveRequest
import com.outmatchapi.slack.DefaultErrorTemplate
import com.outmatchapi.slack.DefaultSuccessTemplate

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import slack.infrastructure.ApiClient
import slack.infrastructure.ApiResponse
import slack.infrastructure.ClientException
import slack.infrastructure.ClientError
import slack.infrastructure.ServerException
import slack.infrastructure.ServerError
import slack.infrastructure.MultiValueMap
import slack.infrastructure.PartConfig
import slack.infrastructure.RequestConfig
import slack.infrastructure.RequestMethod
import slack.infrastructure.ResponseType
import slack.infrastructure.Success
import slack.infrastructure.toMultiValue

class AdminApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://slack.com/api")
        }
    }

    /**
     * 
     * Approve an app for installation on a workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.apps:write&#x60;
     * @param appId The id of the app to approve. (optional)
     * @param requestId The id of the request to approve. (optional)
     * @param teamId  (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminAppsApprove(token: kotlin.String, appId: kotlin.String? = null, requestId: kotlin.String? = null, teamId: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminAppsApproveWithHttpInfo(token = token, appId = appId, requestId = requestId, teamId = teamId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Approve an app for installation on a workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.apps:write&#x60;
     * @param appId The id of the app to approve. (optional)
     * @param requestId The id of the request to approve. (optional)
     * @param teamId  (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminAppsApproveWithHttpInfo(token: kotlin.String, appId: kotlin.String?, requestId: kotlin.String?, teamId: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminAppsApproveRequestConfig(token = token, appId = appId, requestId = requestId, teamId = teamId)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminAppsApprove
     *
     * @param token Authentication token. Requires scope: &#x60;admin.apps:write&#x60;
     * @param appId The id of the app to approve. (optional)
     * @param requestId The id of the request to approve. (optional)
     * @param teamId  (optional)
     * @return RequestConfig
     */
    fun adminAppsApproveRequestConfig(token: kotlin.String, appId: kotlin.String?, requestId: kotlin.String?, teamId: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "app_id" to PartConfig(body = appId, headers = mutableMapOf()),
            "request_id" to PartConfig(body = requestId, headers = mutableMapOf()),
            "team_id" to PartConfig(body = teamId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.apps.approve",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * List approved apps for an org or workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.apps:read&#x60;
     * @param limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page (optional)
     * @param teamId  (optional)
     * @param enterpriseId  (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminAppsApprovedList(token: kotlin.String, limit: kotlin.Int? = null, cursor: kotlin.String? = null, teamId: kotlin.String? = null, enterpriseId: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminAppsApprovedListWithHttpInfo(token = token, limit = limit, cursor = cursor, teamId = teamId, enterpriseId = enterpriseId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * List approved apps for an org or workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.apps:read&#x60;
     * @param limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page (optional)
     * @param teamId  (optional)
     * @param enterpriseId  (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminAppsApprovedListWithHttpInfo(token: kotlin.String, limit: kotlin.Int?, cursor: kotlin.String?, teamId: kotlin.String?, enterpriseId: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminAppsApprovedListRequestConfig(token = token, limit = limit, cursor = cursor, teamId = teamId, enterpriseId = enterpriseId)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminAppsApprovedList
     *
     * @param token Authentication token. Requires scope: &#x60;admin.apps:read&#x60;
     * @param limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page (optional)
     * @param teamId  (optional)
     * @param enterpriseId  (optional)
     * @return RequestConfig
     */
    fun adminAppsApprovedListRequestConfig(token: kotlin.String, limit: kotlin.Int?, cursor: kotlin.String?, teamId: kotlin.String?, enterpriseId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (teamId != null) {
                    put("team_id", listOf(teamId.toString()))
                }
                if (enterpriseId != null) {
                    put("enterprise_id", listOf(enterpriseId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin.apps.approved.list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * List app requests for a team/workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.apps:read&#x60;
     * @param limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page (optional)
     * @param teamId  (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminAppsRequestsList(token: kotlin.String, limit: kotlin.Int? = null, cursor: kotlin.String? = null, teamId: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminAppsRequestsListWithHttpInfo(token = token, limit = limit, cursor = cursor, teamId = teamId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * List app requests for a team/workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.apps:read&#x60;
     * @param limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page (optional)
     * @param teamId  (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminAppsRequestsListWithHttpInfo(token: kotlin.String, limit: kotlin.Int?, cursor: kotlin.String?, teamId: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminAppsRequestsListRequestConfig(token = token, limit = limit, cursor = cursor, teamId = teamId)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminAppsRequestsList
     *
     * @param token Authentication token. Requires scope: &#x60;admin.apps:read&#x60;
     * @param limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page (optional)
     * @param teamId  (optional)
     * @return RequestConfig
     */
    fun adminAppsRequestsListRequestConfig(token: kotlin.String, limit: kotlin.Int?, cursor: kotlin.String?, teamId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (teamId != null) {
                    put("team_id", listOf(teamId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin.apps.requests.list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Restrict an app for installation on a workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.apps:write&#x60;
     * @param appId The id of the app to restrict. (optional)
     * @param requestId The id of the request to restrict. (optional)
     * @param teamId  (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminAppsRestrict(token: kotlin.String, appId: kotlin.String? = null, requestId: kotlin.String? = null, teamId: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminAppsRestrictWithHttpInfo(token = token, appId = appId, requestId = requestId, teamId = teamId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Restrict an app for installation on a workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.apps:write&#x60;
     * @param appId The id of the app to restrict. (optional)
     * @param requestId The id of the request to restrict. (optional)
     * @param teamId  (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminAppsRestrictWithHttpInfo(token: kotlin.String, appId: kotlin.String?, requestId: kotlin.String?, teamId: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminAppsRestrictRequestConfig(token = token, appId = appId, requestId = requestId, teamId = teamId)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminAppsRestrict
     *
     * @param token Authentication token. Requires scope: &#x60;admin.apps:write&#x60;
     * @param appId The id of the app to restrict. (optional)
     * @param requestId The id of the request to restrict. (optional)
     * @param teamId  (optional)
     * @return RequestConfig
     */
    fun adminAppsRestrictRequestConfig(token: kotlin.String, appId: kotlin.String?, requestId: kotlin.String?, teamId: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "app_id" to PartConfig(body = appId, headers = mutableMapOf()),
            "request_id" to PartConfig(body = requestId, headers = mutableMapOf()),
            "team_id" to PartConfig(body = teamId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.apps.restrict",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * List restricted apps for an org or workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.apps:read&#x60;
     * @param limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page (optional)
     * @param teamId  (optional)
     * @param enterpriseId  (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminAppsRestrictedList(token: kotlin.String, limit: kotlin.Int? = null, cursor: kotlin.String? = null, teamId: kotlin.String? = null, enterpriseId: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminAppsRestrictedListWithHttpInfo(token = token, limit = limit, cursor = cursor, teamId = teamId, enterpriseId = enterpriseId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * List restricted apps for an org or workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.apps:read&#x60;
     * @param limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page (optional)
     * @param teamId  (optional)
     * @param enterpriseId  (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminAppsRestrictedListWithHttpInfo(token: kotlin.String, limit: kotlin.Int?, cursor: kotlin.String?, teamId: kotlin.String?, enterpriseId: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminAppsRestrictedListRequestConfig(token = token, limit = limit, cursor = cursor, teamId = teamId, enterpriseId = enterpriseId)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminAppsRestrictedList
     *
     * @param token Authentication token. Requires scope: &#x60;admin.apps:read&#x60;
     * @param limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page (optional)
     * @param teamId  (optional)
     * @param enterpriseId  (optional)
     * @return RequestConfig
     */
    fun adminAppsRestrictedListRequestConfig(token: kotlin.String, limit: kotlin.Int?, cursor: kotlin.String?, teamId: kotlin.String?, enterpriseId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (teamId != null) {
                    put("team_id", listOf(teamId.toString()))
                }
                if (enterpriseId != null) {
                    put("enterprise_id", listOf(enterpriseId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin.apps.restricted.list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Archive a public or private channel.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel to archive.
     * @return AdminConversationsArchiveSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminConversationsArchive(token: kotlin.String, channelId: kotlin.String) : AdminConversationsArchiveSchema = withContext(Dispatchers.IO) {
        val localVarResponse = adminConversationsArchiveWithHttpInfo(token = token, channelId = channelId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AdminConversationsArchiveSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Archive a public or private channel.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel to archive.
     * @return ApiResponse<AdminConversationsArchiveSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminConversationsArchiveWithHttpInfo(token: kotlin.String, channelId: kotlin.String) : ApiResponse<AdminConversationsArchiveSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminConversationsArchiveRequestConfig(token = token, channelId = channelId)

        return@withContext request<Map<String, PartConfig<*>>, AdminConversationsArchiveSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminConversationsArchive
     *
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel to archive.
     * @return RequestConfig
     */
    fun adminConversationsArchiveRequestConfig(token: kotlin.String, channelId: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel_id" to PartConfig(body = channelId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.conversations.archive",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Convert a public channel to a private channel.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel to convert to private.
     * @return AdminConversationsConvertToPrivateSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminConversationsConvertToPrivate(token: kotlin.String, channelId: kotlin.String) : AdminConversationsConvertToPrivateSchema = withContext(Dispatchers.IO) {
        val localVarResponse = adminConversationsConvertToPrivateWithHttpInfo(token = token, channelId = channelId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AdminConversationsConvertToPrivateSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Convert a public channel to a private channel.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel to convert to private.
     * @return ApiResponse<AdminConversationsConvertToPrivateSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminConversationsConvertToPrivateWithHttpInfo(token: kotlin.String, channelId: kotlin.String) : ApiResponse<AdminConversationsConvertToPrivateSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminConversationsConvertToPrivateRequestConfig(token = token, channelId = channelId)

        return@withContext request<Map<String, PartConfig<*>>, AdminConversationsConvertToPrivateSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminConversationsConvertToPrivate
     *
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel to convert to private.
     * @return RequestConfig
     */
    fun adminConversationsConvertToPrivateRequestConfig(token: kotlin.String, channelId: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel_id" to PartConfig(body = channelId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.conversations.convertToPrivate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Create a public or private channel-based conversation.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param isPrivate When &#x60;true&#x60;, creates a private channel instead of a public channel
     * @param name Name of the public or private channel to create.
     * @param description Description of the public or private channel to create. (optional)
     * @param orgWide When &#x60;true&#x60;, the channel will be available org-wide. Note: if the channel is not &#x60;org_wide&#x3D;true&#x60;, you must specify a &#x60;team_id&#x60; for this channel (optional)
     * @param teamId The workspace to create the channel in. Note: this argument is required unless you set &#x60;org_wide&#x3D;true&#x60;. (optional)
     * @return AdminConversationsCreateSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminConversationsCreate(token: kotlin.String, isPrivate: kotlin.Boolean, name: kotlin.String, description: kotlin.String? = null, orgWide: kotlin.Boolean? = null, teamId: kotlin.String? = null) : AdminConversationsCreateSchema = withContext(Dispatchers.IO) {
        val localVarResponse = adminConversationsCreateWithHttpInfo(token = token, isPrivate = isPrivate, name = name, description = description, orgWide = orgWide, teamId = teamId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AdminConversationsCreateSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Create a public or private channel-based conversation.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param isPrivate When &#x60;true&#x60;, creates a private channel instead of a public channel
     * @param name Name of the public or private channel to create.
     * @param description Description of the public or private channel to create. (optional)
     * @param orgWide When &#x60;true&#x60;, the channel will be available org-wide. Note: if the channel is not &#x60;org_wide&#x3D;true&#x60;, you must specify a &#x60;team_id&#x60; for this channel (optional)
     * @param teamId The workspace to create the channel in. Note: this argument is required unless you set &#x60;org_wide&#x3D;true&#x60;. (optional)
     * @return ApiResponse<AdminConversationsCreateSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminConversationsCreateWithHttpInfo(token: kotlin.String, isPrivate: kotlin.Boolean, name: kotlin.String, description: kotlin.String?, orgWide: kotlin.Boolean?, teamId: kotlin.String?) : ApiResponse<AdminConversationsCreateSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminConversationsCreateRequestConfig(token = token, isPrivate = isPrivate, name = name, description = description, orgWide = orgWide, teamId = teamId)

        return@withContext request<Map<String, PartConfig<*>>, AdminConversationsCreateSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminConversationsCreate
     *
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param isPrivate When &#x60;true&#x60;, creates a private channel instead of a public channel
     * @param name Name of the public or private channel to create.
     * @param description Description of the public or private channel to create. (optional)
     * @param orgWide When &#x60;true&#x60;, the channel will be available org-wide. Note: if the channel is not &#x60;org_wide&#x3D;true&#x60;, you must specify a &#x60;team_id&#x60; for this channel (optional)
     * @param teamId The workspace to create the channel in. Note: this argument is required unless you set &#x60;org_wide&#x3D;true&#x60;. (optional)
     * @return RequestConfig
     */
    fun adminConversationsCreateRequestConfig(token: kotlin.String, isPrivate: kotlin.Boolean, name: kotlin.String, description: kotlin.String?, orgWide: kotlin.Boolean?, teamId: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "description" to PartConfig(body = description, headers = mutableMapOf()),
            "is_private" to PartConfig(body = isPrivate, headers = mutableMapOf()),
            "name" to PartConfig(body = name, headers = mutableMapOf()),
            "org_wide" to PartConfig(body = orgWide, headers = mutableMapOf()),
            "team_id" to PartConfig(body = teamId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.conversations.create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Delete a public or private channel.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel to delete.
     * @return AdminConversationsDeleteSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminConversationsDelete(token: kotlin.String, channelId: kotlin.String) : AdminConversationsDeleteSchema = withContext(Dispatchers.IO) {
        val localVarResponse = adminConversationsDeleteWithHttpInfo(token = token, channelId = channelId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AdminConversationsDeleteSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Delete a public or private channel.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel to delete.
     * @return ApiResponse<AdminConversationsDeleteSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminConversationsDeleteWithHttpInfo(token: kotlin.String, channelId: kotlin.String) : ApiResponse<AdminConversationsDeleteSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminConversationsDeleteRequestConfig(token = token, channelId = channelId)

        return@withContext request<Map<String, PartConfig<*>>, AdminConversationsDeleteSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminConversationsDelete
     *
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel to delete.
     * @return RequestConfig
     */
    fun adminConversationsDeleteRequestConfig(token: kotlin.String, channelId: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel_id" to PartConfig(body = channelId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.conversations.delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Disconnect a connected channel from one or more workspaces.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel to be disconnected from some workspaces.
     * @param leavingTeamIds The team to be removed from the channel. Currently only a single team id can be specified. (optional)
     * @return AdminConversationsRenameSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminConversationsDisconnectShared(token: kotlin.String, channelId: kotlin.String, leavingTeamIds: kotlin.String? = null) : AdminConversationsRenameSchema = withContext(Dispatchers.IO) {
        val localVarResponse = adminConversationsDisconnectSharedWithHttpInfo(token = token, channelId = channelId, leavingTeamIds = leavingTeamIds)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AdminConversationsRenameSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Disconnect a connected channel from one or more workspaces.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel to be disconnected from some workspaces.
     * @param leavingTeamIds The team to be removed from the channel. Currently only a single team id can be specified. (optional)
     * @return ApiResponse<AdminConversationsRenameSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminConversationsDisconnectSharedWithHttpInfo(token: kotlin.String, channelId: kotlin.String, leavingTeamIds: kotlin.String?) : ApiResponse<AdminConversationsRenameSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminConversationsDisconnectSharedRequestConfig(token = token, channelId = channelId, leavingTeamIds = leavingTeamIds)

        return@withContext request<Map<String, PartConfig<*>>, AdminConversationsRenameSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminConversationsDisconnectShared
     *
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel to be disconnected from some workspaces.
     * @param leavingTeamIds The team to be removed from the channel. Currently only a single team id can be specified. (optional)
     * @return RequestConfig
     */
    fun adminConversationsDisconnectSharedRequestConfig(token: kotlin.String, channelId: kotlin.String, leavingTeamIds: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel_id" to PartConfig(body = channelId, headers = mutableMapOf()),
            "leaving_team_ids" to PartConfig(body = leavingTeamIds, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.conversations.disconnectShared",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * List all disconnected channelsâ€”i.e., channels that were once connected to other workspaces and then disconnectedâ€”and the corresponding original channel IDs for key revocation with EKM.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
     * @param channelIds A comma-separated list of channels to filter to. (optional)
     * @param teamIds A comma-separated list of the workspaces to which the channels you would like returned belong. (optional)
     * @param limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminConversationsEkmListOriginalConnectedChannelInfo(token: kotlin.String, channelIds: kotlin.String? = null, teamIds: kotlin.String? = null, limit: kotlin.Int? = null, cursor: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminConversationsEkmListOriginalConnectedChannelInfoWithHttpInfo(token = token, channelIds = channelIds, teamIds = teamIds, limit = limit, cursor = cursor)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * List all disconnected channelsâ€”i.e., channels that were once connected to other workspaces and then disconnectedâ€”and the corresponding original channel IDs for key revocation with EKM.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
     * @param channelIds A comma-separated list of channels to filter to. (optional)
     * @param teamIds A comma-separated list of the workspaces to which the channels you would like returned belong. (optional)
     * @param limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminConversationsEkmListOriginalConnectedChannelInfoWithHttpInfo(token: kotlin.String, channelIds: kotlin.String?, teamIds: kotlin.String?, limit: kotlin.Int?, cursor: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminConversationsEkmListOriginalConnectedChannelInfoRequestConfig(token = token, channelIds = channelIds, teamIds = teamIds, limit = limit, cursor = cursor)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminConversationsEkmListOriginalConnectedChannelInfo
     *
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
     * @param channelIds A comma-separated list of channels to filter to. (optional)
     * @param teamIds A comma-separated list of the workspaces to which the channels you would like returned belong. (optional)
     * @param limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional)
     * @return RequestConfig
     */
    fun adminConversationsEkmListOriginalConnectedChannelInfoRequestConfig(token: kotlin.String, channelIds: kotlin.String?, teamIds: kotlin.String?, limit: kotlin.Int?, cursor: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
                if (channelIds != null) {
                    put("channel_ids", listOf(channelIds.toString()))
                }
                if (teamIds != null) {
                    put("team_ids", listOf(teamIds.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin.conversations.ekm.listOriginalConnectedChannelInfo",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get conversation preferences for a public or private channel.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
     * @param channelId The channel to get preferences for.
     * @return AdminConversationsGetConversationPrefsSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminConversationsGetConversationPrefs(token: kotlin.String, channelId: kotlin.String) : AdminConversationsGetConversationPrefsSchema = withContext(Dispatchers.IO) {
        val localVarResponse = adminConversationsGetConversationPrefsWithHttpInfo(token = token, channelId = channelId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AdminConversationsGetConversationPrefsSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get conversation preferences for a public or private channel.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
     * @param channelId The channel to get preferences for.
     * @return ApiResponse<AdminConversationsGetConversationPrefsSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminConversationsGetConversationPrefsWithHttpInfo(token: kotlin.String, channelId: kotlin.String) : ApiResponse<AdminConversationsGetConversationPrefsSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminConversationsGetConversationPrefsRequestConfig(token = token, channelId = channelId)

        return@withContext request<Unit, AdminConversationsGetConversationPrefsSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminConversationsGetConversationPrefs
     *
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
     * @param channelId The channel to get preferences for.
     * @return RequestConfig
     */
    fun adminConversationsGetConversationPrefsRequestConfig(token: kotlin.String, channelId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("channel_id", listOf(channelId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin.conversations.getConversationPrefs",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get all the workspaces a given public or private channel is connected to within this Enterprise org.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
     * @param channelId The channel to determine connected workspaces within the organization for.
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page (optional)
     * @param limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional)
     * @return AdminConversationsGetTeamsSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminConversationsGetTeams(token: kotlin.String, channelId: kotlin.String, cursor: kotlin.String? = null, limit: kotlin.Int? = null) : AdminConversationsGetTeamsSchema = withContext(Dispatchers.IO) {
        val localVarResponse = adminConversationsGetTeamsWithHttpInfo(token = token, channelId = channelId, cursor = cursor, limit = limit)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AdminConversationsGetTeamsSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all the workspaces a given public or private channel is connected to within this Enterprise org.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
     * @param channelId The channel to determine connected workspaces within the organization for.
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page (optional)
     * @param limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional)
     * @return ApiResponse<AdminConversationsGetTeamsSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminConversationsGetTeamsWithHttpInfo(token: kotlin.String, channelId: kotlin.String, cursor: kotlin.String?, limit: kotlin.Int?) : ApiResponse<AdminConversationsGetTeamsSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminConversationsGetTeamsRequestConfig(token = token, channelId = channelId, cursor = cursor, limit = limit)

        return@withContext request<Unit, AdminConversationsGetTeamsSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminConversationsGetTeams
     *
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
     * @param channelId The channel to determine connected workspaces within the organization for.
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page (optional)
     * @param limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional)
     * @return RequestConfig
     */
    fun adminConversationsGetTeamsRequestConfig(token: kotlin.String, channelId: kotlin.String, cursor: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("channel_id", listOf(channelId.toString()))
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin.conversations.getTeams",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Invite a user to a public or private channel.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel that the users will be invited to.
     * @param userIds The users to invite.
     * @return AdminConversationsInviteSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminConversationsInvite(token: kotlin.String, channelId: kotlin.String, userIds: kotlin.String) : AdminConversationsInviteSchema = withContext(Dispatchers.IO) {
        val localVarResponse = adminConversationsInviteWithHttpInfo(token = token, channelId = channelId, userIds = userIds)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AdminConversationsInviteSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Invite a user to a public or private channel.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel that the users will be invited to.
     * @param userIds The users to invite.
     * @return ApiResponse<AdminConversationsInviteSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminConversationsInviteWithHttpInfo(token: kotlin.String, channelId: kotlin.String, userIds: kotlin.String) : ApiResponse<AdminConversationsInviteSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminConversationsInviteRequestConfig(token = token, channelId = channelId, userIds = userIds)

        return@withContext request<Map<String, PartConfig<*>>, AdminConversationsInviteSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminConversationsInvite
     *
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel that the users will be invited to.
     * @param userIds The users to invite.
     * @return RequestConfig
     */
    fun adminConversationsInviteRequestConfig(token: kotlin.String, channelId: kotlin.String, userIds: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel_id" to PartConfig(body = channelId, headers = mutableMapOf()),
            "user_ids" to PartConfig(body = userIds, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.conversations.invite",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Rename a public or private channel.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel to rename.
     * @param name 
     * @return AdminConversationsRenameSchema1
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminConversationsRename(token: kotlin.String, channelId: kotlin.String, name: kotlin.String) : AdminConversationsRenameSchema1 = withContext(Dispatchers.IO) {
        val localVarResponse = adminConversationsRenameWithHttpInfo(token = token, channelId = channelId, name = name)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AdminConversationsRenameSchema1
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Rename a public or private channel.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel to rename.
     * @param name 
     * @return ApiResponse<AdminConversationsRenameSchema1?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminConversationsRenameWithHttpInfo(token: kotlin.String, channelId: kotlin.String, name: kotlin.String) : ApiResponse<AdminConversationsRenameSchema1?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminConversationsRenameRequestConfig(token = token, channelId = channelId, name = name)

        return@withContext request<Map<String, PartConfig<*>>, AdminConversationsRenameSchema1>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminConversationsRename
     *
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel to rename.
     * @param name 
     * @return RequestConfig
     */
    fun adminConversationsRenameRequestConfig(token: kotlin.String, channelId: kotlin.String, name: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel_id" to PartConfig(body = channelId, headers = mutableMapOf()),
            "name" to PartConfig(body = name, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.conversations.rename",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Add an allowlist of IDP groups for accessing a channel
     * @param channelId The channel to link this group to.
     * @param groupId The [IDP Group](https://slack.com/help/articles/115001435788-Connect-identity-provider-groups-to-your-Enterprise-Grid-org) ID to be an allowlist for the private channel.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param teamId The workspace where the channel exists. This argument is required for channels only tied to one workspace, and optional for channels that are shared across an organization. (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminConversationsRestrictAccessAddGroup(channelId: kotlin.String, groupId: kotlin.String, token: kotlin.String, teamId: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminConversationsRestrictAccessAddGroupWithHttpInfo(channelId = channelId, groupId = groupId, token = token, teamId = teamId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Add an allowlist of IDP groups for accessing a channel
     * @param channelId The channel to link this group to.
     * @param groupId The [IDP Group](https://slack.com/help/articles/115001435788-Connect-identity-provider-groups-to-your-Enterprise-Grid-org) ID to be an allowlist for the private channel.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param teamId The workspace where the channel exists. This argument is required for channels only tied to one workspace, and optional for channels that are shared across an organization. (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminConversationsRestrictAccessAddGroupWithHttpInfo(channelId: kotlin.String, groupId: kotlin.String, token: kotlin.String, teamId: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminConversationsRestrictAccessAddGroupRequestConfig(channelId = channelId, groupId = groupId, token = token, teamId = teamId)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminConversationsRestrictAccessAddGroup
     *
     * @param channelId The channel to link this group to.
     * @param groupId The [IDP Group](https://slack.com/help/articles/115001435788-Connect-identity-provider-groups-to-your-Enterprise-Grid-org) ID to be an allowlist for the private channel.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param teamId The workspace where the channel exists. This argument is required for channels only tied to one workspace, and optional for channels that are shared across an organization. (optional)
     * @return RequestConfig
     */
    fun adminConversationsRestrictAccessAddGroupRequestConfig(channelId: kotlin.String, groupId: kotlin.String, token: kotlin.String, teamId: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel_id" to PartConfig(body = channelId, headers = mutableMapOf()),
            "group_id" to PartConfig(body = groupId, headers = mutableMapOf()),
            "team_id" to PartConfig(body = teamId, headers = mutableMapOf()),
            "token" to PartConfig(body = token, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.conversations.restrictAccess.addGroup",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * List all IDP Groups linked to a channel
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
     * @param channelId 
     * @param teamId The workspace where the channel exists. This argument is required for channels only tied to one workspace, and optional for channels that are shared across an organization. (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminConversationsRestrictAccessListGroups(token: kotlin.String, channelId: kotlin.String, teamId: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminConversationsRestrictAccessListGroupsWithHttpInfo(token = token, channelId = channelId, teamId = teamId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * List all IDP Groups linked to a channel
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
     * @param channelId 
     * @param teamId The workspace where the channel exists. This argument is required for channels only tied to one workspace, and optional for channels that are shared across an organization. (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminConversationsRestrictAccessListGroupsWithHttpInfo(token: kotlin.String, channelId: kotlin.String, teamId: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminConversationsRestrictAccessListGroupsRequestConfig(token = token, channelId = channelId, teamId = teamId)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminConversationsRestrictAccessListGroups
     *
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
     * @param channelId 
     * @param teamId The workspace where the channel exists. This argument is required for channels only tied to one workspace, and optional for channels that are shared across an organization. (optional)
     * @return RequestConfig
     */
    fun adminConversationsRestrictAccessListGroupsRequestConfig(token: kotlin.String, channelId: kotlin.String, teamId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
                put("channel_id", listOf(channelId.toString()))
                if (teamId != null) {
                    put("team_id", listOf(teamId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin.conversations.restrictAccess.listGroups",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Remove a linked IDP group linked from a private channel
     * @param channelId The channel to remove the linked group from.
     * @param groupId The [IDP Group](https://slack.com/help/articles/115001435788-Connect-identity-provider-groups-to-your-Enterprise-Grid-org) ID to remove from the private channel.
     * @param teamId The workspace where the channel exists. This argument is required for channels only tied to one workspace, and optional for channels that are shared across an organization.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminConversationsRestrictAccessRemoveGroup(channelId: kotlin.String, groupId: kotlin.String, teamId: kotlin.String, token: kotlin.String) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminConversationsRestrictAccessRemoveGroupWithHttpInfo(channelId = channelId, groupId = groupId, teamId = teamId, token = token)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Remove a linked IDP group linked from a private channel
     * @param channelId The channel to remove the linked group from.
     * @param groupId The [IDP Group](https://slack.com/help/articles/115001435788-Connect-identity-provider-groups-to-your-Enterprise-Grid-org) ID to remove from the private channel.
     * @param teamId The workspace where the channel exists. This argument is required for channels only tied to one workspace, and optional for channels that are shared across an organization.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminConversationsRestrictAccessRemoveGroupWithHttpInfo(channelId: kotlin.String, groupId: kotlin.String, teamId: kotlin.String, token: kotlin.String) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminConversationsRestrictAccessRemoveGroupRequestConfig(channelId = channelId, groupId = groupId, teamId = teamId, token = token)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminConversationsRestrictAccessRemoveGroup
     *
     * @param channelId The channel to remove the linked group from.
     * @param groupId The [IDP Group](https://slack.com/help/articles/115001435788-Connect-identity-provider-groups-to-your-Enterprise-Grid-org) ID to remove from the private channel.
     * @param teamId The workspace where the channel exists. This argument is required for channels only tied to one workspace, and optional for channels that are shared across an organization.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @return RequestConfig
     */
    fun adminConversationsRestrictAccessRemoveGroupRequestConfig(channelId: kotlin.String, groupId: kotlin.String, teamId: kotlin.String, token: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel_id" to PartConfig(body = channelId, headers = mutableMapOf()),
            "group_id" to PartConfig(body = groupId, headers = mutableMapOf()),
            "team_id" to PartConfig(body = teamId, headers = mutableMapOf()),
            "token" to PartConfig(body = token, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.conversations.restrictAccess.removeGroup",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Search for public or private channels in an Enterprise organization.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
     * @param teamIds Comma separated string of team IDs, signifying the workspaces to search through. (optional)
     * @param query Name of the the channel to query by. (optional)
     * @param limit Maximum number of items to be returned. Must be between 1 - 20 both inclusive. Default is 10. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional)
     * @param searchChannelTypes The type of channel to include or exclude in the search. For example &#x60;private&#x60; will search private channels, while &#x60;private_exclude&#x60; will exclude them. For a full list of types, check the [Types section](#types). (optional)
     * @param sort Possible values are &#x60;relevant&#x60; (search ranking based on what we think is closest), &#x60;name&#x60; (alphabetical), &#x60;member_count&#x60; (number of users in the channel), and &#x60;created&#x60; (date channel was created). You can optionally pair this with the &#x60;sort_dir&#x60; arg to change how it is sorted  (optional)
     * @param sortDir Sort direction. Possible values are &#x60;asc&#x60; for ascending order like (1, 2, 3) or (a, b, c), and &#x60;desc&#x60; for descending order like (3, 2, 1) or (c, b, a) (optional)
     * @return AdminConversationsSearchSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminConversationsSearch(token: kotlin.String, teamIds: kotlin.String? = null, query: kotlin.String? = null, limit: kotlin.Int? = null, cursor: kotlin.String? = null, searchChannelTypes: kotlin.String? = null, sort: kotlin.String? = null, sortDir: kotlin.String? = null) : AdminConversationsSearchSchema = withContext(Dispatchers.IO) {
        val localVarResponse = adminConversationsSearchWithHttpInfo(token = token, teamIds = teamIds, query = query, limit = limit, cursor = cursor, searchChannelTypes = searchChannelTypes, sort = sort, sortDir = sortDir)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AdminConversationsSearchSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Search for public or private channels in an Enterprise organization.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
     * @param teamIds Comma separated string of team IDs, signifying the workspaces to search through. (optional)
     * @param query Name of the the channel to query by. (optional)
     * @param limit Maximum number of items to be returned. Must be between 1 - 20 both inclusive. Default is 10. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional)
     * @param searchChannelTypes The type of channel to include or exclude in the search. For example &#x60;private&#x60; will search private channels, while &#x60;private_exclude&#x60; will exclude them. For a full list of types, check the [Types section](#types). (optional)
     * @param sort Possible values are &#x60;relevant&#x60; (search ranking based on what we think is closest), &#x60;name&#x60; (alphabetical), &#x60;member_count&#x60; (number of users in the channel), and &#x60;created&#x60; (date channel was created). You can optionally pair this with the &#x60;sort_dir&#x60; arg to change how it is sorted  (optional)
     * @param sortDir Sort direction. Possible values are &#x60;asc&#x60; for ascending order like (1, 2, 3) or (a, b, c), and &#x60;desc&#x60; for descending order like (3, 2, 1) or (c, b, a) (optional)
     * @return ApiResponse<AdminConversationsSearchSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminConversationsSearchWithHttpInfo(token: kotlin.String, teamIds: kotlin.String?, query: kotlin.String?, limit: kotlin.Int?, cursor: kotlin.String?, searchChannelTypes: kotlin.String?, sort: kotlin.String?, sortDir: kotlin.String?) : ApiResponse<AdminConversationsSearchSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminConversationsSearchRequestConfig(token = token, teamIds = teamIds, query = query, limit = limit, cursor = cursor, searchChannelTypes = searchChannelTypes, sort = sort, sortDir = sortDir)

        return@withContext request<Unit, AdminConversationsSearchSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminConversationsSearch
     *
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
     * @param teamIds Comma separated string of team IDs, signifying the workspaces to search through. (optional)
     * @param query Name of the the channel to query by. (optional)
     * @param limit Maximum number of items to be returned. Must be between 1 - 20 both inclusive. Default is 10. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional)
     * @param searchChannelTypes The type of channel to include or exclude in the search. For example &#x60;private&#x60; will search private channels, while &#x60;private_exclude&#x60; will exclude them. For a full list of types, check the [Types section](#types). (optional)
     * @param sort Possible values are &#x60;relevant&#x60; (search ranking based on what we think is closest), &#x60;name&#x60; (alphabetical), &#x60;member_count&#x60; (number of users in the channel), and &#x60;created&#x60; (date channel was created). You can optionally pair this with the &#x60;sort_dir&#x60; arg to change how it is sorted  (optional)
     * @param sortDir Sort direction. Possible values are &#x60;asc&#x60; for ascending order like (1, 2, 3) or (a, b, c), and &#x60;desc&#x60; for descending order like (3, 2, 1) or (c, b, a) (optional)
     * @return RequestConfig
     */
    fun adminConversationsSearchRequestConfig(token: kotlin.String, teamIds: kotlin.String?, query: kotlin.String?, limit: kotlin.Int?, cursor: kotlin.String?, searchChannelTypes: kotlin.String?, sort: kotlin.String?, sortDir: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (teamIds != null) {
                    put("team_ids", listOf(teamIds.toString()))
                }
                if (query != null) {
                    put("query", listOf(query.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (searchChannelTypes != null) {
                    put("search_channel_types", listOf(searchChannelTypes.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (sortDir != null) {
                    put("sort_dir", listOf(sortDir.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin.conversations.search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Set the posting permissions for a public or private channel.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel to set the prefs for
     * @param prefs The prefs for this channel in a stringified JSON format.
     * @return AdminConversationsSetConversationPrefsSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminConversationsSetConversationPrefs(token: kotlin.String, channelId: kotlin.String, prefs: kotlin.String) : AdminConversationsSetConversationPrefsSchema = withContext(Dispatchers.IO) {
        val localVarResponse = adminConversationsSetConversationPrefsWithHttpInfo(token = token, channelId = channelId, prefs = prefs)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AdminConversationsSetConversationPrefsSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Set the posting permissions for a public or private channel.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel to set the prefs for
     * @param prefs The prefs for this channel in a stringified JSON format.
     * @return ApiResponse<AdminConversationsSetConversationPrefsSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminConversationsSetConversationPrefsWithHttpInfo(token: kotlin.String, channelId: kotlin.String, prefs: kotlin.String) : ApiResponse<AdminConversationsSetConversationPrefsSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminConversationsSetConversationPrefsRequestConfig(token = token, channelId = channelId, prefs = prefs)

        return@withContext request<Map<String, PartConfig<*>>, AdminConversationsSetConversationPrefsSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminConversationsSetConversationPrefs
     *
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel to set the prefs for
     * @param prefs The prefs for this channel in a stringified JSON format.
     * @return RequestConfig
     */
    fun adminConversationsSetConversationPrefsRequestConfig(token: kotlin.String, channelId: kotlin.String, prefs: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel_id" to PartConfig(body = channelId, headers = mutableMapOf()),
            "prefs" to PartConfig(body = prefs, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.conversations.setConversationPrefs",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Set the workspaces in an Enterprise grid org that connect to a public or private channel.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The encoded &#x60;channel_id&#x60; to add or remove to workspaces.
     * @param orgChannel True if channel has to be converted to an org channel (optional)
     * @param targetTeamIds A comma-separated list of workspaces to which the channel should be shared. Not required if the channel is being shared org-wide. (optional)
     * @param teamId The workspace to which the channel belongs. Omit this argument if the channel is a cross-workspace shared channel. (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminConversationsSetTeams(token: kotlin.String, channelId: kotlin.String, orgChannel: kotlin.Boolean? = null, targetTeamIds: kotlin.String? = null, teamId: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminConversationsSetTeamsWithHttpInfo(token = token, channelId = channelId, orgChannel = orgChannel, targetTeamIds = targetTeamIds, teamId = teamId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Set the workspaces in an Enterprise grid org that connect to a public or private channel.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The encoded &#x60;channel_id&#x60; to add or remove to workspaces.
     * @param orgChannel True if channel has to be converted to an org channel (optional)
     * @param targetTeamIds A comma-separated list of workspaces to which the channel should be shared. Not required if the channel is being shared org-wide. (optional)
     * @param teamId The workspace to which the channel belongs. Omit this argument if the channel is a cross-workspace shared channel. (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminConversationsSetTeamsWithHttpInfo(token: kotlin.String, channelId: kotlin.String, orgChannel: kotlin.Boolean?, targetTeamIds: kotlin.String?, teamId: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminConversationsSetTeamsRequestConfig(token = token, channelId = channelId, orgChannel = orgChannel, targetTeamIds = targetTeamIds, teamId = teamId)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminConversationsSetTeams
     *
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The encoded &#x60;channel_id&#x60; to add or remove to workspaces.
     * @param orgChannel True if channel has to be converted to an org channel (optional)
     * @param targetTeamIds A comma-separated list of workspaces to which the channel should be shared. Not required if the channel is being shared org-wide. (optional)
     * @param teamId The workspace to which the channel belongs. Omit this argument if the channel is a cross-workspace shared channel. (optional)
     * @return RequestConfig
     */
    fun adminConversationsSetTeamsRequestConfig(token: kotlin.String, channelId: kotlin.String, orgChannel: kotlin.Boolean?, targetTeamIds: kotlin.String?, teamId: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel_id" to PartConfig(body = channelId, headers = mutableMapOf()),
            "org_channel" to PartConfig(body = orgChannel, headers = mutableMapOf()),
            "target_team_ids" to PartConfig(body = targetTeamIds, headers = mutableMapOf()),
            "team_id" to PartConfig(body = teamId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.conversations.setTeams",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Unarchive a public or private channel.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel to unarchive.
     * @return AdminConversationsUnarchiveSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminConversationsUnarchive(token: kotlin.String, channelId: kotlin.String) : AdminConversationsUnarchiveSchema = withContext(Dispatchers.IO) {
        val localVarResponse = adminConversationsUnarchiveWithHttpInfo(token = token, channelId = channelId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AdminConversationsUnarchiveSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Unarchive a public or private channel.
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel to unarchive.
     * @return ApiResponse<AdminConversationsUnarchiveSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminConversationsUnarchiveWithHttpInfo(token: kotlin.String, channelId: kotlin.String) : ApiResponse<AdminConversationsUnarchiveSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminConversationsUnarchiveRequestConfig(token = token, channelId = channelId)

        return@withContext request<Map<String, PartConfig<*>>, AdminConversationsUnarchiveSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminConversationsUnarchive
     *
     * @param token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
     * @param channelId The channel to unarchive.
     * @return RequestConfig
     */
    fun adminConversationsUnarchiveRequestConfig(token: kotlin.String, channelId: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel_id" to PartConfig(body = channelId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.conversations.unarchive",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Add an emoji.
     * @param name The name of the emoji to be removed. Colons (&#x60;:myemoji:&#x60;) around the value are not required, although they may be included.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @param url The URL of a file to use as an image for the emoji. Square images under 128KB and with transparent backgrounds work best.
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminEmojiAdd(name: kotlin.String, token: kotlin.String, url: kotlin.String) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminEmojiAddWithHttpInfo(name = name, token = token, url = url)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Add an emoji.
     * @param name The name of the emoji to be removed. Colons (&#x60;:myemoji:&#x60;) around the value are not required, although they may be included.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @param url The URL of a file to use as an image for the emoji. Square images under 128KB and with transparent backgrounds work best.
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminEmojiAddWithHttpInfo(name: kotlin.String, token: kotlin.String, url: kotlin.String) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminEmojiAddRequestConfig(name = name, token = token, url = url)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminEmojiAdd
     *
     * @param name The name of the emoji to be removed. Colons (&#x60;:myemoji:&#x60;) around the value are not required, although they may be included.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @param url The URL of a file to use as an image for the emoji. Square images under 128KB and with transparent backgrounds work best.
     * @return RequestConfig
     */
    fun adminEmojiAddRequestConfig(name: kotlin.String, token: kotlin.String, url: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "name" to PartConfig(body = name, headers = mutableMapOf()),
            "token" to PartConfig(body = token, headers = mutableMapOf()),
            "url" to PartConfig(body = url, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.emoji.add",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Add an emoji alias.
     * @param aliasFor The alias of the emoji.
     * @param name The name of the emoji to be aliased. Colons (&#x60;:myemoji:&#x60;) around the value are not required, although they may be included.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminEmojiAddAlias(aliasFor: kotlin.String, name: kotlin.String, token: kotlin.String) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminEmojiAddAliasWithHttpInfo(aliasFor = aliasFor, name = name, token = token)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Add an emoji alias.
     * @param aliasFor The alias of the emoji.
     * @param name The name of the emoji to be aliased. Colons (&#x60;:myemoji:&#x60;) around the value are not required, although they may be included.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminEmojiAddAliasWithHttpInfo(aliasFor: kotlin.String, name: kotlin.String, token: kotlin.String) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminEmojiAddAliasRequestConfig(aliasFor = aliasFor, name = name, token = token)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminEmojiAddAlias
     *
     * @param aliasFor The alias of the emoji.
     * @param name The name of the emoji to be aliased. Colons (&#x60;:myemoji:&#x60;) around the value are not required, although they may be included.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @return RequestConfig
     */
    fun adminEmojiAddAliasRequestConfig(aliasFor: kotlin.String, name: kotlin.String, token: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "alias_for" to PartConfig(body = aliasFor, headers = mutableMapOf()),
            "name" to PartConfig(body = name, headers = mutableMapOf()),
            "token" to PartConfig(body = token, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.emoji.addAlias",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * List emoji for an Enterprise Grid organization.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:read&#x60;
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page (optional)
     * @param limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminEmojiList(token: kotlin.String, cursor: kotlin.String? = null, limit: kotlin.Int? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminEmojiListWithHttpInfo(token = token, cursor = cursor, limit = limit)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * List emoji for an Enterprise Grid organization.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:read&#x60;
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page (optional)
     * @param limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminEmojiListWithHttpInfo(token: kotlin.String, cursor: kotlin.String?, limit: kotlin.Int?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminEmojiListRequestConfig(token = token, cursor = cursor, limit = limit)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminEmojiList
     *
     * @param token Authentication token. Requires scope: &#x60;admin.teams:read&#x60;
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page (optional)
     * @param limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional)
     * @return RequestConfig
     */
    fun adminEmojiListRequestConfig(token: kotlin.String, cursor: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin.emoji.list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Remove an emoji across an Enterprise Grid organization
     * @param name The name of the emoji to be removed. Colons (&#x60;:myemoji:&#x60;) around the value are not required, although they may be included.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminEmojiRemove(name: kotlin.String, token: kotlin.String) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminEmojiRemoveWithHttpInfo(name = name, token = token)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Remove an emoji across an Enterprise Grid organization
     * @param name The name of the emoji to be removed. Colons (&#x60;:myemoji:&#x60;) around the value are not required, although they may be included.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminEmojiRemoveWithHttpInfo(name: kotlin.String, token: kotlin.String) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminEmojiRemoveRequestConfig(name = name, token = token)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminEmojiRemove
     *
     * @param name The name of the emoji to be removed. Colons (&#x60;:myemoji:&#x60;) around the value are not required, although they may be included.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @return RequestConfig
     */
    fun adminEmojiRemoveRequestConfig(name: kotlin.String, token: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "name" to PartConfig(body = name, headers = mutableMapOf()),
            "token" to PartConfig(body = token, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.emoji.remove",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Rename an emoji.
     * @param name The name of the emoji to be renamed. Colons (&#x60;:myemoji:&#x60;) around the value are not required, although they may be included.
     * @param newName The new name of the emoji.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminEmojiRename(name: kotlin.String, newName: kotlin.String, token: kotlin.String) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminEmojiRenameWithHttpInfo(name = name, newName = newName, token = token)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Rename an emoji.
     * @param name The name of the emoji to be renamed. Colons (&#x60;:myemoji:&#x60;) around the value are not required, although they may be included.
     * @param newName The new name of the emoji.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminEmojiRenameWithHttpInfo(name: kotlin.String, newName: kotlin.String, token: kotlin.String) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminEmojiRenameRequestConfig(name = name, newName = newName, token = token)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminEmojiRename
     *
     * @param name The name of the emoji to be renamed. Colons (&#x60;:myemoji:&#x60;) around the value are not required, although they may be included.
     * @param newName The new name of the emoji.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @return RequestConfig
     */
    fun adminEmojiRenameRequestConfig(name: kotlin.String, newName: kotlin.String, token: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "name" to PartConfig(body = name, headers = mutableMapOf()),
            "new_name" to PartConfig(body = newName, headers = mutableMapOf()),
            "token" to PartConfig(body = token, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.emoji.rename",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Approve a workspace invite request.
     * @param token Authentication token. Requires scope: &#x60;admin.invites:write&#x60;
     * @param adminInviteRequestsApproveRequest  (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminInviteRequestsApprove(token: kotlin.String, adminInviteRequestsApproveRequest: AdminInviteRequestsApproveRequest? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminInviteRequestsApproveWithHttpInfo(token = token, adminInviteRequestsApproveRequest = adminInviteRequestsApproveRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Approve a workspace invite request.
     * @param token Authentication token. Requires scope: &#x60;admin.invites:write&#x60;
     * @param adminInviteRequestsApproveRequest  (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminInviteRequestsApproveWithHttpInfo(token: kotlin.String, adminInviteRequestsApproveRequest: AdminInviteRequestsApproveRequest?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminInviteRequestsApproveRequestConfig(token = token, adminInviteRequestsApproveRequest = adminInviteRequestsApproveRequest)

        return@withContext request<AdminInviteRequestsApproveRequest, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminInviteRequestsApprove
     *
     * @param token Authentication token. Requires scope: &#x60;admin.invites:write&#x60;
     * @param adminInviteRequestsApproveRequest  (optional)
     * @return RequestConfig
     */
    fun adminInviteRequestsApproveRequestConfig(token: kotlin.String, adminInviteRequestsApproveRequest: AdminInviteRequestsApproveRequest?) : RequestConfig<AdminInviteRequestsApproveRequest> {
        val localVariableBody = adminInviteRequestsApproveRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/x-www-form-urlencoded"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.inviteRequests.approve",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * List all approved workspace invite requests.
     * @param token Authentication token. Requires scope: &#x60;admin.invites:read&#x60;
     * @param teamId ID for the workspace where the invite requests were made. (optional)
     * @param cursor Value of the &#x60;next_cursor&#x60; field sent as part of the previous API response (optional)
     * @param limit The number of results that will be returned by the API on each invocation. Must be between 1 - 1000, both inclusive (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminInviteRequestsApprovedList(token: kotlin.String, teamId: kotlin.String? = null, cursor: kotlin.String? = null, limit: kotlin.Int? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminInviteRequestsApprovedListWithHttpInfo(token = token, teamId = teamId, cursor = cursor, limit = limit)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * List all approved workspace invite requests.
     * @param token Authentication token. Requires scope: &#x60;admin.invites:read&#x60;
     * @param teamId ID for the workspace where the invite requests were made. (optional)
     * @param cursor Value of the &#x60;next_cursor&#x60; field sent as part of the previous API response (optional)
     * @param limit The number of results that will be returned by the API on each invocation. Must be between 1 - 1000, both inclusive (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminInviteRequestsApprovedListWithHttpInfo(token: kotlin.String, teamId: kotlin.String?, cursor: kotlin.String?, limit: kotlin.Int?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminInviteRequestsApprovedListRequestConfig(token = token, teamId = teamId, cursor = cursor, limit = limit)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminInviteRequestsApprovedList
     *
     * @param token Authentication token. Requires scope: &#x60;admin.invites:read&#x60;
     * @param teamId ID for the workspace where the invite requests were made. (optional)
     * @param cursor Value of the &#x60;next_cursor&#x60; field sent as part of the previous API response (optional)
     * @param limit The number of results that will be returned by the API on each invocation. Must be between 1 - 1000, both inclusive (optional)
     * @return RequestConfig
     */
    fun adminInviteRequestsApprovedListRequestConfig(token: kotlin.String, teamId: kotlin.String?, cursor: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (teamId != null) {
                    put("team_id", listOf(teamId.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin.inviteRequests.approved.list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * List all denied workspace invite requests.
     * @param token Authentication token. Requires scope: &#x60;admin.invites:read&#x60;
     * @param teamId ID for the workspace where the invite requests were made. (optional)
     * @param cursor Value of the &#x60;next_cursor&#x60; field sent as part of the previous api response (optional)
     * @param limit The number of results that will be returned by the API on each invocation. Must be between 1 - 1000 both inclusive (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminInviteRequestsDeniedList(token: kotlin.String, teamId: kotlin.String? = null, cursor: kotlin.String? = null, limit: kotlin.Int? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminInviteRequestsDeniedListWithHttpInfo(token = token, teamId = teamId, cursor = cursor, limit = limit)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * List all denied workspace invite requests.
     * @param token Authentication token. Requires scope: &#x60;admin.invites:read&#x60;
     * @param teamId ID for the workspace where the invite requests were made. (optional)
     * @param cursor Value of the &#x60;next_cursor&#x60; field sent as part of the previous api response (optional)
     * @param limit The number of results that will be returned by the API on each invocation. Must be between 1 - 1000 both inclusive (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminInviteRequestsDeniedListWithHttpInfo(token: kotlin.String, teamId: kotlin.String?, cursor: kotlin.String?, limit: kotlin.Int?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminInviteRequestsDeniedListRequestConfig(token = token, teamId = teamId, cursor = cursor, limit = limit)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminInviteRequestsDeniedList
     *
     * @param token Authentication token. Requires scope: &#x60;admin.invites:read&#x60;
     * @param teamId ID for the workspace where the invite requests were made. (optional)
     * @param cursor Value of the &#x60;next_cursor&#x60; field sent as part of the previous api response (optional)
     * @param limit The number of results that will be returned by the API on each invocation. Must be between 1 - 1000 both inclusive (optional)
     * @return RequestConfig
     */
    fun adminInviteRequestsDeniedListRequestConfig(token: kotlin.String, teamId: kotlin.String?, cursor: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (teamId != null) {
                    put("team_id", listOf(teamId.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin.inviteRequests.denied.list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Deny a workspace invite request.
     * @param token Authentication token. Requires scope: &#x60;admin.invites:write&#x60;
     * @param adminInviteRequestsApproveRequest  (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminInviteRequestsDeny(token: kotlin.String, adminInviteRequestsApproveRequest: AdminInviteRequestsApproveRequest? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminInviteRequestsDenyWithHttpInfo(token = token, adminInviteRequestsApproveRequest = adminInviteRequestsApproveRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Deny a workspace invite request.
     * @param token Authentication token. Requires scope: &#x60;admin.invites:write&#x60;
     * @param adminInviteRequestsApproveRequest  (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminInviteRequestsDenyWithHttpInfo(token: kotlin.String, adminInviteRequestsApproveRequest: AdminInviteRequestsApproveRequest?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminInviteRequestsDenyRequestConfig(token = token, adminInviteRequestsApproveRequest = adminInviteRequestsApproveRequest)

        return@withContext request<AdminInviteRequestsApproveRequest, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminInviteRequestsDeny
     *
     * @param token Authentication token. Requires scope: &#x60;admin.invites:write&#x60;
     * @param adminInviteRequestsApproveRequest  (optional)
     * @return RequestConfig
     */
    fun adminInviteRequestsDenyRequestConfig(token: kotlin.String, adminInviteRequestsApproveRequest: AdminInviteRequestsApproveRequest?) : RequestConfig<AdminInviteRequestsApproveRequest> {
        val localVariableBody = adminInviteRequestsApproveRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/x-www-form-urlencoded"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.inviteRequests.deny",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * List all pending workspace invite requests.
     * @param token Authentication token. Requires scope: &#x60;admin.invites:read&#x60;
     * @param teamId ID for the workspace where the invite requests were made. (optional)
     * @param cursor Value of the &#x60;next_cursor&#x60; field sent as part of the previous API response (optional)
     * @param limit The number of results that will be returned by the API on each invocation. Must be between 1 - 1000, both inclusive (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminInviteRequestsList(token: kotlin.String, teamId: kotlin.String? = null, cursor: kotlin.String? = null, limit: kotlin.Int? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminInviteRequestsListWithHttpInfo(token = token, teamId = teamId, cursor = cursor, limit = limit)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * List all pending workspace invite requests.
     * @param token Authentication token. Requires scope: &#x60;admin.invites:read&#x60;
     * @param teamId ID for the workspace where the invite requests were made. (optional)
     * @param cursor Value of the &#x60;next_cursor&#x60; field sent as part of the previous API response (optional)
     * @param limit The number of results that will be returned by the API on each invocation. Must be between 1 - 1000, both inclusive (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminInviteRequestsListWithHttpInfo(token: kotlin.String, teamId: kotlin.String?, cursor: kotlin.String?, limit: kotlin.Int?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminInviteRequestsListRequestConfig(token = token, teamId = teamId, cursor = cursor, limit = limit)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminInviteRequestsList
     *
     * @param token Authentication token. Requires scope: &#x60;admin.invites:read&#x60;
     * @param teamId ID for the workspace where the invite requests were made. (optional)
     * @param cursor Value of the &#x60;next_cursor&#x60; field sent as part of the previous API response (optional)
     * @param limit The number of results that will be returned by the API on each invocation. Must be between 1 - 1000, both inclusive (optional)
     * @return RequestConfig
     */
    fun adminInviteRequestsListRequestConfig(token: kotlin.String, teamId: kotlin.String?, cursor: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (teamId != null) {
                    put("team_id", listOf(teamId.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin.inviteRequests.list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * List all of the admins on a given workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:read&#x60;
     * @param teamId 
     * @param limit The maximum number of items to return. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminTeamsAdminsList(token: kotlin.String, teamId: kotlin.String, limit: kotlin.Int? = null, cursor: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminTeamsAdminsListWithHttpInfo(token = token, teamId = teamId, limit = limit, cursor = cursor)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * List all of the admins on a given workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:read&#x60;
     * @param teamId 
     * @param limit The maximum number of items to return. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminTeamsAdminsListWithHttpInfo(token: kotlin.String, teamId: kotlin.String, limit: kotlin.Int?, cursor: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminTeamsAdminsListRequestConfig(token = token, teamId = teamId, limit = limit, cursor = cursor)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminTeamsAdminsList
     *
     * @param token Authentication token. Requires scope: &#x60;admin.teams:read&#x60;
     * @param teamId 
     * @param limit The maximum number of items to return. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional)
     * @return RequestConfig
     */
    fun adminTeamsAdminsListRequestConfig(token: kotlin.String, teamId: kotlin.String, limit: kotlin.Int?, cursor: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                put("team_id", listOf(teamId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin.teams.admins.list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Create an Enterprise team.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @param teamDomain Team domain (for example, slacksoftballteam).
     * @param teamName Team name (for example, Slack Softball Team).
     * @param teamDescription Description for the team. (optional)
     * @param teamDiscoverability Who can join the team. A team&#39;s discoverability can be &#x60;open&#x60;, &#x60;closed&#x60;, &#x60;invite_only&#x60;, or &#x60;unlisted&#x60;. (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminTeamsCreate(token: kotlin.String, teamDomain: kotlin.String, teamName: kotlin.String, teamDescription: kotlin.String? = null, teamDiscoverability: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminTeamsCreateWithHttpInfo(token = token, teamDomain = teamDomain, teamName = teamName, teamDescription = teamDescription, teamDiscoverability = teamDiscoverability)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Create an Enterprise team.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @param teamDomain Team domain (for example, slacksoftballteam).
     * @param teamName Team name (for example, Slack Softball Team).
     * @param teamDescription Description for the team. (optional)
     * @param teamDiscoverability Who can join the team. A team&#39;s discoverability can be &#x60;open&#x60;, &#x60;closed&#x60;, &#x60;invite_only&#x60;, or &#x60;unlisted&#x60;. (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminTeamsCreateWithHttpInfo(token: kotlin.String, teamDomain: kotlin.String, teamName: kotlin.String, teamDescription: kotlin.String?, teamDiscoverability: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminTeamsCreateRequestConfig(token = token, teamDomain = teamDomain, teamName = teamName, teamDescription = teamDescription, teamDiscoverability = teamDiscoverability)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminTeamsCreate
     *
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @param teamDomain Team domain (for example, slacksoftballteam).
     * @param teamName Team name (for example, Slack Softball Team).
     * @param teamDescription Description for the team. (optional)
     * @param teamDiscoverability Who can join the team. A team&#39;s discoverability can be &#x60;open&#x60;, &#x60;closed&#x60;, &#x60;invite_only&#x60;, or &#x60;unlisted&#x60;. (optional)
     * @return RequestConfig
     */
    fun adminTeamsCreateRequestConfig(token: kotlin.String, teamDomain: kotlin.String, teamName: kotlin.String, teamDescription: kotlin.String?, teamDiscoverability: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "team_description" to PartConfig(body = teamDescription, headers = mutableMapOf()),
            "team_discoverability" to PartConfig(body = teamDiscoverability, headers = mutableMapOf()),
            "team_domain" to PartConfig(body = teamDomain, headers = mutableMapOf()),
            "team_name" to PartConfig(body = teamName, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.teams.create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * List all teams on an Enterprise organization
     * @param token Authentication token. Requires scope: &#x60;admin.teams:read&#x60;
     * @param limit The maximum number of items to return. Must be between 1 - 100 both inclusive. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminTeamsList(token: kotlin.String, limit: kotlin.Int? = null, cursor: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminTeamsListWithHttpInfo(token = token, limit = limit, cursor = cursor)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * List all teams on an Enterprise organization
     * @param token Authentication token. Requires scope: &#x60;admin.teams:read&#x60;
     * @param limit The maximum number of items to return. Must be between 1 - 100 both inclusive. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminTeamsListWithHttpInfo(token: kotlin.String, limit: kotlin.Int?, cursor: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminTeamsListRequestConfig(token = token, limit = limit, cursor = cursor)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminTeamsList
     *
     * @param token Authentication token. Requires scope: &#x60;admin.teams:read&#x60;
     * @param limit The maximum number of items to return. Must be between 1 - 100 both inclusive. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional)
     * @return RequestConfig
     */
    fun adminTeamsListRequestConfig(token: kotlin.String, limit: kotlin.Int?, cursor: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin.teams.list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * List all of the owners on a given workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:read&#x60;
     * @param teamId 
     * @param limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminTeamsOwnersList(token: kotlin.String, teamId: kotlin.String, limit: kotlin.Int? = null, cursor: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminTeamsOwnersListWithHttpInfo(token = token, teamId = teamId, limit = limit, cursor = cursor)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * List all of the owners on a given workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:read&#x60;
     * @param teamId 
     * @param limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminTeamsOwnersListWithHttpInfo(token: kotlin.String, teamId: kotlin.String, limit: kotlin.Int?, cursor: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminTeamsOwnersListRequestConfig(token = token, teamId = teamId, limit = limit, cursor = cursor)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminTeamsOwnersList
     *
     * @param token Authentication token. Requires scope: &#x60;admin.teams:read&#x60;
     * @param teamId 
     * @param limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional)
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional)
     * @return RequestConfig
     */
    fun adminTeamsOwnersListRequestConfig(token: kotlin.String, teamId: kotlin.String, limit: kotlin.Int?, cursor: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
                put("team_id", listOf(teamId.toString()))
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin.teams.owners.list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Fetch information about settings in a workspace
     * @param token Authentication token. Requires scope: &#x60;admin.teams:read&#x60;
     * @param teamId 
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminTeamsSettingsInfo(token: kotlin.String, teamId: kotlin.String) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminTeamsSettingsInfoWithHttpInfo(token = token, teamId = teamId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Fetch information about settings in a workspace
     * @param token Authentication token. Requires scope: &#x60;admin.teams:read&#x60;
     * @param teamId 
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminTeamsSettingsInfoWithHttpInfo(token: kotlin.String, teamId: kotlin.String) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminTeamsSettingsInfoRequestConfig(token = token, teamId = teamId)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminTeamsSettingsInfo
     *
     * @param token Authentication token. Requires scope: &#x60;admin.teams:read&#x60;
     * @param teamId 
     * @return RequestConfig
     */
    fun adminTeamsSettingsInfoRequestConfig(token: kotlin.String, teamId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("team_id", listOf(teamId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin.teams.settings.info",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Set the default channels of a workspace.
     * @param channelIds An array of channel IDs.
     * @param teamId ID for the workspace to set the default channel for.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminTeamsSettingsSetDefaultChannels(channelIds: kotlin.String, teamId: kotlin.String, token: kotlin.String) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminTeamsSettingsSetDefaultChannelsWithHttpInfo(channelIds = channelIds, teamId = teamId, token = token)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Set the default channels of a workspace.
     * @param channelIds An array of channel IDs.
     * @param teamId ID for the workspace to set the default channel for.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminTeamsSettingsSetDefaultChannelsWithHttpInfo(channelIds: kotlin.String, teamId: kotlin.String, token: kotlin.String) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminTeamsSettingsSetDefaultChannelsRequestConfig(channelIds = channelIds, teamId = teamId, token = token)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminTeamsSettingsSetDefaultChannels
     *
     * @param channelIds An array of channel IDs.
     * @param teamId ID for the workspace to set the default channel for.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @return RequestConfig
     */
    fun adminTeamsSettingsSetDefaultChannelsRequestConfig(channelIds: kotlin.String, teamId: kotlin.String, token: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel_ids" to PartConfig(body = channelIds, headers = mutableMapOf()),
            "team_id" to PartConfig(body = teamId, headers = mutableMapOf()),
            "token" to PartConfig(body = token, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.teams.settings.setDefaultChannels",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Set the description of a given workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @param description The new description for the workspace.
     * @param teamId ID for the workspace to set the description for.
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminTeamsSettingsSetDescription(token: kotlin.String, description: kotlin.String, teamId: kotlin.String) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminTeamsSettingsSetDescriptionWithHttpInfo(token = token, description = description, teamId = teamId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Set the description of a given workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @param description The new description for the workspace.
     * @param teamId ID for the workspace to set the description for.
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminTeamsSettingsSetDescriptionWithHttpInfo(token: kotlin.String, description: kotlin.String, teamId: kotlin.String) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminTeamsSettingsSetDescriptionRequestConfig(token = token, description = description, teamId = teamId)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminTeamsSettingsSetDescription
     *
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @param description The new description for the workspace.
     * @param teamId ID for the workspace to set the description for.
     * @return RequestConfig
     */
    fun adminTeamsSettingsSetDescriptionRequestConfig(token: kotlin.String, description: kotlin.String, teamId: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "description" to PartConfig(body = description, headers = mutableMapOf()),
            "team_id" to PartConfig(body = teamId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.teams.settings.setDescription",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * An API method that allows admins to set the discoverability of a given workspace
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @param discoverability This workspace&#39;s discovery setting. It must be set to one of &#x60;open&#x60;, &#x60;invite_only&#x60;, &#x60;closed&#x60;, or &#x60;unlisted&#x60;.
     * @param teamId The ID of the workspace to set discoverability on.
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminTeamsSettingsSetDiscoverability(token: kotlin.String, discoverability: kotlin.String, teamId: kotlin.String) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminTeamsSettingsSetDiscoverabilityWithHttpInfo(token = token, discoverability = discoverability, teamId = teamId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * An API method that allows admins to set the discoverability of a given workspace
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @param discoverability This workspace&#39;s discovery setting. It must be set to one of &#x60;open&#x60;, &#x60;invite_only&#x60;, &#x60;closed&#x60;, or &#x60;unlisted&#x60;.
     * @param teamId The ID of the workspace to set discoverability on.
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminTeamsSettingsSetDiscoverabilityWithHttpInfo(token: kotlin.String, discoverability: kotlin.String, teamId: kotlin.String) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminTeamsSettingsSetDiscoverabilityRequestConfig(token = token, discoverability = discoverability, teamId = teamId)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminTeamsSettingsSetDiscoverability
     *
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @param discoverability This workspace&#39;s discovery setting. It must be set to one of &#x60;open&#x60;, &#x60;invite_only&#x60;, &#x60;closed&#x60;, or &#x60;unlisted&#x60;.
     * @param teamId The ID of the workspace to set discoverability on.
     * @return RequestConfig
     */
    fun adminTeamsSettingsSetDiscoverabilityRequestConfig(token: kotlin.String, discoverability: kotlin.String, teamId: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "discoverability" to PartConfig(body = discoverability, headers = mutableMapOf()),
            "team_id" to PartConfig(body = teamId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.teams.settings.setDiscoverability",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Sets the icon of a workspace.
     * @param imageUrl Image URL for the icon
     * @param teamId ID for the workspace to set the icon for.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminTeamsSettingsSetIcon(imageUrl: kotlin.String, teamId: kotlin.String, token: kotlin.String) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminTeamsSettingsSetIconWithHttpInfo(imageUrl = imageUrl, teamId = teamId, token = token)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Sets the icon of a workspace.
     * @param imageUrl Image URL for the icon
     * @param teamId ID for the workspace to set the icon for.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminTeamsSettingsSetIconWithHttpInfo(imageUrl: kotlin.String, teamId: kotlin.String, token: kotlin.String) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminTeamsSettingsSetIconRequestConfig(imageUrl = imageUrl, teamId = teamId, token = token)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminTeamsSettingsSetIcon
     *
     * @param imageUrl Image URL for the icon
     * @param teamId ID for the workspace to set the icon for.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @return RequestConfig
     */
    fun adminTeamsSettingsSetIconRequestConfig(imageUrl: kotlin.String, teamId: kotlin.String, token: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "image_url" to PartConfig(body = imageUrl, headers = mutableMapOf()),
            "team_id" to PartConfig(body = teamId, headers = mutableMapOf()),
            "token" to PartConfig(body = token, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.teams.settings.setIcon",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Set the name of a given workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @param name The new name of the workspace.
     * @param teamId ID for the workspace to set the name for.
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminTeamsSettingsSetName(token: kotlin.String, name: kotlin.String, teamId: kotlin.String) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminTeamsSettingsSetNameWithHttpInfo(token = token, name = name, teamId = teamId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Set the name of a given workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @param name The new name of the workspace.
     * @param teamId ID for the workspace to set the name for.
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminTeamsSettingsSetNameWithHttpInfo(token: kotlin.String, name: kotlin.String, teamId: kotlin.String) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminTeamsSettingsSetNameRequestConfig(token = token, name = name, teamId = teamId)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminTeamsSettingsSetName
     *
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @param name The new name of the workspace.
     * @param teamId ID for the workspace to set the name for.
     * @return RequestConfig
     */
    fun adminTeamsSettingsSetNameRequestConfig(token: kotlin.String, name: kotlin.String, teamId: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "name" to PartConfig(body = name, headers = mutableMapOf()),
            "team_id" to PartConfig(body = teamId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.teams.settings.setName",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Add one or more default channels to an IDP group.
     * @param token Authentication token. Requires scope: &#x60;admin.usergroups:write&#x60;
     * @param channelIds Comma separated string of channel IDs.
     * @param usergroupId ID of the IDP group to add default channels for.
     * @param teamId The workspace to add default channels in. (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminUsergroupsAddChannels(token: kotlin.String, channelIds: kotlin.String, usergroupId: kotlin.String, teamId: kotlin.String? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminUsergroupsAddChannelsWithHttpInfo(token = token, channelIds = channelIds, usergroupId = usergroupId, teamId = teamId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Add one or more default channels to an IDP group.
     * @param token Authentication token. Requires scope: &#x60;admin.usergroups:write&#x60;
     * @param channelIds Comma separated string of channel IDs.
     * @param usergroupId ID of the IDP group to add default channels for.
     * @param teamId The workspace to add default channels in. (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminUsergroupsAddChannelsWithHttpInfo(token: kotlin.String, channelIds: kotlin.String, usergroupId: kotlin.String, teamId: kotlin.String?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminUsergroupsAddChannelsRequestConfig(token = token, channelIds = channelIds, usergroupId = usergroupId, teamId = teamId)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminUsergroupsAddChannels
     *
     * @param token Authentication token. Requires scope: &#x60;admin.usergroups:write&#x60;
     * @param channelIds Comma separated string of channel IDs.
     * @param usergroupId ID of the IDP group to add default channels for.
     * @param teamId The workspace to add default channels in. (optional)
     * @return RequestConfig
     */
    fun adminUsergroupsAddChannelsRequestConfig(token: kotlin.String, channelIds: kotlin.String, usergroupId: kotlin.String, teamId: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel_ids" to PartConfig(body = channelIds, headers = mutableMapOf()),
            "team_id" to PartConfig(body = teamId, headers = mutableMapOf()),
            "usergroup_id" to PartConfig(body = usergroupId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.usergroups.addChannels",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Associate one or more default workspaces with an organization-wide IDP group.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @param teamIds A comma separated list of encoded team (workspace) IDs. Each workspace *MUST* belong to the organization associated with the token.
     * @param usergroupId An encoded usergroup (IDP Group) ID.
     * @param autoProvision When &#x60;true&#x60;, this method automatically creates new workspace accounts for the IDP group members. (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminUsergroupsAddTeams(token: kotlin.String, teamIds: kotlin.String, usergroupId: kotlin.String, autoProvision: kotlin.Boolean? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminUsergroupsAddTeamsWithHttpInfo(token = token, teamIds = teamIds, usergroupId = usergroupId, autoProvision = autoProvision)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Associate one or more default workspaces with an organization-wide IDP group.
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @param teamIds A comma separated list of encoded team (workspace) IDs. Each workspace *MUST* belong to the organization associated with the token.
     * @param usergroupId An encoded usergroup (IDP Group) ID.
     * @param autoProvision When &#x60;true&#x60;, this method automatically creates new workspace accounts for the IDP group members. (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminUsergroupsAddTeamsWithHttpInfo(token: kotlin.String, teamIds: kotlin.String, usergroupId: kotlin.String, autoProvision: kotlin.Boolean?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminUsergroupsAddTeamsRequestConfig(token = token, teamIds = teamIds, usergroupId = usergroupId, autoProvision = autoProvision)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminUsergroupsAddTeams
     *
     * @param token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
     * @param teamIds A comma separated list of encoded team (workspace) IDs. Each workspace *MUST* belong to the organization associated with the token.
     * @param usergroupId An encoded usergroup (IDP Group) ID.
     * @param autoProvision When &#x60;true&#x60;, this method automatically creates new workspace accounts for the IDP group members. (optional)
     * @return RequestConfig
     */
    fun adminUsergroupsAddTeamsRequestConfig(token: kotlin.String, teamIds: kotlin.String, usergroupId: kotlin.String, autoProvision: kotlin.Boolean?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "auto_provision" to PartConfig(body = autoProvision, headers = mutableMapOf()),
            "team_ids" to PartConfig(body = teamIds, headers = mutableMapOf()),
            "usergroup_id" to PartConfig(body = usergroupId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.usergroups.addTeams",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * List the channels linked to an org-level IDP group (user group).
     * @param token Authentication token. Requires scope: &#x60;admin.usergroups:read&#x60;
     * @param usergroupId ID of the IDP group to list default channels for.
     * @param teamId ID of the the workspace. (optional)
     * @param includeNumMembers Flag to include or exclude the count of members per channel. (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminUsergroupsListChannels(token: kotlin.String, usergroupId: kotlin.String, teamId: kotlin.String? = null, includeNumMembers: kotlin.Boolean? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminUsergroupsListChannelsWithHttpInfo(token = token, usergroupId = usergroupId, teamId = teamId, includeNumMembers = includeNumMembers)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * List the channels linked to an org-level IDP group (user group).
     * @param token Authentication token. Requires scope: &#x60;admin.usergroups:read&#x60;
     * @param usergroupId ID of the IDP group to list default channels for.
     * @param teamId ID of the the workspace. (optional)
     * @param includeNumMembers Flag to include or exclude the count of members per channel. (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminUsergroupsListChannelsWithHttpInfo(token: kotlin.String, usergroupId: kotlin.String, teamId: kotlin.String?, includeNumMembers: kotlin.Boolean?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminUsergroupsListChannelsRequestConfig(token = token, usergroupId = usergroupId, teamId = teamId, includeNumMembers = includeNumMembers)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminUsergroupsListChannels
     *
     * @param token Authentication token. Requires scope: &#x60;admin.usergroups:read&#x60;
     * @param usergroupId ID of the IDP group to list default channels for.
     * @param teamId ID of the the workspace. (optional)
     * @param includeNumMembers Flag to include or exclude the count of members per channel. (optional)
     * @return RequestConfig
     */
    fun adminUsergroupsListChannelsRequestConfig(token: kotlin.String, usergroupId: kotlin.String, teamId: kotlin.String?, includeNumMembers: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("usergroup_id", listOf(usergroupId.toString()))
                if (teamId != null) {
                    put("team_id", listOf(teamId.toString()))
                }
                if (includeNumMembers != null) {
                    put("include_num_members", listOf(includeNumMembers.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin.usergroups.listChannels",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Remove one or more default channels from an org-level IDP group (user group).
     * @param token Authentication token. Requires scope: &#x60;admin.usergroups:write&#x60;
     * @param channelIds Comma-separated string of channel IDs
     * @param usergroupId ID of the IDP Group
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminUsergroupsRemoveChannels(token: kotlin.String, channelIds: kotlin.String, usergroupId: kotlin.String) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminUsergroupsRemoveChannelsWithHttpInfo(token = token, channelIds = channelIds, usergroupId = usergroupId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Remove one or more default channels from an org-level IDP group (user group).
     * @param token Authentication token. Requires scope: &#x60;admin.usergroups:write&#x60;
     * @param channelIds Comma-separated string of channel IDs
     * @param usergroupId ID of the IDP Group
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminUsergroupsRemoveChannelsWithHttpInfo(token: kotlin.String, channelIds: kotlin.String, usergroupId: kotlin.String) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminUsergroupsRemoveChannelsRequestConfig(token = token, channelIds = channelIds, usergroupId = usergroupId)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminUsergroupsRemoveChannels
     *
     * @param token Authentication token. Requires scope: &#x60;admin.usergroups:write&#x60;
     * @param channelIds Comma-separated string of channel IDs
     * @param usergroupId ID of the IDP Group
     * @return RequestConfig
     */
    fun adminUsergroupsRemoveChannelsRequestConfig(token: kotlin.String, channelIds: kotlin.String, usergroupId: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel_ids" to PartConfig(body = channelIds, headers = mutableMapOf()),
            "usergroup_id" to PartConfig(body = usergroupId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.usergroups.removeChannels",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Add an Enterprise user to a workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param userId The ID of the user to add to the workspace.
     * @param channelIds Comma separated values of channel IDs to add user in the new workspace. (optional)
     * @param isRestricted True if user should be added to the workspace as a guest. (optional)
     * @param isUltraRestricted True if user should be added to the workspace as a single-channel guest. (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminUsersAssign(token: kotlin.String, teamId: kotlin.String, userId: kotlin.String, channelIds: kotlin.String? = null, isRestricted: kotlin.Boolean? = null, isUltraRestricted: kotlin.Boolean? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminUsersAssignWithHttpInfo(token = token, teamId = teamId, userId = userId, channelIds = channelIds, isRestricted = isRestricted, isUltraRestricted = isUltraRestricted)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Add an Enterprise user to a workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param userId The ID of the user to add to the workspace.
     * @param channelIds Comma separated values of channel IDs to add user in the new workspace. (optional)
     * @param isRestricted True if user should be added to the workspace as a guest. (optional)
     * @param isUltraRestricted True if user should be added to the workspace as a single-channel guest. (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminUsersAssignWithHttpInfo(token: kotlin.String, teamId: kotlin.String, userId: kotlin.String, channelIds: kotlin.String?, isRestricted: kotlin.Boolean?, isUltraRestricted: kotlin.Boolean?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminUsersAssignRequestConfig(token = token, teamId = teamId, userId = userId, channelIds = channelIds, isRestricted = isRestricted, isUltraRestricted = isUltraRestricted)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminUsersAssign
     *
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param userId The ID of the user to add to the workspace.
     * @param channelIds Comma separated values of channel IDs to add user in the new workspace. (optional)
     * @param isRestricted True if user should be added to the workspace as a guest. (optional)
     * @param isUltraRestricted True if user should be added to the workspace as a single-channel guest. (optional)
     * @return RequestConfig
     */
    fun adminUsersAssignRequestConfig(token: kotlin.String, teamId: kotlin.String, userId: kotlin.String, channelIds: kotlin.String?, isRestricted: kotlin.Boolean?, isUltraRestricted: kotlin.Boolean?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel_ids" to PartConfig(body = channelIds, headers = mutableMapOf()),
            "is_restricted" to PartConfig(body = isRestricted, headers = mutableMapOf()),
            "is_ultra_restricted" to PartConfig(body = isUltraRestricted, headers = mutableMapOf()),
            "team_id" to PartConfig(body = teamId, headers = mutableMapOf()),
            "user_id" to PartConfig(body = userId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.users.assign",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Invite a user to a workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param channelIds A comma-separated list of &#x60;channel_id&#x60;s for this user to join. At least one channel is required.
     * @param email The email address of the person to invite.
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param customMessage An optional message to send to the user in the invite email. (optional)
     * @param guestExpirationTs Timestamp when guest account should be disabled. Only include this timestamp if you are inviting a guest user and you want their account to expire on a certain date. (optional)
     * @param isRestricted Is this user a multi-channel guest user? (default: false) (optional)
     * @param isUltraRestricted Is this user a single channel guest user? (default: false) (optional)
     * @param realName Full name of the user. (optional)
     * @param resend Allow this invite to be resent in the future if a user has not signed up yet. (default: false) (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminUsersInvite(token: kotlin.String, channelIds: kotlin.String, email: kotlin.String, teamId: kotlin.String, customMessage: kotlin.String? = null, guestExpirationTs: kotlin.String? = null, isRestricted: kotlin.Boolean? = null, isUltraRestricted: kotlin.Boolean? = null, realName: kotlin.String? = null, resend: kotlin.Boolean? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminUsersInviteWithHttpInfo(token = token, channelIds = channelIds, email = email, teamId = teamId, customMessage = customMessage, guestExpirationTs = guestExpirationTs, isRestricted = isRestricted, isUltraRestricted = isUltraRestricted, realName = realName, resend = resend)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Invite a user to a workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param channelIds A comma-separated list of &#x60;channel_id&#x60;s for this user to join. At least one channel is required.
     * @param email The email address of the person to invite.
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param customMessage An optional message to send to the user in the invite email. (optional)
     * @param guestExpirationTs Timestamp when guest account should be disabled. Only include this timestamp if you are inviting a guest user and you want their account to expire on a certain date. (optional)
     * @param isRestricted Is this user a multi-channel guest user? (default: false) (optional)
     * @param isUltraRestricted Is this user a single channel guest user? (default: false) (optional)
     * @param realName Full name of the user. (optional)
     * @param resend Allow this invite to be resent in the future if a user has not signed up yet. (default: false) (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminUsersInviteWithHttpInfo(token: kotlin.String, channelIds: kotlin.String, email: kotlin.String, teamId: kotlin.String, customMessage: kotlin.String?, guestExpirationTs: kotlin.String?, isRestricted: kotlin.Boolean?, isUltraRestricted: kotlin.Boolean?, realName: kotlin.String?, resend: kotlin.Boolean?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminUsersInviteRequestConfig(token = token, channelIds = channelIds, email = email, teamId = teamId, customMessage = customMessage, guestExpirationTs = guestExpirationTs, isRestricted = isRestricted, isUltraRestricted = isUltraRestricted, realName = realName, resend = resend)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminUsersInvite
     *
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param channelIds A comma-separated list of &#x60;channel_id&#x60;s for this user to join. At least one channel is required.
     * @param email The email address of the person to invite.
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param customMessage An optional message to send to the user in the invite email. (optional)
     * @param guestExpirationTs Timestamp when guest account should be disabled. Only include this timestamp if you are inviting a guest user and you want their account to expire on a certain date. (optional)
     * @param isRestricted Is this user a multi-channel guest user? (default: false) (optional)
     * @param isUltraRestricted Is this user a single channel guest user? (default: false) (optional)
     * @param realName Full name of the user. (optional)
     * @param resend Allow this invite to be resent in the future if a user has not signed up yet. (default: false) (optional)
     * @return RequestConfig
     */
    fun adminUsersInviteRequestConfig(token: kotlin.String, channelIds: kotlin.String, email: kotlin.String, teamId: kotlin.String, customMessage: kotlin.String?, guestExpirationTs: kotlin.String?, isRestricted: kotlin.Boolean?, isUltraRestricted: kotlin.Boolean?, realName: kotlin.String?, resend: kotlin.Boolean?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel_ids" to PartConfig(body = channelIds, headers = mutableMapOf()),
            "custom_message" to PartConfig(body = customMessage, headers = mutableMapOf()),
            "email" to PartConfig(body = email, headers = mutableMapOf()),
            "guest_expiration_ts" to PartConfig(body = guestExpirationTs, headers = mutableMapOf()),
            "is_restricted" to PartConfig(body = isRestricted, headers = mutableMapOf()),
            "is_ultra_restricted" to PartConfig(body = isUltraRestricted, headers = mutableMapOf()),
            "real_name" to PartConfig(body = realName, headers = mutableMapOf()),
            "resend" to PartConfig(body = resend, headers = mutableMapOf()),
            "team_id" to PartConfig(body = teamId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.users.invite",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * List users on a workspace
     * @param token Authentication token. Requires scope: &#x60;admin.users:read&#x60;
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional)
     * @param limit Limit for how many users to be retrieved per page (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminUsersList(token: kotlin.String, teamId: kotlin.String, cursor: kotlin.String? = null, limit: kotlin.Int? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminUsersListWithHttpInfo(token = token, teamId = teamId, cursor = cursor, limit = limit)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * List users on a workspace
     * @param token Authentication token. Requires scope: &#x60;admin.users:read&#x60;
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional)
     * @param limit Limit for how many users to be retrieved per page (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminUsersListWithHttpInfo(token: kotlin.String, teamId: kotlin.String, cursor: kotlin.String?, limit: kotlin.Int?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminUsersListRequestConfig(token = token, teamId = teamId, cursor = cursor, limit = limit)

        return@withContext request<Unit, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminUsersList
     *
     * @param token Authentication token. Requires scope: &#x60;admin.users:read&#x60;
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional)
     * @param limit Limit for how many users to be retrieved per page (optional)
     * @return RequestConfig
     */
    fun adminUsersListRequestConfig(token: kotlin.String, teamId: kotlin.String, cursor: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("team_id", listOf(teamId.toString()))
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin.users.list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Remove a user from a workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param userId The ID of the user to remove.
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminUsersRemove(token: kotlin.String, teamId: kotlin.String, userId: kotlin.String) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminUsersRemoveWithHttpInfo(token = token, teamId = teamId, userId = userId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Remove a user from a workspace.
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param userId The ID of the user to remove.
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminUsersRemoveWithHttpInfo(token: kotlin.String, teamId: kotlin.String, userId: kotlin.String) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminUsersRemoveRequestConfig(token = token, teamId = teamId, userId = userId)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminUsersRemove
     *
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param userId The ID of the user to remove.
     * @return RequestConfig
     */
    fun adminUsersRemoveRequestConfig(token: kotlin.String, teamId: kotlin.String, userId: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "team_id" to PartConfig(body = teamId, headers = mutableMapOf()),
            "user_id" to PartConfig(body = userId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.users.remove",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Invalidate a single session for a user by session_id
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param sessionId 
     * @param teamId ID of the team that the session belongs to
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminUsersSessionInvalidate(token: kotlin.String, sessionId: kotlin.Int, teamId: kotlin.String) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminUsersSessionInvalidateWithHttpInfo(token = token, sessionId = sessionId, teamId = teamId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Invalidate a single session for a user by session_id
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param sessionId 
     * @param teamId ID of the team that the session belongs to
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminUsersSessionInvalidateWithHttpInfo(token: kotlin.String, sessionId: kotlin.Int, teamId: kotlin.String) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminUsersSessionInvalidateRequestConfig(token = token, sessionId = sessionId, teamId = teamId)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminUsersSessionInvalidate
     *
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param sessionId 
     * @param teamId ID of the team that the session belongs to
     * @return RequestConfig
     */
    fun adminUsersSessionInvalidateRequestConfig(token: kotlin.String, sessionId: kotlin.Int, teamId: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "session_id" to PartConfig(body = sessionId, headers = mutableMapOf()),
            "team_id" to PartConfig(body = teamId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.users.session.invalidate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Wipes all valid sessions on all devices for a given user
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param userId The ID of the user to wipe sessions for
     * @param mobileOnly Only expire mobile sessions (default: false) (optional)
     * @param webOnly Only expire web sessions (default: false) (optional)
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminUsersSessionReset(token: kotlin.String, userId: kotlin.String, mobileOnly: kotlin.Boolean? = null, webOnly: kotlin.Boolean? = null) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminUsersSessionResetWithHttpInfo(token = token, userId = userId, mobileOnly = mobileOnly, webOnly = webOnly)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Wipes all valid sessions on all devices for a given user
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param userId The ID of the user to wipe sessions for
     * @param mobileOnly Only expire mobile sessions (default: false) (optional)
     * @param webOnly Only expire web sessions (default: false) (optional)
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminUsersSessionResetWithHttpInfo(token: kotlin.String, userId: kotlin.String, mobileOnly: kotlin.Boolean?, webOnly: kotlin.Boolean?) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminUsersSessionResetRequestConfig(token = token, userId = userId, mobileOnly = mobileOnly, webOnly = webOnly)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminUsersSessionReset
     *
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param userId The ID of the user to wipe sessions for
     * @param mobileOnly Only expire mobile sessions (default: false) (optional)
     * @param webOnly Only expire web sessions (default: false) (optional)
     * @return RequestConfig
     */
    fun adminUsersSessionResetRequestConfig(token: kotlin.String, userId: kotlin.String, mobileOnly: kotlin.Boolean?, webOnly: kotlin.Boolean?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "mobile_only" to PartConfig(body = mobileOnly, headers = mutableMapOf()),
            "user_id" to PartConfig(body = userId, headers = mutableMapOf()),
            "web_only" to PartConfig(body = webOnly, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.users.session.reset",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Set an existing guest, regular user, or owner to be an admin user.
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param userId The ID of the user to designate as an admin.
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminUsersSetAdmin(token: kotlin.String, teamId: kotlin.String, userId: kotlin.String) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminUsersSetAdminWithHttpInfo(token = token, teamId = teamId, userId = userId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Set an existing guest, regular user, or owner to be an admin user.
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param userId The ID of the user to designate as an admin.
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminUsersSetAdminWithHttpInfo(token: kotlin.String, teamId: kotlin.String, userId: kotlin.String) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminUsersSetAdminRequestConfig(token = token, teamId = teamId, userId = userId)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminUsersSetAdmin
     *
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param userId The ID of the user to designate as an admin.
     * @return RequestConfig
     */
    fun adminUsersSetAdminRequestConfig(token: kotlin.String, teamId: kotlin.String, userId: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "team_id" to PartConfig(body = teamId, headers = mutableMapOf()),
            "user_id" to PartConfig(body = userId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.users.setAdmin",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Set an expiration for a guest user
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param expirationTs Timestamp when guest account should be disabled.
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param userId The ID of the user to set an expiration for.
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminUsersSetExpiration(token: kotlin.String, expirationTs: kotlin.Int, teamId: kotlin.String, userId: kotlin.String) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminUsersSetExpirationWithHttpInfo(token = token, expirationTs = expirationTs, teamId = teamId, userId = userId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Set an expiration for a guest user
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param expirationTs Timestamp when guest account should be disabled.
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param userId The ID of the user to set an expiration for.
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminUsersSetExpirationWithHttpInfo(token: kotlin.String, expirationTs: kotlin.Int, teamId: kotlin.String, userId: kotlin.String) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminUsersSetExpirationRequestConfig(token = token, expirationTs = expirationTs, teamId = teamId, userId = userId)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminUsersSetExpiration
     *
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param expirationTs Timestamp when guest account should be disabled.
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param userId The ID of the user to set an expiration for.
     * @return RequestConfig
     */
    fun adminUsersSetExpirationRequestConfig(token: kotlin.String, expirationTs: kotlin.Int, teamId: kotlin.String, userId: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "expiration_ts" to PartConfig(body = expirationTs, headers = mutableMapOf()),
            "team_id" to PartConfig(body = teamId, headers = mutableMapOf()),
            "user_id" to PartConfig(body = userId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.users.setExpiration",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Set an existing guest, regular user, or admin user to be a workspace owner.
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param userId Id of the user to promote to owner.
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminUsersSetOwner(token: kotlin.String, teamId: kotlin.String, userId: kotlin.String) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminUsersSetOwnerWithHttpInfo(token = token, teamId = teamId, userId = userId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Set an existing guest, regular user, or admin user to be a workspace owner.
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param userId Id of the user to promote to owner.
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminUsersSetOwnerWithHttpInfo(token: kotlin.String, teamId: kotlin.String, userId: kotlin.String) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminUsersSetOwnerRequestConfig(token = token, teamId = teamId, userId = userId)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminUsersSetOwner
     *
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param userId Id of the user to promote to owner.
     * @return RequestConfig
     */
    fun adminUsersSetOwnerRequestConfig(token: kotlin.String, teamId: kotlin.String, userId: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "team_id" to PartConfig(body = teamId, headers = mutableMapOf()),
            "user_id" to PartConfig(body = userId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.users.setOwner",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Set an existing guest user, admin user, or owner to be a regular user.
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param userId The ID of the user to designate as a regular user.
     * @return DefaultSuccessTemplate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun adminUsersSetRegular(token: kotlin.String, teamId: kotlin.String, userId: kotlin.String) : DefaultSuccessTemplate = withContext(Dispatchers.IO) {
        val localVarResponse = adminUsersSetRegularWithHttpInfo(token = token, teamId = teamId, userId = userId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DefaultSuccessTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Set an existing guest user, admin user, or owner to be a regular user.
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param userId The ID of the user to designate as a regular user.
     * @return ApiResponse<DefaultSuccessTemplate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun adminUsersSetRegularWithHttpInfo(token: kotlin.String, teamId: kotlin.String, userId: kotlin.String) : ApiResponse<DefaultSuccessTemplate?> = withContext(Dispatchers.IO) {
        val localVariableConfig = adminUsersSetRegularRequestConfig(token = token, teamId = teamId, userId = userId)

        return@withContext request<Map<String, PartConfig<*>>, DefaultSuccessTemplate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminUsersSetRegular
     *
     * @param token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
     * @param teamId The ID (&#x60;T1234&#x60;) of the workspace.
     * @param userId The ID of the user to designate as a regular user.
     * @return RequestConfig
     */
    fun adminUsersSetRegularRequestConfig(token: kotlin.String, teamId: kotlin.String, userId: kotlin.String) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "team_id" to PartConfig(body = teamId, headers = mutableMapOf()),
            "user_id" to PartConfig(body = userId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin.users.setRegular",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
