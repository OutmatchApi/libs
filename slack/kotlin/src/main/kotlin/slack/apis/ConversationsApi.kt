/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package slack.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.outmatchapi.slack.ConversationsArchiveErrorSchema
import com.outmatchapi.slack.ConversationsArchiveSuccessSchema
import com.outmatchapi.slack.ConversationsCloseErrorSchema
import com.outmatchapi.slack.ConversationsCloseSuccessSchema
import com.outmatchapi.slack.ConversationsCreateErrorSchema
import com.outmatchapi.slack.ConversationsCreateSuccessSchema
import com.outmatchapi.slack.ConversationsHistoryErrorSchema
import com.outmatchapi.slack.ConversationsHistorySuccessSchema
import com.outmatchapi.slack.ConversationsInfoErrorSchema
import com.outmatchapi.slack.ConversationsInfoSuccessSchema
import com.outmatchapi.slack.ConversationsInviteErrorSchema
import com.outmatchapi.slack.ConversationsInviteErrorSchema1
import com.outmatchapi.slack.ConversationsJoinErrorSchema
import com.outmatchapi.slack.ConversationsJoinSuccessSchema
import com.outmatchapi.slack.ConversationsKickErrorSchema
import com.outmatchapi.slack.ConversationsKickSuccessSchema
import com.outmatchapi.slack.ConversationsLeaveErrorSchema
import com.outmatchapi.slack.ConversationsLeaveSuccessSchema
import com.outmatchapi.slack.ConversationsListErrorSchema
import com.outmatchapi.slack.ConversationsListSuccessSchema
import com.outmatchapi.slack.ConversationsMarkErrorSchema
import com.outmatchapi.slack.ConversationsMarkSuccessSchema
import com.outmatchapi.slack.ConversationsMembersErrorSchema
import com.outmatchapi.slack.ConversationsMembersSuccessSchema
import com.outmatchapi.slack.ConversationsOpenErrorSchema
import com.outmatchapi.slack.ConversationsOpenSuccessSchema
import com.outmatchapi.slack.ConversationsRenameErrorSchema
import com.outmatchapi.slack.ConversationsRenameSuccessSchema
import com.outmatchapi.slack.ConversationsRepliesErrorSchema
import com.outmatchapi.slack.ConversationsRepliesSuccessSchema
import com.outmatchapi.slack.ConversationsSetPurposeErrorSchema
import com.outmatchapi.slack.ConversationsSetPurposeSuccessSchema
import com.outmatchapi.slack.ConversationsSetTopicErrorSchema
import com.outmatchapi.slack.ConversationsSetTopicSuccessSchema
import com.outmatchapi.slack.ConversationsUnarchiveErrorSchema
import com.outmatchapi.slack.ConversationsUnarchiveSuccessSchema

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import slack.infrastructure.ApiClient
import slack.infrastructure.ApiResponse
import slack.infrastructure.ClientException
import slack.infrastructure.ClientError
import slack.infrastructure.ServerException
import slack.infrastructure.ServerError
import slack.infrastructure.MultiValueMap
import slack.infrastructure.PartConfig
import slack.infrastructure.RequestConfig
import slack.infrastructure.RequestMethod
import slack.infrastructure.ResponseType
import slack.infrastructure.Success
import slack.infrastructure.toMultiValue

class ConversationsApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://slack.com/api")
        }
    }

    /**
     * 
     * Archives a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to archive (optional)
     * @return ConversationsArchiveSuccessSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun conversationsArchive(token: kotlin.String? = null, channel: kotlin.String? = null) : ConversationsArchiveSuccessSchema = withContext(Dispatchers.IO) {
        val localVarResponse = conversationsArchiveWithHttpInfo(token = token, channel = channel)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConversationsArchiveSuccessSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Archives a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to archive (optional)
     * @return ApiResponse<ConversationsArchiveSuccessSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun conversationsArchiveWithHttpInfo(token: kotlin.String?, channel: kotlin.String?) : ApiResponse<ConversationsArchiveSuccessSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = conversationsArchiveRequestConfig(token = token, channel = channel)

        return@withContext request<Map<String, PartConfig<*>>, ConversationsArchiveSuccessSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation conversationsArchive
     *
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to archive (optional)
     * @return RequestConfig
     */
    fun conversationsArchiveRequestConfig(token: kotlin.String?, channel: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel" to PartConfig(body = channel, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token?.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/conversations.archive",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Closes a direct message or multi-person direct message.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to close. (optional)
     * @return ConversationsCloseSuccessSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun conversationsClose(token: kotlin.String? = null, channel: kotlin.String? = null) : ConversationsCloseSuccessSchema = withContext(Dispatchers.IO) {
        val localVarResponse = conversationsCloseWithHttpInfo(token = token, channel = channel)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConversationsCloseSuccessSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Closes a direct message or multi-person direct message.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to close. (optional)
     * @return ApiResponse<ConversationsCloseSuccessSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun conversationsCloseWithHttpInfo(token: kotlin.String?, channel: kotlin.String?) : ApiResponse<ConversationsCloseSuccessSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = conversationsCloseRequestConfig(token = token, channel = channel)

        return@withContext request<Map<String, PartConfig<*>>, ConversationsCloseSuccessSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation conversationsClose
     *
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to close. (optional)
     * @return RequestConfig
     */
    fun conversationsCloseRequestConfig(token: kotlin.String?, channel: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel" to PartConfig(body = channel, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token?.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/conversations.close",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Initiates a public or private channel-based conversation
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param isPrivate Create a private channel instead of a public one (optional)
     * @param name Name of the public or private channel to create (optional)
     * @return ConversationsCreateSuccessSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun conversationsCreate(token: kotlin.String? = null, isPrivate: kotlin.Boolean? = null, name: kotlin.String? = null) : ConversationsCreateSuccessSchema = withContext(Dispatchers.IO) {
        val localVarResponse = conversationsCreateWithHttpInfo(token = token, isPrivate = isPrivate, name = name)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConversationsCreateSuccessSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Initiates a public or private channel-based conversation
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param isPrivate Create a private channel instead of a public one (optional)
     * @param name Name of the public or private channel to create (optional)
     * @return ApiResponse<ConversationsCreateSuccessSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun conversationsCreateWithHttpInfo(token: kotlin.String?, isPrivate: kotlin.Boolean?, name: kotlin.String?) : ApiResponse<ConversationsCreateSuccessSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = conversationsCreateRequestConfig(token = token, isPrivate = isPrivate, name = name)

        return@withContext request<Map<String, PartConfig<*>>, ConversationsCreateSuccessSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation conversationsCreate
     *
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param isPrivate Create a private channel instead of a public one (optional)
     * @param name Name of the public or private channel to create (optional)
     * @return RequestConfig
     */
    fun conversationsCreateRequestConfig(token: kotlin.String?, isPrivate: kotlin.Boolean?, name: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "is_private" to PartConfig(body = isPrivate, headers = mutableMapOf()),
            "name" to PartConfig(body = name, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token?.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/conversations.create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Fetches a conversation&#39;s history of messages and events.
     * @param token Authentication token. Requires scope: &#x60;conversations:history&#x60; (optional)
     * @param channel Conversation ID to fetch history for. (optional)
     * @param latest End of time range of messages to include in results. (optional)
     * @param oldest Start of time range of messages to include in results. (optional)
     * @param inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified. (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return ConversationsHistorySuccessSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun conversationsHistory(token: kotlin.String? = null, channel: kotlin.String? = null, latest: java.math.BigDecimal? = null, oldest: java.math.BigDecimal? = null, inclusive: kotlin.Boolean? = null, limit: kotlin.Int? = null, cursor: kotlin.String? = null) : ConversationsHistorySuccessSchema = withContext(Dispatchers.IO) {
        val localVarResponse = conversationsHistoryWithHttpInfo(token = token, channel = channel, latest = latest, oldest = oldest, inclusive = inclusive, limit = limit, cursor = cursor)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConversationsHistorySuccessSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Fetches a conversation&#39;s history of messages and events.
     * @param token Authentication token. Requires scope: &#x60;conversations:history&#x60; (optional)
     * @param channel Conversation ID to fetch history for. (optional)
     * @param latest End of time range of messages to include in results. (optional)
     * @param oldest Start of time range of messages to include in results. (optional)
     * @param inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified. (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return ApiResponse<ConversationsHistorySuccessSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun conversationsHistoryWithHttpInfo(token: kotlin.String?, channel: kotlin.String?, latest: java.math.BigDecimal?, oldest: java.math.BigDecimal?, inclusive: kotlin.Boolean?, limit: kotlin.Int?, cursor: kotlin.String?) : ApiResponse<ConversationsHistorySuccessSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = conversationsHistoryRequestConfig(token = token, channel = channel, latest = latest, oldest = oldest, inclusive = inclusive, limit = limit, cursor = cursor)

        return@withContext request<Unit, ConversationsHistorySuccessSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation conversationsHistory
     *
     * @param token Authentication token. Requires scope: &#x60;conversations:history&#x60; (optional)
     * @param channel Conversation ID to fetch history for. (optional)
     * @param latest End of time range of messages to include in results. (optional)
     * @param oldest Start of time range of messages to include in results. (optional)
     * @param inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified. (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return RequestConfig
     */
    fun conversationsHistoryRequestConfig(token: kotlin.String?, channel: kotlin.String?, latest: java.math.BigDecimal?, oldest: java.math.BigDecimal?, inclusive: kotlin.Boolean?, limit: kotlin.Int?, cursor: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (token != null) {
                    put("token", listOf(token.toString()))
                }
                if (channel != null) {
                    put("channel", listOf(channel.toString()))
                }
                if (latest != null) {
                    put("latest", listOf(latest.toString()))
                }
                if (oldest != null) {
                    put("oldest", listOf(oldest.toString()))
                }
                if (inclusive != null) {
                    put("inclusive", listOf(inclusive.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/conversations.history",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve information about a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
     * @param channel Conversation ID to learn more about (optional)
     * @param includeLocale Set this to &#x60;true&#x60; to receive the locale for this conversation. Defaults to &#x60;false&#x60; (optional)
     * @param includeNumMembers Set to &#x60;true&#x60; to include the member count for the specified conversation. Defaults to &#x60;false&#x60; (optional)
     * @return ConversationsInfoSuccessSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun conversationsInfo(token: kotlin.String? = null, channel: kotlin.String? = null, includeLocale: kotlin.Boolean? = null, includeNumMembers: kotlin.Boolean? = null) : ConversationsInfoSuccessSchema = withContext(Dispatchers.IO) {
        val localVarResponse = conversationsInfoWithHttpInfo(token = token, channel = channel, includeLocale = includeLocale, includeNumMembers = includeNumMembers)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConversationsInfoSuccessSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve information about a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
     * @param channel Conversation ID to learn more about (optional)
     * @param includeLocale Set this to &#x60;true&#x60; to receive the locale for this conversation. Defaults to &#x60;false&#x60; (optional)
     * @param includeNumMembers Set to &#x60;true&#x60; to include the member count for the specified conversation. Defaults to &#x60;false&#x60; (optional)
     * @return ApiResponse<ConversationsInfoSuccessSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun conversationsInfoWithHttpInfo(token: kotlin.String?, channel: kotlin.String?, includeLocale: kotlin.Boolean?, includeNumMembers: kotlin.Boolean?) : ApiResponse<ConversationsInfoSuccessSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = conversationsInfoRequestConfig(token = token, channel = channel, includeLocale = includeLocale, includeNumMembers = includeNumMembers)

        return@withContext request<Unit, ConversationsInfoSuccessSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation conversationsInfo
     *
     * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
     * @param channel Conversation ID to learn more about (optional)
     * @param includeLocale Set this to &#x60;true&#x60; to receive the locale for this conversation. Defaults to &#x60;false&#x60; (optional)
     * @param includeNumMembers Set to &#x60;true&#x60; to include the member count for the specified conversation. Defaults to &#x60;false&#x60; (optional)
     * @return RequestConfig
     */
    fun conversationsInfoRequestConfig(token: kotlin.String?, channel: kotlin.String?, includeLocale: kotlin.Boolean?, includeNumMembers: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (token != null) {
                    put("token", listOf(token.toString()))
                }
                if (channel != null) {
                    put("channel", listOf(channel.toString()))
                }
                if (includeLocale != null) {
                    put("include_locale", listOf(includeLocale.toString()))
                }
                if (includeNumMembers != null) {
                    put("include_num_members", listOf(includeNumMembers.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/conversations.info",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Invites users to a channel.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel The ID of the public or private channel to invite user(s) to. (optional)
     * @param users A comma separated list of user IDs. Up to 1000 users may be listed. (optional)
     * @return ConversationsInviteErrorSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun conversationsInvite(token: kotlin.String? = null, channel: kotlin.String? = null, users: kotlin.String? = null) : ConversationsInviteErrorSchema = withContext(Dispatchers.IO) {
        val localVarResponse = conversationsInviteWithHttpInfo(token = token, channel = channel, users = users)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConversationsInviteErrorSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Invites users to a channel.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel The ID of the public or private channel to invite user(s) to. (optional)
     * @param users A comma separated list of user IDs. Up to 1000 users may be listed. (optional)
     * @return ApiResponse<ConversationsInviteErrorSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun conversationsInviteWithHttpInfo(token: kotlin.String?, channel: kotlin.String?, users: kotlin.String?) : ApiResponse<ConversationsInviteErrorSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = conversationsInviteRequestConfig(token = token, channel = channel, users = users)

        return@withContext request<Map<String, PartConfig<*>>, ConversationsInviteErrorSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation conversationsInvite
     *
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel The ID of the public or private channel to invite user(s) to. (optional)
     * @param users A comma separated list of user IDs. Up to 1000 users may be listed. (optional)
     * @return RequestConfig
     */
    fun conversationsInviteRequestConfig(token: kotlin.String?, channel: kotlin.String?, users: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel" to PartConfig(body = channel, headers = mutableMapOf()),
            "users" to PartConfig(body = users, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token?.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/conversations.invite",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Joins an existing conversation.
     * @param token Authentication token. Requires scope: &#x60;channels:write&#x60; (optional)
     * @param channel ID of conversation to join (optional)
     * @return ConversationsJoinSuccessSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun conversationsJoin(token: kotlin.String? = null, channel: kotlin.String? = null) : ConversationsJoinSuccessSchema = withContext(Dispatchers.IO) {
        val localVarResponse = conversationsJoinWithHttpInfo(token = token, channel = channel)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConversationsJoinSuccessSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Joins an existing conversation.
     * @param token Authentication token. Requires scope: &#x60;channels:write&#x60; (optional)
     * @param channel ID of conversation to join (optional)
     * @return ApiResponse<ConversationsJoinSuccessSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun conversationsJoinWithHttpInfo(token: kotlin.String?, channel: kotlin.String?) : ApiResponse<ConversationsJoinSuccessSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = conversationsJoinRequestConfig(token = token, channel = channel)

        return@withContext request<Map<String, PartConfig<*>>, ConversationsJoinSuccessSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation conversationsJoin
     *
     * @param token Authentication token. Requires scope: &#x60;channels:write&#x60; (optional)
     * @param channel ID of conversation to join (optional)
     * @return RequestConfig
     */
    fun conversationsJoinRequestConfig(token: kotlin.String?, channel: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel" to PartConfig(body = channel, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token?.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/conversations.join",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Removes a user from a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to remove user from. (optional)
     * @param user User ID to be removed. (optional)
     * @return ConversationsKickSuccessSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun conversationsKick(token: kotlin.String? = null, channel: kotlin.String? = null, user: kotlin.String? = null) : ConversationsKickSuccessSchema = withContext(Dispatchers.IO) {
        val localVarResponse = conversationsKickWithHttpInfo(token = token, channel = channel, user = user)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConversationsKickSuccessSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Removes a user from a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to remove user from. (optional)
     * @param user User ID to be removed. (optional)
     * @return ApiResponse<ConversationsKickSuccessSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun conversationsKickWithHttpInfo(token: kotlin.String?, channel: kotlin.String?, user: kotlin.String?) : ApiResponse<ConversationsKickSuccessSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = conversationsKickRequestConfig(token = token, channel = channel, user = user)

        return@withContext request<Map<String, PartConfig<*>>, ConversationsKickSuccessSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation conversationsKick
     *
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to remove user from. (optional)
     * @param user User ID to be removed. (optional)
     * @return RequestConfig
     */
    fun conversationsKickRequestConfig(token: kotlin.String?, channel: kotlin.String?, user: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel" to PartConfig(body = channel, headers = mutableMapOf()),
            "user" to PartConfig(body = user, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token?.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/conversations.kick",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Leaves a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to leave (optional)
     * @return ConversationsLeaveSuccessSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun conversationsLeave(token: kotlin.String? = null, channel: kotlin.String? = null) : ConversationsLeaveSuccessSchema = withContext(Dispatchers.IO) {
        val localVarResponse = conversationsLeaveWithHttpInfo(token = token, channel = channel)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConversationsLeaveSuccessSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Leaves a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to leave (optional)
     * @return ApiResponse<ConversationsLeaveSuccessSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun conversationsLeaveWithHttpInfo(token: kotlin.String?, channel: kotlin.String?) : ApiResponse<ConversationsLeaveSuccessSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = conversationsLeaveRequestConfig(token = token, channel = channel)

        return@withContext request<Map<String, PartConfig<*>>, ConversationsLeaveSuccessSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation conversationsLeave
     *
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to leave (optional)
     * @return RequestConfig
     */
    fun conversationsLeaveRequestConfig(token: kotlin.String?, channel: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel" to PartConfig(body = channel, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token?.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/conversations.leave",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Lists all channels in a Slack team.
     * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
     * @param excludeArchived Set to &#x60;true&#x60; to exclude archived channels from the list (optional)
     * @param types Mix and match channel types by providing a comma-separated list of any combination of &#x60;public_channel&#x60;, &#x60;private_channel&#x60;, &#x60;mpim&#x60;, &#x60;im&#x60; (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn&#39;t been reached. Must be an integer no larger than 1000. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return ConversationsListSuccessSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun conversationsList(token: kotlin.String? = null, excludeArchived: kotlin.Boolean? = null, types: kotlin.String? = null, limit: kotlin.Int? = null, cursor: kotlin.String? = null) : ConversationsListSuccessSchema = withContext(Dispatchers.IO) {
        val localVarResponse = conversationsListWithHttpInfo(token = token, excludeArchived = excludeArchived, types = types, limit = limit, cursor = cursor)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConversationsListSuccessSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Lists all channels in a Slack team.
     * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
     * @param excludeArchived Set to &#x60;true&#x60; to exclude archived channels from the list (optional)
     * @param types Mix and match channel types by providing a comma-separated list of any combination of &#x60;public_channel&#x60;, &#x60;private_channel&#x60;, &#x60;mpim&#x60;, &#x60;im&#x60; (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn&#39;t been reached. Must be an integer no larger than 1000. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return ApiResponse<ConversationsListSuccessSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun conversationsListWithHttpInfo(token: kotlin.String?, excludeArchived: kotlin.Boolean?, types: kotlin.String?, limit: kotlin.Int?, cursor: kotlin.String?) : ApiResponse<ConversationsListSuccessSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = conversationsListRequestConfig(token = token, excludeArchived = excludeArchived, types = types, limit = limit, cursor = cursor)

        return@withContext request<Unit, ConversationsListSuccessSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation conversationsList
     *
     * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
     * @param excludeArchived Set to &#x60;true&#x60; to exclude archived channels from the list (optional)
     * @param types Mix and match channel types by providing a comma-separated list of any combination of &#x60;public_channel&#x60;, &#x60;private_channel&#x60;, &#x60;mpim&#x60;, &#x60;im&#x60; (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn&#39;t been reached. Must be an integer no larger than 1000. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return RequestConfig
     */
    fun conversationsListRequestConfig(token: kotlin.String?, excludeArchived: kotlin.Boolean?, types: kotlin.String?, limit: kotlin.Int?, cursor: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (token != null) {
                    put("token", listOf(token.toString()))
                }
                if (excludeArchived != null) {
                    put("exclude_archived", listOf(excludeArchived.toString()))
                }
                if (types != null) {
                    put("types", listOf(types.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/conversations.list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Sets the read cursor in a channel.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Channel or conversation to set the read cursor for. (optional)
     * @param ts Unique identifier of message you want marked as most recently seen in this conversation. (optional)
     * @return ConversationsMarkSuccessSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun conversationsMark(token: kotlin.String? = null, channel: kotlin.String? = null, ts: java.math.BigDecimal? = null) : ConversationsMarkSuccessSchema = withContext(Dispatchers.IO) {
        val localVarResponse = conversationsMarkWithHttpInfo(token = token, channel = channel, ts = ts)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConversationsMarkSuccessSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Sets the read cursor in a channel.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Channel or conversation to set the read cursor for. (optional)
     * @param ts Unique identifier of message you want marked as most recently seen in this conversation. (optional)
     * @return ApiResponse<ConversationsMarkSuccessSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun conversationsMarkWithHttpInfo(token: kotlin.String?, channel: kotlin.String?, ts: java.math.BigDecimal?) : ApiResponse<ConversationsMarkSuccessSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = conversationsMarkRequestConfig(token = token, channel = channel, ts = ts)

        return@withContext request<Map<String, PartConfig<*>>, ConversationsMarkSuccessSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation conversationsMark
     *
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Channel or conversation to set the read cursor for. (optional)
     * @param ts Unique identifier of message you want marked as most recently seen in this conversation. (optional)
     * @return RequestConfig
     */
    fun conversationsMarkRequestConfig(token: kotlin.String?, channel: kotlin.String?, ts: java.math.BigDecimal?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel" to PartConfig(body = channel, headers = mutableMapOf()),
            "ts" to PartConfig(body = ts, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token?.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/conversations.mark",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve members of a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
     * @param channel ID of the conversation to retrieve members for (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return ConversationsMembersSuccessSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun conversationsMembers(token: kotlin.String? = null, channel: kotlin.String? = null, limit: kotlin.Int? = null, cursor: kotlin.String? = null) : ConversationsMembersSuccessSchema = withContext(Dispatchers.IO) {
        val localVarResponse = conversationsMembersWithHttpInfo(token = token, channel = channel, limit = limit, cursor = cursor)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConversationsMembersSuccessSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve members of a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
     * @param channel ID of the conversation to retrieve members for (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return ApiResponse<ConversationsMembersSuccessSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun conversationsMembersWithHttpInfo(token: kotlin.String?, channel: kotlin.String?, limit: kotlin.Int?, cursor: kotlin.String?) : ApiResponse<ConversationsMembersSuccessSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = conversationsMembersRequestConfig(token = token, channel = channel, limit = limit, cursor = cursor)

        return@withContext request<Unit, ConversationsMembersSuccessSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation conversationsMembers
     *
     * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
     * @param channel ID of the conversation to retrieve members for (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return RequestConfig
     */
    fun conversationsMembersRequestConfig(token: kotlin.String?, channel: kotlin.String?, limit: kotlin.Int?, cursor: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (token != null) {
                    put("token", listOf(token.toString()))
                }
                if (channel != null) {
                    put("channel", listOf(channel.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/conversations.members",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Opens or resumes a direct message or multi-person direct message.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Resume a conversation by supplying an &#x60;im&#x60; or &#x60;mpim&#x60;&#39;s ID. Or provide the &#x60;users&#x60; field instead. (optional)
     * @param returnIm Boolean, indicates you want the full IM channel definition in the response. (optional)
     * @param users Comma separated lists of users. If only one user is included, this creates a 1:1 DM.  The ordering of the users is preserved whenever a multi-person direct message is returned. Supply a &#x60;channel&#x60; when not supplying &#x60;users&#x60;. (optional)
     * @return ConversationsOpenSuccessSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun conversationsOpen(token: kotlin.String? = null, channel: kotlin.String? = null, returnIm: kotlin.Boolean? = null, users: kotlin.String? = null) : ConversationsOpenSuccessSchema = withContext(Dispatchers.IO) {
        val localVarResponse = conversationsOpenWithHttpInfo(token = token, channel = channel, returnIm = returnIm, users = users)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConversationsOpenSuccessSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Opens or resumes a direct message or multi-person direct message.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Resume a conversation by supplying an &#x60;im&#x60; or &#x60;mpim&#x60;&#39;s ID. Or provide the &#x60;users&#x60; field instead. (optional)
     * @param returnIm Boolean, indicates you want the full IM channel definition in the response. (optional)
     * @param users Comma separated lists of users. If only one user is included, this creates a 1:1 DM.  The ordering of the users is preserved whenever a multi-person direct message is returned. Supply a &#x60;channel&#x60; when not supplying &#x60;users&#x60;. (optional)
     * @return ApiResponse<ConversationsOpenSuccessSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun conversationsOpenWithHttpInfo(token: kotlin.String?, channel: kotlin.String?, returnIm: kotlin.Boolean?, users: kotlin.String?) : ApiResponse<ConversationsOpenSuccessSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = conversationsOpenRequestConfig(token = token, channel = channel, returnIm = returnIm, users = users)

        return@withContext request<Map<String, PartConfig<*>>, ConversationsOpenSuccessSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation conversationsOpen
     *
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Resume a conversation by supplying an &#x60;im&#x60; or &#x60;mpim&#x60;&#39;s ID. Or provide the &#x60;users&#x60; field instead. (optional)
     * @param returnIm Boolean, indicates you want the full IM channel definition in the response. (optional)
     * @param users Comma separated lists of users. If only one user is included, this creates a 1:1 DM.  The ordering of the users is preserved whenever a multi-person direct message is returned. Supply a &#x60;channel&#x60; when not supplying &#x60;users&#x60;. (optional)
     * @return RequestConfig
     */
    fun conversationsOpenRequestConfig(token: kotlin.String?, channel: kotlin.String?, returnIm: kotlin.Boolean?, users: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel" to PartConfig(body = channel, headers = mutableMapOf()),
            "return_im" to PartConfig(body = returnIm, headers = mutableMapOf()),
            "users" to PartConfig(body = users, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token?.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/conversations.open",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Renames a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to rename (optional)
     * @param name New name for conversation. (optional)
     * @return ConversationsRenameSuccessSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun conversationsRename(token: kotlin.String? = null, channel: kotlin.String? = null, name: kotlin.String? = null) : ConversationsRenameSuccessSchema = withContext(Dispatchers.IO) {
        val localVarResponse = conversationsRenameWithHttpInfo(token = token, channel = channel, name = name)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConversationsRenameSuccessSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Renames a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to rename (optional)
     * @param name New name for conversation. (optional)
     * @return ApiResponse<ConversationsRenameSuccessSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun conversationsRenameWithHttpInfo(token: kotlin.String?, channel: kotlin.String?, name: kotlin.String?) : ApiResponse<ConversationsRenameSuccessSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = conversationsRenameRequestConfig(token = token, channel = channel, name = name)

        return@withContext request<Map<String, PartConfig<*>>, ConversationsRenameSuccessSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation conversationsRename
     *
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to rename (optional)
     * @param name New name for conversation. (optional)
     * @return RequestConfig
     */
    fun conversationsRenameRequestConfig(token: kotlin.String?, channel: kotlin.String?, name: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel" to PartConfig(body = channel, headers = mutableMapOf()),
            "name" to PartConfig(body = name, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token?.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/conversations.rename",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve a thread of messages posted to a conversation
     * @param token Authentication token. Requires scope: &#x60;conversations:history&#x60; (optional)
     * @param channel Conversation ID to fetch thread from. (optional)
     * @param ts Unique identifier of a thread&#39;s parent message. &#x60;ts&#x60; must be the timestamp of an existing message with 0 or more replies. If there are no replies then just the single message referenced by &#x60;ts&#x60; will return - it is just an ordinary, unthreaded message. (optional)
     * @param latest End of time range of messages to include in results. (optional)
     * @param oldest Start of time range of messages to include in results. (optional)
     * @param inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified. (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return ConversationsRepliesSuccessSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun conversationsReplies(token: kotlin.String? = null, channel: kotlin.String? = null, ts: java.math.BigDecimal? = null, latest: java.math.BigDecimal? = null, oldest: java.math.BigDecimal? = null, inclusive: kotlin.Boolean? = null, limit: kotlin.Int? = null, cursor: kotlin.String? = null) : ConversationsRepliesSuccessSchema = withContext(Dispatchers.IO) {
        val localVarResponse = conversationsRepliesWithHttpInfo(token = token, channel = channel, ts = ts, latest = latest, oldest = oldest, inclusive = inclusive, limit = limit, cursor = cursor)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConversationsRepliesSuccessSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve a thread of messages posted to a conversation
     * @param token Authentication token. Requires scope: &#x60;conversations:history&#x60; (optional)
     * @param channel Conversation ID to fetch thread from. (optional)
     * @param ts Unique identifier of a thread&#39;s parent message. &#x60;ts&#x60; must be the timestamp of an existing message with 0 or more replies. If there are no replies then just the single message referenced by &#x60;ts&#x60; will return - it is just an ordinary, unthreaded message. (optional)
     * @param latest End of time range of messages to include in results. (optional)
     * @param oldest Start of time range of messages to include in results. (optional)
     * @param inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified. (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return ApiResponse<ConversationsRepliesSuccessSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun conversationsRepliesWithHttpInfo(token: kotlin.String?, channel: kotlin.String?, ts: java.math.BigDecimal?, latest: java.math.BigDecimal?, oldest: java.math.BigDecimal?, inclusive: kotlin.Boolean?, limit: kotlin.Int?, cursor: kotlin.String?) : ApiResponse<ConversationsRepliesSuccessSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = conversationsRepliesRequestConfig(token = token, channel = channel, ts = ts, latest = latest, oldest = oldest, inclusive = inclusive, limit = limit, cursor = cursor)

        return@withContext request<Unit, ConversationsRepliesSuccessSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation conversationsReplies
     *
     * @param token Authentication token. Requires scope: &#x60;conversations:history&#x60; (optional)
     * @param channel Conversation ID to fetch thread from. (optional)
     * @param ts Unique identifier of a thread&#39;s parent message. &#x60;ts&#x60; must be the timestamp of an existing message with 0 or more replies. If there are no replies then just the single message referenced by &#x60;ts&#x60; will return - it is just an ordinary, unthreaded message. (optional)
     * @param latest End of time range of messages to include in results. (optional)
     * @param oldest Start of time range of messages to include in results. (optional)
     * @param inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified. (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return RequestConfig
     */
    fun conversationsRepliesRequestConfig(token: kotlin.String?, channel: kotlin.String?, ts: java.math.BigDecimal?, latest: java.math.BigDecimal?, oldest: java.math.BigDecimal?, inclusive: kotlin.Boolean?, limit: kotlin.Int?, cursor: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (token != null) {
                    put("token", listOf(token.toString()))
                }
                if (channel != null) {
                    put("channel", listOf(channel.toString()))
                }
                if (ts != null) {
                    put("ts", listOf(ts.toString()))
                }
                if (latest != null) {
                    put("latest", listOf(latest.toString()))
                }
                if (oldest != null) {
                    put("oldest", listOf(oldest.toString()))
                }
                if (inclusive != null) {
                    put("inclusive", listOf(inclusive.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/conversations.replies",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Sets the purpose for a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to set the purpose of (optional)
     * @param purpose A new, specialer purpose (optional)
     * @return ConversationsSetPurposeSuccessSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun conversationsSetPurpose(token: kotlin.String? = null, channel: kotlin.String? = null, purpose: kotlin.String? = null) : ConversationsSetPurposeSuccessSchema = withContext(Dispatchers.IO) {
        val localVarResponse = conversationsSetPurposeWithHttpInfo(token = token, channel = channel, purpose = purpose)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConversationsSetPurposeSuccessSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Sets the purpose for a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to set the purpose of (optional)
     * @param purpose A new, specialer purpose (optional)
     * @return ApiResponse<ConversationsSetPurposeSuccessSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun conversationsSetPurposeWithHttpInfo(token: kotlin.String?, channel: kotlin.String?, purpose: kotlin.String?) : ApiResponse<ConversationsSetPurposeSuccessSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = conversationsSetPurposeRequestConfig(token = token, channel = channel, purpose = purpose)

        return@withContext request<Map<String, PartConfig<*>>, ConversationsSetPurposeSuccessSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation conversationsSetPurpose
     *
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to set the purpose of (optional)
     * @param purpose A new, specialer purpose (optional)
     * @return RequestConfig
     */
    fun conversationsSetPurposeRequestConfig(token: kotlin.String?, channel: kotlin.String?, purpose: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel" to PartConfig(body = channel, headers = mutableMapOf()),
            "purpose" to PartConfig(body = purpose, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token?.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/conversations.setPurpose",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Sets the topic for a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to set the topic of (optional)
     * @param topic The new topic string. Does not support formatting or linkification. (optional)
     * @return ConversationsSetTopicSuccessSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun conversationsSetTopic(token: kotlin.String? = null, channel: kotlin.String? = null, topic: kotlin.String? = null) : ConversationsSetTopicSuccessSchema = withContext(Dispatchers.IO) {
        val localVarResponse = conversationsSetTopicWithHttpInfo(token = token, channel = channel, topic = topic)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConversationsSetTopicSuccessSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Sets the topic for a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to set the topic of (optional)
     * @param topic The new topic string. Does not support formatting or linkification. (optional)
     * @return ApiResponse<ConversationsSetTopicSuccessSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun conversationsSetTopicWithHttpInfo(token: kotlin.String?, channel: kotlin.String?, topic: kotlin.String?) : ApiResponse<ConversationsSetTopicSuccessSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = conversationsSetTopicRequestConfig(token = token, channel = channel, topic = topic)

        return@withContext request<Map<String, PartConfig<*>>, ConversationsSetTopicSuccessSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation conversationsSetTopic
     *
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to set the topic of (optional)
     * @param topic The new topic string. Does not support formatting or linkification. (optional)
     * @return RequestConfig
     */
    fun conversationsSetTopicRequestConfig(token: kotlin.String?, channel: kotlin.String?, topic: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel" to PartConfig(body = channel, headers = mutableMapOf()),
            "topic" to PartConfig(body = topic, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token?.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/conversations.setTopic",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Reverses conversation archival.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to unarchive (optional)
     * @return ConversationsUnarchiveSuccessSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun conversationsUnarchive(token: kotlin.String? = null, channel: kotlin.String? = null) : ConversationsUnarchiveSuccessSchema = withContext(Dispatchers.IO) {
        val localVarResponse = conversationsUnarchiveWithHttpInfo(token = token, channel = channel)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConversationsUnarchiveSuccessSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Reverses conversation archival.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to unarchive (optional)
     * @return ApiResponse<ConversationsUnarchiveSuccessSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun conversationsUnarchiveWithHttpInfo(token: kotlin.String?, channel: kotlin.String?) : ApiResponse<ConversationsUnarchiveSuccessSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = conversationsUnarchiveRequestConfig(token = token, channel = channel)

        return@withContext request<Map<String, PartConfig<*>>, ConversationsUnarchiveSuccessSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation conversationsUnarchive
     *
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to unarchive (optional)
     * @return RequestConfig
     */
    fun conversationsUnarchiveRequestConfig(token: kotlin.String?, channel: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "channel" to PartConfig(body = channel, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token?.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/conversations.unarchive",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
