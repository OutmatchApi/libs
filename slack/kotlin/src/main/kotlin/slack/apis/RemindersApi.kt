/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package slack.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.outmatchapi.slack.RemindersAddErrorSchema
import com.outmatchapi.slack.RemindersAddSchema
import com.outmatchapi.slack.RemindersCompleteErrorSchema
import com.outmatchapi.slack.RemindersCompleteSchema
import com.outmatchapi.slack.RemindersDeleteErrorSchema
import com.outmatchapi.slack.RemindersDeleteSchema
import com.outmatchapi.slack.RemindersInfoErrorSchema
import com.outmatchapi.slack.RemindersInfoSchema
import com.outmatchapi.slack.RemindersListErrorSchema
import com.outmatchapi.slack.RemindersListSchema

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import slack.infrastructure.ApiClient
import slack.infrastructure.ApiResponse
import slack.infrastructure.ClientException
import slack.infrastructure.ClientError
import slack.infrastructure.ServerException
import slack.infrastructure.ServerError
import slack.infrastructure.MultiValueMap
import slack.infrastructure.PartConfig
import slack.infrastructure.RequestConfig
import slack.infrastructure.RequestMethod
import slack.infrastructure.ResponseType
import slack.infrastructure.Success
import slack.infrastructure.toMultiValue

class RemindersApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://slack.com/api")
        }
    }

    /**
     * 
     * Creates a reminder.
     * @param token Authentication token. Requires scope: &#x60;reminders:write&#x60;
     * @param text The content of the reminder
     * @param time When this reminder should happen: the Unix timestamp (up to five years from now), the number of seconds until the reminder (if within 24 hours), or a natural language description (Ex. \\\&quot;in 15 minutes,\\\&quot; or \\\&quot;every Thursday\\\&quot;)
     * @param user The user who will receive the reminder. If no user is specified, the reminder will go to user who created it. (optional)
     * @return RemindersAddSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun remindersAdd(token: kotlin.String, text: kotlin.String, time: kotlin.String, user: kotlin.String? = null) : RemindersAddSchema = withContext(Dispatchers.IO) {
        val localVarResponse = remindersAddWithHttpInfo(token = token, text = text, time = time, user = user)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RemindersAddSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Creates a reminder.
     * @param token Authentication token. Requires scope: &#x60;reminders:write&#x60;
     * @param text The content of the reminder
     * @param time When this reminder should happen: the Unix timestamp (up to five years from now), the number of seconds until the reminder (if within 24 hours), or a natural language description (Ex. \\\&quot;in 15 minutes,\\\&quot; or \\\&quot;every Thursday\\\&quot;)
     * @param user The user who will receive the reminder. If no user is specified, the reminder will go to user who created it. (optional)
     * @return ApiResponse<RemindersAddSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun remindersAddWithHttpInfo(token: kotlin.String, text: kotlin.String, time: kotlin.String, user: kotlin.String?) : ApiResponse<RemindersAddSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = remindersAddRequestConfig(token = token, text = text, time = time, user = user)

        return@withContext request<Map<String, PartConfig<*>>, RemindersAddSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation remindersAdd
     *
     * @param token Authentication token. Requires scope: &#x60;reminders:write&#x60;
     * @param text The content of the reminder
     * @param time When this reminder should happen: the Unix timestamp (up to five years from now), the number of seconds until the reminder (if within 24 hours), or a natural language description (Ex. \\\&quot;in 15 minutes,\\\&quot; or \\\&quot;every Thursday\\\&quot;)
     * @param user The user who will receive the reminder. If no user is specified, the reminder will go to user who created it. (optional)
     * @return RequestConfig
     */
    fun remindersAddRequestConfig(token: kotlin.String, text: kotlin.String, time: kotlin.String, user: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "text" to PartConfig(body = text, headers = mutableMapOf()),
            "time" to PartConfig(body = time, headers = mutableMapOf()),
            "user" to PartConfig(body = user, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/reminders.add",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Marks a reminder as complete.
     * @param token Authentication token. Requires scope: &#x60;reminders:write&#x60; (optional)
     * @param reminder The ID of the reminder to be marked as complete (optional)
     * @return RemindersCompleteSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun remindersComplete(token: kotlin.String? = null, reminder: kotlin.String? = null) : RemindersCompleteSchema = withContext(Dispatchers.IO) {
        val localVarResponse = remindersCompleteWithHttpInfo(token = token, reminder = reminder)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RemindersCompleteSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Marks a reminder as complete.
     * @param token Authentication token. Requires scope: &#x60;reminders:write&#x60; (optional)
     * @param reminder The ID of the reminder to be marked as complete (optional)
     * @return ApiResponse<RemindersCompleteSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun remindersCompleteWithHttpInfo(token: kotlin.String?, reminder: kotlin.String?) : ApiResponse<RemindersCompleteSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = remindersCompleteRequestConfig(token = token, reminder = reminder)

        return@withContext request<Map<String, PartConfig<*>>, RemindersCompleteSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation remindersComplete
     *
     * @param token Authentication token. Requires scope: &#x60;reminders:write&#x60; (optional)
     * @param reminder The ID of the reminder to be marked as complete (optional)
     * @return RequestConfig
     */
    fun remindersCompleteRequestConfig(token: kotlin.String?, reminder: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "reminder" to PartConfig(body = reminder, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token?.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/reminders.complete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Deletes a reminder.
     * @param token Authentication token. Requires scope: &#x60;reminders:write&#x60; (optional)
     * @param reminder The ID of the reminder (optional)
     * @return RemindersDeleteSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun remindersDelete(token: kotlin.String? = null, reminder: kotlin.String? = null) : RemindersDeleteSchema = withContext(Dispatchers.IO) {
        val localVarResponse = remindersDeleteWithHttpInfo(token = token, reminder = reminder)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RemindersDeleteSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Deletes a reminder.
     * @param token Authentication token. Requires scope: &#x60;reminders:write&#x60; (optional)
     * @param reminder The ID of the reminder (optional)
     * @return ApiResponse<RemindersDeleteSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun remindersDeleteWithHttpInfo(token: kotlin.String?, reminder: kotlin.String?) : ApiResponse<RemindersDeleteSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = remindersDeleteRequestConfig(token = token, reminder = reminder)

        return@withContext request<Map<String, PartConfig<*>>, RemindersDeleteSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation remindersDelete
     *
     * @param token Authentication token. Requires scope: &#x60;reminders:write&#x60; (optional)
     * @param reminder The ID of the reminder (optional)
     * @return RequestConfig
     */
    fun remindersDeleteRequestConfig(token: kotlin.String?, reminder: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "reminder" to PartConfig(body = reminder, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        token?.apply { localVariableHeaders["token"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/reminders.delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Gets information about a reminder.
     * @param token Authentication token. Requires scope: &#x60;reminders:read&#x60; (optional)
     * @param reminder The ID of the reminder (optional)
     * @return RemindersInfoSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun remindersInfo(token: kotlin.String? = null, reminder: kotlin.String? = null) : RemindersInfoSchema = withContext(Dispatchers.IO) {
        val localVarResponse = remindersInfoWithHttpInfo(token = token, reminder = reminder)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RemindersInfoSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Gets information about a reminder.
     * @param token Authentication token. Requires scope: &#x60;reminders:read&#x60; (optional)
     * @param reminder The ID of the reminder (optional)
     * @return ApiResponse<RemindersInfoSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun remindersInfoWithHttpInfo(token: kotlin.String?, reminder: kotlin.String?) : ApiResponse<RemindersInfoSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = remindersInfoRequestConfig(token = token, reminder = reminder)

        return@withContext request<Unit, RemindersInfoSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation remindersInfo
     *
     * @param token Authentication token. Requires scope: &#x60;reminders:read&#x60; (optional)
     * @param reminder The ID of the reminder (optional)
     * @return RequestConfig
     */
    fun remindersInfoRequestConfig(token: kotlin.String?, reminder: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (token != null) {
                    put("token", listOf(token.toString()))
                }
                if (reminder != null) {
                    put("reminder", listOf(reminder.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/reminders.info",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Lists all reminders created by or for a given user.
     * @param token Authentication token. Requires scope: &#x60;reminders:read&#x60; (optional)
     * @return RemindersListSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun remindersList(token: kotlin.String? = null) : RemindersListSchema = withContext(Dispatchers.IO) {
        val localVarResponse = remindersListWithHttpInfo(token = token)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RemindersListSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Lists all reminders created by or for a given user.
     * @param token Authentication token. Requires scope: &#x60;reminders:read&#x60; (optional)
     * @return ApiResponse<RemindersListSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun remindersListWithHttpInfo(token: kotlin.String?) : ApiResponse<RemindersListSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = remindersListRequestConfig(token = token)

        return@withContext request<Unit, RemindersListSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation remindersList
     *
     * @param token Authentication token. Requires scope: &#x60;reminders:read&#x60; (optional)
     * @return RequestConfig
     */
    fun remindersListRequestConfig(token: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (token != null) {
                    put("token", listOf(token.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/reminders.list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
