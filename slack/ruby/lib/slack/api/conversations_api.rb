=begin
#Slack Web API

#One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.

The version of the OpenAPI document: 1.7.0

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 6.2.1

=end

require 'cgi'

module slack
  class ConversationsApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Archives a conversation.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel ID of conversation to archive
    # @return [ConversationsArchiveSuccessSchema]
    def conversations_archive(opts = {})
      data, _status_code, _headers = conversations_archive_with_http_info(opts)
      data
    end

    # Archives a conversation.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel ID of conversation to archive
    # @return [Array<(ConversationsArchiveSuccessSchema, Integer, Hash)>] ConversationsArchiveSuccessSchema data, response status code and response headers
    def conversations_archive_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConversationsApi.conversations_archive ...'
      end
      # resource path
      local_var_path = '/conversations.archive'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/x-www-form-urlencoded'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'token'] = opts[:'token'] if !opts[:'token'].nil?

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['channel'] = opts[:'channel'] if !opts[:'channel'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ConversationsArchiveSuccessSchema'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['slackAuth']

      new_options = opts.merge(
        :operation => :"ConversationsApi.conversations_archive",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConversationsApi#conversations_archive\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Closes a direct message or multi-person direct message.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel Conversation to close.
    # @return [ConversationsCloseSuccessSchema]
    def conversations_close(opts = {})
      data, _status_code, _headers = conversations_close_with_http_info(opts)
      data
    end

    # Closes a direct message or multi-person direct message.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel Conversation to close.
    # @return [Array<(ConversationsCloseSuccessSchema, Integer, Hash)>] ConversationsCloseSuccessSchema data, response status code and response headers
    def conversations_close_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConversationsApi.conversations_close ...'
      end
      # resource path
      local_var_path = '/conversations.close'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/x-www-form-urlencoded'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'token'] = opts[:'token'] if !opts[:'token'].nil?

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['channel'] = opts[:'channel'] if !opts[:'channel'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ConversationsCloseSuccessSchema'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['slackAuth']

      new_options = opts.merge(
        :operation => :"ConversationsApi.conversations_close",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConversationsApi#conversations_close\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Initiates a public or private channel-based conversation
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [Boolean] :is_private Create a private channel instead of a public one
    # @option opts [String] :name Name of the public or private channel to create
    # @return [ConversationsCreateSuccessSchema]
    def conversations_create(opts = {})
      data, _status_code, _headers = conversations_create_with_http_info(opts)
      data
    end

    # Initiates a public or private channel-based conversation
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [Boolean] :is_private Create a private channel instead of a public one
    # @option opts [String] :name Name of the public or private channel to create
    # @return [Array<(ConversationsCreateSuccessSchema, Integer, Hash)>] ConversationsCreateSuccessSchema data, response status code and response headers
    def conversations_create_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConversationsApi.conversations_create ...'
      end
      # resource path
      local_var_path = '/conversations.create'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/x-www-form-urlencoded'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'token'] = opts[:'token'] if !opts[:'token'].nil?

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['is_private'] = opts[:'is_private'] if !opts[:'is_private'].nil?
      form_params['name'] = opts[:'name'] if !opts[:'name'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ConversationsCreateSuccessSchema'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['slackAuth']

      new_options = opts.merge(
        :operation => :"ConversationsApi.conversations_create",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConversationsApi#conversations_create\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Fetches a conversation's history of messages and events.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:history&#x60;
    # @option opts [String] :channel Conversation ID to fetch history for.
    # @option opts [Float] :latest End of time range of messages to include in results.
    # @option opts [Float] :oldest Start of time range of messages to include in results.
    # @option opts [Boolean] :inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified.
    # @option opts [Integer] :limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached.
    # @option opts [String] :cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail.
    # @return [ConversationsHistorySuccessSchema]
    def conversations_history(opts = {})
      data, _status_code, _headers = conversations_history_with_http_info(opts)
      data
    end

    # Fetches a conversation&#39;s history of messages and events.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:history&#x60;
    # @option opts [String] :channel Conversation ID to fetch history for.
    # @option opts [Float] :latest End of time range of messages to include in results.
    # @option opts [Float] :oldest Start of time range of messages to include in results.
    # @option opts [Boolean] :inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified.
    # @option opts [Integer] :limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached.
    # @option opts [String] :cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail.
    # @return [Array<(ConversationsHistorySuccessSchema, Integer, Hash)>] ConversationsHistorySuccessSchema data, response status code and response headers
    def conversations_history_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConversationsApi.conversations_history ...'
      end
      # resource path
      local_var_path = '/conversations.history'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'token'] = opts[:'token'] if !opts[:'token'].nil?
      query_params[:'channel'] = opts[:'channel'] if !opts[:'channel'].nil?
      query_params[:'latest'] = opts[:'latest'] if !opts[:'latest'].nil?
      query_params[:'oldest'] = opts[:'oldest'] if !opts[:'oldest'].nil?
      query_params[:'inclusive'] = opts[:'inclusive'] if !opts[:'inclusive'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ConversationsHistorySuccessSchema'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['slackAuth']

      new_options = opts.merge(
        :operation => :"ConversationsApi.conversations_history",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConversationsApi#conversations_history\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve information about a conversation.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:read&#x60;
    # @option opts [String] :channel Conversation ID to learn more about
    # @option opts [Boolean] :include_locale Set this to &#x60;true&#x60; to receive the locale for this conversation. Defaults to &#x60;false&#x60;
    # @option opts [Boolean] :include_num_members Set to &#x60;true&#x60; to include the member count for the specified conversation. Defaults to &#x60;false&#x60;
    # @return [ConversationsInfoSuccessSchema]
    def conversations_info(opts = {})
      data, _status_code, _headers = conversations_info_with_http_info(opts)
      data
    end

    # Retrieve information about a conversation.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:read&#x60;
    # @option opts [String] :channel Conversation ID to learn more about
    # @option opts [Boolean] :include_locale Set this to &#x60;true&#x60; to receive the locale for this conversation. Defaults to &#x60;false&#x60;
    # @option opts [Boolean] :include_num_members Set to &#x60;true&#x60; to include the member count for the specified conversation. Defaults to &#x60;false&#x60;
    # @return [Array<(ConversationsInfoSuccessSchema, Integer, Hash)>] ConversationsInfoSuccessSchema data, response status code and response headers
    def conversations_info_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConversationsApi.conversations_info ...'
      end
      # resource path
      local_var_path = '/conversations.info'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'token'] = opts[:'token'] if !opts[:'token'].nil?
      query_params[:'channel'] = opts[:'channel'] if !opts[:'channel'].nil?
      query_params[:'include_locale'] = opts[:'include_locale'] if !opts[:'include_locale'].nil?
      query_params[:'include_num_members'] = opts[:'include_num_members'] if !opts[:'include_num_members'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ConversationsInfoSuccessSchema'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['slackAuth']

      new_options = opts.merge(
        :operation => :"ConversationsApi.conversations_info",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConversationsApi#conversations_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Invites users to a channel.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel The ID of the public or private channel to invite user(s) to.
    # @option opts [String] :users A comma separated list of user IDs. Up to 1000 users may be listed.
    # @return [ConversationsInviteErrorSchema]
    def conversations_invite(opts = {})
      data, _status_code, _headers = conversations_invite_with_http_info(opts)
      data
    end

    # Invites users to a channel.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel The ID of the public or private channel to invite user(s) to.
    # @option opts [String] :users A comma separated list of user IDs. Up to 1000 users may be listed.
    # @return [Array<(ConversationsInviteErrorSchema, Integer, Hash)>] ConversationsInviteErrorSchema data, response status code and response headers
    def conversations_invite_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConversationsApi.conversations_invite ...'
      end
      # resource path
      local_var_path = '/conversations.invite'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/x-www-form-urlencoded'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'token'] = opts[:'token'] if !opts[:'token'].nil?

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['channel'] = opts[:'channel'] if !opts[:'channel'].nil?
      form_params['users'] = opts[:'users'] if !opts[:'users'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ConversationsInviteErrorSchema'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['slackAuth']

      new_options = opts.merge(
        :operation => :"ConversationsApi.conversations_invite",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConversationsApi#conversations_invite\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Joins an existing conversation.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;channels:write&#x60;
    # @option opts [String] :channel ID of conversation to join
    # @return [ConversationsJoinSuccessSchema]
    def conversations_join(opts = {})
      data, _status_code, _headers = conversations_join_with_http_info(opts)
      data
    end

    # Joins an existing conversation.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;channels:write&#x60;
    # @option opts [String] :channel ID of conversation to join
    # @return [Array<(ConversationsJoinSuccessSchema, Integer, Hash)>] ConversationsJoinSuccessSchema data, response status code and response headers
    def conversations_join_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConversationsApi.conversations_join ...'
      end
      # resource path
      local_var_path = '/conversations.join'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/x-www-form-urlencoded'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'token'] = opts[:'token'] if !opts[:'token'].nil?

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['channel'] = opts[:'channel'] if !opts[:'channel'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ConversationsJoinSuccessSchema'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['slackAuth']

      new_options = opts.merge(
        :operation => :"ConversationsApi.conversations_join",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConversationsApi#conversations_join\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Removes a user from a conversation.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel ID of conversation to remove user from.
    # @option opts [String] :user User ID to be removed.
    # @return [ConversationsKickSuccessSchema]
    def conversations_kick(opts = {})
      data, _status_code, _headers = conversations_kick_with_http_info(opts)
      data
    end

    # Removes a user from a conversation.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel ID of conversation to remove user from.
    # @option opts [String] :user User ID to be removed.
    # @return [Array<(ConversationsKickSuccessSchema, Integer, Hash)>] ConversationsKickSuccessSchema data, response status code and response headers
    def conversations_kick_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConversationsApi.conversations_kick ...'
      end
      # resource path
      local_var_path = '/conversations.kick'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/x-www-form-urlencoded'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'token'] = opts[:'token'] if !opts[:'token'].nil?

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['channel'] = opts[:'channel'] if !opts[:'channel'].nil?
      form_params['user'] = opts[:'user'] if !opts[:'user'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ConversationsKickSuccessSchema'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['slackAuth']

      new_options = opts.merge(
        :operation => :"ConversationsApi.conversations_kick",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConversationsApi#conversations_kick\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Leaves a conversation.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel Conversation to leave
    # @return [ConversationsLeaveSuccessSchema]
    def conversations_leave(opts = {})
      data, _status_code, _headers = conversations_leave_with_http_info(opts)
      data
    end

    # Leaves a conversation.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel Conversation to leave
    # @return [Array<(ConversationsLeaveSuccessSchema, Integer, Hash)>] ConversationsLeaveSuccessSchema data, response status code and response headers
    def conversations_leave_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConversationsApi.conversations_leave ...'
      end
      # resource path
      local_var_path = '/conversations.leave'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/x-www-form-urlencoded'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'token'] = opts[:'token'] if !opts[:'token'].nil?

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['channel'] = opts[:'channel'] if !opts[:'channel'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ConversationsLeaveSuccessSchema'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['slackAuth']

      new_options = opts.merge(
        :operation => :"ConversationsApi.conversations_leave",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConversationsApi#conversations_leave\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Lists all channels in a Slack team.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:read&#x60;
    # @option opts [Boolean] :exclude_archived Set to &#x60;true&#x60; to exclude archived channels from the list
    # @option opts [String] :types Mix and match channel types by providing a comma-separated list of any combination of &#x60;public_channel&#x60;, &#x60;private_channel&#x60;, &#x60;mpim&#x60;, &#x60;im&#x60;
    # @option opts [Integer] :limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn&#39;t been reached. Must be an integer no larger than 1000.
    # @option opts [String] :cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail.
    # @return [ConversationsListSuccessSchema]
    def conversations_list(opts = {})
      data, _status_code, _headers = conversations_list_with_http_info(opts)
      data
    end

    # Lists all channels in a Slack team.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:read&#x60;
    # @option opts [Boolean] :exclude_archived Set to &#x60;true&#x60; to exclude archived channels from the list
    # @option opts [String] :types Mix and match channel types by providing a comma-separated list of any combination of &#x60;public_channel&#x60;, &#x60;private_channel&#x60;, &#x60;mpim&#x60;, &#x60;im&#x60;
    # @option opts [Integer] :limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn&#39;t been reached. Must be an integer no larger than 1000.
    # @option opts [String] :cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail.
    # @return [Array<(ConversationsListSuccessSchema, Integer, Hash)>] ConversationsListSuccessSchema data, response status code and response headers
    def conversations_list_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConversationsApi.conversations_list ...'
      end
      # resource path
      local_var_path = '/conversations.list'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'token'] = opts[:'token'] if !opts[:'token'].nil?
      query_params[:'exclude_archived'] = opts[:'exclude_archived'] if !opts[:'exclude_archived'].nil?
      query_params[:'types'] = opts[:'types'] if !opts[:'types'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ConversationsListSuccessSchema'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['slackAuth']

      new_options = opts.merge(
        :operation => :"ConversationsApi.conversations_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConversationsApi#conversations_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Sets the read cursor in a channel.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel Channel or conversation to set the read cursor for.
    # @option opts [Float] :ts Unique identifier of message you want marked as most recently seen in this conversation.
    # @return [ConversationsMarkSuccessSchema]
    def conversations_mark(opts = {})
      data, _status_code, _headers = conversations_mark_with_http_info(opts)
      data
    end

    # Sets the read cursor in a channel.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel Channel or conversation to set the read cursor for.
    # @option opts [Float] :ts Unique identifier of message you want marked as most recently seen in this conversation.
    # @return [Array<(ConversationsMarkSuccessSchema, Integer, Hash)>] ConversationsMarkSuccessSchema data, response status code and response headers
    def conversations_mark_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConversationsApi.conversations_mark ...'
      end
      # resource path
      local_var_path = '/conversations.mark'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/x-www-form-urlencoded'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'token'] = opts[:'token'] if !opts[:'token'].nil?

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['channel'] = opts[:'channel'] if !opts[:'channel'].nil?
      form_params['ts'] = opts[:'ts'] if !opts[:'ts'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ConversationsMarkSuccessSchema'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['slackAuth']

      new_options = opts.merge(
        :operation => :"ConversationsApi.conversations_mark",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConversationsApi#conversations_mark\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve members of a conversation.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:read&#x60;
    # @option opts [String] :channel ID of the conversation to retrieve members for
    # @option opts [Integer] :limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached.
    # @option opts [String] :cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail.
    # @return [ConversationsMembersSuccessSchema]
    def conversations_members(opts = {})
      data, _status_code, _headers = conversations_members_with_http_info(opts)
      data
    end

    # Retrieve members of a conversation.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:read&#x60;
    # @option opts [String] :channel ID of the conversation to retrieve members for
    # @option opts [Integer] :limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached.
    # @option opts [String] :cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail.
    # @return [Array<(ConversationsMembersSuccessSchema, Integer, Hash)>] ConversationsMembersSuccessSchema data, response status code and response headers
    def conversations_members_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConversationsApi.conversations_members ...'
      end
      # resource path
      local_var_path = '/conversations.members'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'token'] = opts[:'token'] if !opts[:'token'].nil?
      query_params[:'channel'] = opts[:'channel'] if !opts[:'channel'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ConversationsMembersSuccessSchema'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['slackAuth']

      new_options = opts.merge(
        :operation => :"ConversationsApi.conversations_members",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConversationsApi#conversations_members\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Opens or resumes a direct message or multi-person direct message.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel Resume a conversation by supplying an &#x60;im&#x60; or &#x60;mpim&#x60;&#39;s ID. Or provide the &#x60;users&#x60; field instead.
    # @option opts [Boolean] :return_im Boolean, indicates you want the full IM channel definition in the response.
    # @option opts [String] :users Comma separated lists of users. If only one user is included, this creates a 1:1 DM.  The ordering of the users is preserved whenever a multi-person direct message is returned. Supply a &#x60;channel&#x60; when not supplying &#x60;users&#x60;.
    # @return [ConversationsOpenSuccessSchema]
    def conversations_open(opts = {})
      data, _status_code, _headers = conversations_open_with_http_info(opts)
      data
    end

    # Opens or resumes a direct message or multi-person direct message.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel Resume a conversation by supplying an &#x60;im&#x60; or &#x60;mpim&#x60;&#39;s ID. Or provide the &#x60;users&#x60; field instead.
    # @option opts [Boolean] :return_im Boolean, indicates you want the full IM channel definition in the response.
    # @option opts [String] :users Comma separated lists of users. If only one user is included, this creates a 1:1 DM.  The ordering of the users is preserved whenever a multi-person direct message is returned. Supply a &#x60;channel&#x60; when not supplying &#x60;users&#x60;.
    # @return [Array<(ConversationsOpenSuccessSchema, Integer, Hash)>] ConversationsOpenSuccessSchema data, response status code and response headers
    def conversations_open_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConversationsApi.conversations_open ...'
      end
      # resource path
      local_var_path = '/conversations.open'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/x-www-form-urlencoded'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'token'] = opts[:'token'] if !opts[:'token'].nil?

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['channel'] = opts[:'channel'] if !opts[:'channel'].nil?
      form_params['return_im'] = opts[:'return_im'] if !opts[:'return_im'].nil?
      form_params['users'] = opts[:'users'] if !opts[:'users'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ConversationsOpenSuccessSchema'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['slackAuth']

      new_options = opts.merge(
        :operation => :"ConversationsApi.conversations_open",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConversationsApi#conversations_open\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Renames a conversation.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel ID of conversation to rename
    # @option opts [String] :name New name for conversation.
    # @return [ConversationsRenameSuccessSchema]
    def conversations_rename(opts = {})
      data, _status_code, _headers = conversations_rename_with_http_info(opts)
      data
    end

    # Renames a conversation.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel ID of conversation to rename
    # @option opts [String] :name New name for conversation.
    # @return [Array<(ConversationsRenameSuccessSchema, Integer, Hash)>] ConversationsRenameSuccessSchema data, response status code and response headers
    def conversations_rename_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConversationsApi.conversations_rename ...'
      end
      # resource path
      local_var_path = '/conversations.rename'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/x-www-form-urlencoded'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'token'] = opts[:'token'] if !opts[:'token'].nil?

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['channel'] = opts[:'channel'] if !opts[:'channel'].nil?
      form_params['name'] = opts[:'name'] if !opts[:'name'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ConversationsRenameSuccessSchema'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['slackAuth']

      new_options = opts.merge(
        :operation => :"ConversationsApi.conversations_rename",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConversationsApi#conversations_rename\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a thread of messages posted to a conversation
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:history&#x60;
    # @option opts [String] :channel Conversation ID to fetch thread from.
    # @option opts [Float] :ts Unique identifier of a thread&#39;s parent message. &#x60;ts&#x60; must be the timestamp of an existing message with 0 or more replies. If there are no replies then just the single message referenced by &#x60;ts&#x60; will return - it is just an ordinary, unthreaded message.
    # @option opts [Float] :latest End of time range of messages to include in results.
    # @option opts [Float] :oldest Start of time range of messages to include in results.
    # @option opts [Boolean] :inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified.
    # @option opts [Integer] :limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached.
    # @option opts [String] :cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail.
    # @return [ConversationsRepliesSuccessSchema]
    def conversations_replies(opts = {})
      data, _status_code, _headers = conversations_replies_with_http_info(opts)
      data
    end

    # Retrieve a thread of messages posted to a conversation
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:history&#x60;
    # @option opts [String] :channel Conversation ID to fetch thread from.
    # @option opts [Float] :ts Unique identifier of a thread&#39;s parent message. &#x60;ts&#x60; must be the timestamp of an existing message with 0 or more replies. If there are no replies then just the single message referenced by &#x60;ts&#x60; will return - it is just an ordinary, unthreaded message.
    # @option opts [Float] :latest End of time range of messages to include in results.
    # @option opts [Float] :oldest Start of time range of messages to include in results.
    # @option opts [Boolean] :inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified.
    # @option opts [Integer] :limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached.
    # @option opts [String] :cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail.
    # @return [Array<(ConversationsRepliesSuccessSchema, Integer, Hash)>] ConversationsRepliesSuccessSchema data, response status code and response headers
    def conversations_replies_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConversationsApi.conversations_replies ...'
      end
      # resource path
      local_var_path = '/conversations.replies'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'token'] = opts[:'token'] if !opts[:'token'].nil?
      query_params[:'channel'] = opts[:'channel'] if !opts[:'channel'].nil?
      query_params[:'ts'] = opts[:'ts'] if !opts[:'ts'].nil?
      query_params[:'latest'] = opts[:'latest'] if !opts[:'latest'].nil?
      query_params[:'oldest'] = opts[:'oldest'] if !opts[:'oldest'].nil?
      query_params[:'inclusive'] = opts[:'inclusive'] if !opts[:'inclusive'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ConversationsRepliesSuccessSchema'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['slackAuth']

      new_options = opts.merge(
        :operation => :"ConversationsApi.conversations_replies",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConversationsApi#conversations_replies\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Sets the purpose for a conversation.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel Conversation to set the purpose of
    # @option opts [String] :purpose A new, specialer purpose
    # @return [ConversationsSetPurposeSuccessSchema]
    def conversations_set_purpose(opts = {})
      data, _status_code, _headers = conversations_set_purpose_with_http_info(opts)
      data
    end

    # Sets the purpose for a conversation.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel Conversation to set the purpose of
    # @option opts [String] :purpose A new, specialer purpose
    # @return [Array<(ConversationsSetPurposeSuccessSchema, Integer, Hash)>] ConversationsSetPurposeSuccessSchema data, response status code and response headers
    def conversations_set_purpose_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConversationsApi.conversations_set_purpose ...'
      end
      # resource path
      local_var_path = '/conversations.setPurpose'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/x-www-form-urlencoded'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'token'] = opts[:'token'] if !opts[:'token'].nil?

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['channel'] = opts[:'channel'] if !opts[:'channel'].nil?
      form_params['purpose'] = opts[:'purpose'] if !opts[:'purpose'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ConversationsSetPurposeSuccessSchema'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['slackAuth']

      new_options = opts.merge(
        :operation => :"ConversationsApi.conversations_set_purpose",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConversationsApi#conversations_set_purpose\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Sets the topic for a conversation.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel Conversation to set the topic of
    # @option opts [String] :topic The new topic string. Does not support formatting or linkification.
    # @return [ConversationsSetTopicSuccessSchema]
    def conversations_set_topic(opts = {})
      data, _status_code, _headers = conversations_set_topic_with_http_info(opts)
      data
    end

    # Sets the topic for a conversation.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel Conversation to set the topic of
    # @option opts [String] :topic The new topic string. Does not support formatting or linkification.
    # @return [Array<(ConversationsSetTopicSuccessSchema, Integer, Hash)>] ConversationsSetTopicSuccessSchema data, response status code and response headers
    def conversations_set_topic_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConversationsApi.conversations_set_topic ...'
      end
      # resource path
      local_var_path = '/conversations.setTopic'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/x-www-form-urlencoded'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'token'] = opts[:'token'] if !opts[:'token'].nil?

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['channel'] = opts[:'channel'] if !opts[:'channel'].nil?
      form_params['topic'] = opts[:'topic'] if !opts[:'topic'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ConversationsSetTopicSuccessSchema'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['slackAuth']

      new_options = opts.merge(
        :operation => :"ConversationsApi.conversations_set_topic",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConversationsApi#conversations_set_topic\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Reverses conversation archival.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel ID of conversation to unarchive
    # @return [ConversationsUnarchiveSuccessSchema]
    def conversations_unarchive(opts = {})
      data, _status_code, _headers = conversations_unarchive_with_http_info(opts)
      data
    end

    # Reverses conversation archival.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :token Authentication token. Requires scope: &#x60;conversations:write&#x60;
    # @option opts [String] :channel ID of conversation to unarchive
    # @return [Array<(ConversationsUnarchiveSuccessSchema, Integer, Hash)>] ConversationsUnarchiveSuccessSchema data, response status code and response headers
    def conversations_unarchive_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ConversationsApi.conversations_unarchive ...'
      end
      # resource path
      local_var_path = '/conversations.unarchive'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/x-www-form-urlencoded'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'token'] = opts[:'token'] if !opts[:'token'].nil?

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['channel'] = opts[:'channel'] if !opts[:'channel'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ConversationsUnarchiveSuccessSchema'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['slackAuth']

      new_options = opts.merge(
        :operation => :"ConversationsApi.conversations_unarchive",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ConversationsApi#conversations_unarchive\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
