/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package apivideo.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.outmatchapi.apivideo.BadMinusRequest
import com.outmatchapi.apivideo.NotMinusFound
import com.outmatchapi.apivideo.TokenMinusCreateMinusPayload
import com.outmatchapi.apivideo.TokenMinusListMinusResponse
import com.outmatchapi.apivideo.UploadMinusToken
import com.outmatchapi.apivideo.Video

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import apivideo.infrastructure.ApiClient
import apivideo.infrastructure.ApiResponse
import apivideo.infrastructure.ClientException
import apivideo.infrastructure.ClientError
import apivideo.infrastructure.ServerException
import apivideo.infrastructure.ServerError
import apivideo.infrastructure.MultiValueMap
import apivideo.infrastructure.PartConfig
import apivideo.infrastructure.RequestConfig
import apivideo.infrastructure.RequestMethod
import apivideo.infrastructure.ResponseType
import apivideo.infrastructure.Success
import apivideo.infrastructure.toMultiValue

class VideosDelegatedUploadApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://ws.api.video")
        }
    }

    /**
     * Delete an upload token
     * Delete an existing upload token. This is especially useful for tokens you may have created that do not expire.
     * @param uploadToken The unique identifier for the upload token you want to delete. Deleting a token will make it so the token can no longer be used for authentication.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun dELETEUploadTokensUploadToken(uploadToken: kotlin.String) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = dELETEUploadTokensUploadTokenWithHttpInfo(uploadToken = uploadToken)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete an upload token
     * Delete an existing upload token. This is especially useful for tokens you may have created that do not expire.
     * @param uploadToken The unique identifier for the upload token you want to delete. Deleting a token will make it so the token can no longer be used for authentication.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun dELETEUploadTokensUploadTokenWithHttpInfo(uploadToken: kotlin.String) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = dELETEUploadTokensUploadTokenRequestConfig(uploadToken = uploadToken)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation dELETEUploadTokensUploadToken
     *
     * @param uploadToken The unique identifier for the upload token you want to delete. Deleting a token will make it so the token can no longer be used for authentication.
     * @return RequestConfig
     */
    fun dELETEUploadTokensUploadTokenRequestConfig(uploadToken: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/upload-tokens/{uploadToken}".replace("{"+"uploadToken"+"}", encodeURIComponent(uploadToken.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortBy
     */
     enum class SortBy_gETUploadTokens(val value: kotlin.String) {
         @Json(name = "createdAt") createdAt("createdAt"),
         @Json(name = "ttl") ttl("ttl")
     }

    /**
     * enum for parameter sortOrder
     */
     enum class SortOrder_gETUploadTokens(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc")
     }

    /**
     * List all active upload tokens.
     * A delegated token is used to allow secure uploads without exposing your API key. Use this endpoint to retrieve a list of all currently active delegated tokens. Tutorials using [delegated upload](https://api.video/blog/endpoints/delegated-upload).
     * @param sortBy Allowed: createdAt, ttl. You can use these to sort by when a token was created, or how much longer the token will be active (ttl - time to live). Date and time is presented in ISO-8601 format. (optional)
     * @param sortOrder Allowed: asc, desc. Ascending is 0-9 or A-Z. Descending is 9-0 or Z-A. (optional)
     * @param currentPage Choose the number of search results to return per page. Minimum value: 1 (optional, default to 1)
     * @param pageSize Results per page. Allowed values 1-100, default is 25. (optional, default to 25)
     * @return TokenMinusListMinusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun gETUploadTokens(sortBy: SortBy_gETUploadTokens? = null, sortOrder: SortOrder_gETUploadTokens? = null, currentPage: kotlin.Int? = 1, pageSize: kotlin.Int? = 25) : TokenMinusListMinusResponse = withContext(Dispatchers.IO) {
        val localVarResponse = gETUploadTokensWithHttpInfo(sortBy = sortBy, sortOrder = sortOrder, currentPage = currentPage, pageSize = pageSize)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TokenMinusListMinusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List all active upload tokens.
     * A delegated token is used to allow secure uploads without exposing your API key. Use this endpoint to retrieve a list of all currently active delegated tokens. Tutorials using [delegated upload](https://api.video/blog/endpoints/delegated-upload).
     * @param sortBy Allowed: createdAt, ttl. You can use these to sort by when a token was created, or how much longer the token will be active (ttl - time to live). Date and time is presented in ISO-8601 format. (optional)
     * @param sortOrder Allowed: asc, desc. Ascending is 0-9 or A-Z. Descending is 9-0 or Z-A. (optional)
     * @param currentPage Choose the number of search results to return per page. Minimum value: 1 (optional, default to 1)
     * @param pageSize Results per page. Allowed values 1-100, default is 25. (optional, default to 25)
     * @return ApiResponse<TokenMinusListMinusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun gETUploadTokensWithHttpInfo(sortBy: SortBy_gETUploadTokens?, sortOrder: SortOrder_gETUploadTokens?, currentPage: kotlin.Int?, pageSize: kotlin.Int?) : ApiResponse<TokenMinusListMinusResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = gETUploadTokensRequestConfig(sortBy = sortBy, sortOrder = sortOrder, currentPage = currentPage, pageSize = pageSize)

        return@withContext request<Unit, TokenMinusListMinusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation gETUploadTokens
     *
     * @param sortBy Allowed: createdAt, ttl. You can use these to sort by when a token was created, or how much longer the token will be active (ttl - time to live). Date and time is presented in ISO-8601 format. (optional)
     * @param sortOrder Allowed: asc, desc. Ascending is 0-9 or A-Z. Descending is 9-0 or Z-A. (optional)
     * @param currentPage Choose the number of search results to return per page. Minimum value: 1 (optional, default to 1)
     * @param pageSize Results per page. Allowed values 1-100, default is 25. (optional, default to 25)
     * @return RequestConfig
     */
    fun gETUploadTokensRequestConfig(sortBy: SortBy_gETUploadTokens?, sortOrder: SortOrder_gETUploadTokens?, currentPage: kotlin.Int?, pageSize: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (sortBy != null) {
                    put("sortBy", listOf(sortBy.toString()))
                }
                if (sortOrder != null) {
                    put("sortOrder", listOf(sortOrder.toString()))
                }
                if (currentPage != null) {
                    put("currentPage", listOf(currentPage.toString()))
                }
                if (pageSize != null) {
                    put("pageSize", listOf(pageSize.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/upload-tokens",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Show upload token
     * You can retrieve details about a specific upload token if you have the unique identifier for the upload token. Add it in the path of the endpoint. Details include time-to-live (ttl), when the token was created, and when it will expire.
     * @param uploadToken The unique identifier for the token you want information about.
     * @return UploadMinusToken
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun gETUploadTokensUploadToken(uploadToken: kotlin.String) : UploadMinusToken = withContext(Dispatchers.IO) {
        val localVarResponse = gETUploadTokensUploadTokenWithHttpInfo(uploadToken = uploadToken)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UploadMinusToken
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Show upload token
     * You can retrieve details about a specific upload token if you have the unique identifier for the upload token. Add it in the path of the endpoint. Details include time-to-live (ttl), when the token was created, and when it will expire.
     * @param uploadToken The unique identifier for the token you want information about.
     * @return ApiResponse<UploadMinusToken?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun gETUploadTokensUploadTokenWithHttpInfo(uploadToken: kotlin.String) : ApiResponse<UploadMinusToken?> = withContext(Dispatchers.IO) {
        val localVariableConfig = gETUploadTokensUploadTokenRequestConfig(uploadToken = uploadToken)

        return@withContext request<Unit, UploadMinusToken>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation gETUploadTokensUploadToken
     *
     * @param uploadToken The unique identifier for the token you want information about.
     * @return RequestConfig
     */
    fun gETUploadTokensUploadTokenRequestConfig(uploadToken: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/upload-tokens/{uploadToken}".replace("{"+"uploadToken"+"}", encodeURIComponent(uploadToken.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Upload with an upload token
     * When given a token, anyone can upload a file to the URI &#x60;https://ws.api.video/upload?token&#x3D;&lt;tokenId&gt;&#x60;.  Example with cURL:  &#x60;&#x60;&#x60;curl $ curl  --request POST --url &#39;https://ws.api.video/upload?token&#x3D;toXXX&#39;  --header &#39;content-type: multipart/form-data&#39;  -F file&#x3D;@video.mp4 &#x60;&#x60;&#x60;  Or in an HTML form, with a little JavaScript to convert the form into JSON: &#x60;&#x60;&#x60;html &lt;!--form for user interaction--&gt; &lt;form name&#x3D;\&quot;videoUploadForm\&quot; &gt;   &lt;label for&#x3D;video&gt;Video:&lt;/label&gt;   &lt;input type&#x3D;file name&#x3D;source/&gt;&lt;br/&gt;   &lt;input value&#x3D;\&quot;Submit\&quot; type&#x3D;\&quot;submit\&quot;&gt; &lt;/form&gt; &lt;div&gt;&lt;/div&gt; &lt;!--JS takes the form data      uses FormData to turn the response into JSON.     then uses POST to upload the video file.     Update the token parameter in the url to your upload token.     --&gt; &lt;script&gt;    var form &#x3D; document.forms.namedItem(\&quot;videoUploadForm\&quot;);     form.addEventListener(&#39;submit&#39;, function(ev) {   ev.preventDefault();      var oOutput &#x3D; document.querySelector(\&quot;div\&quot;),          oData &#x3D; new FormData(form);      var oReq &#x3D; new XMLHttpRequest();         oReq.open(\&quot;POST\&quot;, \&quot;https://ws.api.video/upload?token&#x3D;toXXX\&quot;, true);      oReq.send(oData);   oReq.onload &#x3D; function(oEvent) {        if (oReq.status &#x3D;&#x3D;201) {          oOutput.innerHTML &#x3D; \&quot;Your video is uploaded!&lt;br/&gt;\&quot;  + oReq.response;        } else {          oOutput.innerHTML &#x3D; \&quot;Error \&quot; + oReq.status + \&quot; occurred when trying to upload your file.&lt;br /&gt;\&quot;;        }      };    }, false);  &lt;/script&gt; &#x60;&#x60;&#x60;   ### Dealing with large files  We have created a &lt;a href&#x3D;&#39;https://api.video/blog/tutorials/uploading-large-files-with-javascript&#39;&gt;tutorial&lt;/a&gt; to walk through the steps required.
     * @param token The unique identifier for the token you want to use to upload a video.
     * @param file The path to the video you want to upload.
     * @param contentRange Content-Range represents the range of bytes that will be returned as a result of the request. Byte ranges are inclusive, meaning that bytes 0-999 represents the first 1000 bytes in a file or object. (optional)
     * @param videoId The video id returned by the first call to this endpoint in a large video upload scenario. (optional)
     * @return Video
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun pOSTUpload(token: kotlin.String, file: java.io.File, contentRange: kotlin.String? = null, videoId: kotlin.String? = null) : Video = withContext(Dispatchers.IO) {
        val localVarResponse = pOSTUploadWithHttpInfo(token = token, file = file, contentRange = contentRange, videoId = videoId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Video
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Upload with an upload token
     * When given a token, anyone can upload a file to the URI &#x60;https://ws.api.video/upload?token&#x3D;&lt;tokenId&gt;&#x60;.  Example with cURL:  &#x60;&#x60;&#x60;curl $ curl  --request POST --url &#39;https://ws.api.video/upload?token&#x3D;toXXX&#39;  --header &#39;content-type: multipart/form-data&#39;  -F file&#x3D;@video.mp4 &#x60;&#x60;&#x60;  Or in an HTML form, with a little JavaScript to convert the form into JSON: &#x60;&#x60;&#x60;html &lt;!--form for user interaction--&gt; &lt;form name&#x3D;\&quot;videoUploadForm\&quot; &gt;   &lt;label for&#x3D;video&gt;Video:&lt;/label&gt;   &lt;input type&#x3D;file name&#x3D;source/&gt;&lt;br/&gt;   &lt;input value&#x3D;\&quot;Submit\&quot; type&#x3D;\&quot;submit\&quot;&gt; &lt;/form&gt; &lt;div&gt;&lt;/div&gt; &lt;!--JS takes the form data      uses FormData to turn the response into JSON.     then uses POST to upload the video file.     Update the token parameter in the url to your upload token.     --&gt; &lt;script&gt;    var form &#x3D; document.forms.namedItem(\&quot;videoUploadForm\&quot;);     form.addEventListener(&#39;submit&#39;, function(ev) {   ev.preventDefault();      var oOutput &#x3D; document.querySelector(\&quot;div\&quot;),          oData &#x3D; new FormData(form);      var oReq &#x3D; new XMLHttpRequest();         oReq.open(\&quot;POST\&quot;, \&quot;https://ws.api.video/upload?token&#x3D;toXXX\&quot;, true);      oReq.send(oData);   oReq.onload &#x3D; function(oEvent) {        if (oReq.status &#x3D;&#x3D;201) {          oOutput.innerHTML &#x3D; \&quot;Your video is uploaded!&lt;br/&gt;\&quot;  + oReq.response;        } else {          oOutput.innerHTML &#x3D; \&quot;Error \&quot; + oReq.status + \&quot; occurred when trying to upload your file.&lt;br /&gt;\&quot;;        }      };    }, false);  &lt;/script&gt; &#x60;&#x60;&#x60;   ### Dealing with large files  We have created a &lt;a href&#x3D;&#39;https://api.video/blog/tutorials/uploading-large-files-with-javascript&#39;&gt;tutorial&lt;/a&gt; to walk through the steps required.
     * @param token The unique identifier for the token you want to use to upload a video.
     * @param file The path to the video you want to upload.
     * @param contentRange Content-Range represents the range of bytes that will be returned as a result of the request. Byte ranges are inclusive, meaning that bytes 0-999 represents the first 1000 bytes in a file or object. (optional)
     * @param videoId The video id returned by the first call to this endpoint in a large video upload scenario. (optional)
     * @return ApiResponse<Video?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun pOSTUploadWithHttpInfo(token: kotlin.String, file: java.io.File, contentRange: kotlin.String?, videoId: kotlin.String?) : ApiResponse<Video?> = withContext(Dispatchers.IO) {
        val localVariableConfig = pOSTUploadRequestConfig(token = token, file = file, contentRange = contentRange, videoId = videoId)

        return@withContext request<Map<String, PartConfig<*>>, Video>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation pOSTUpload
     *
     * @param token The unique identifier for the token you want to use to upload a video.
     * @param file The path to the video you want to upload.
     * @param contentRange Content-Range represents the range of bytes that will be returned as a result of the request. Byte ranges are inclusive, meaning that bytes 0-999 represents the first 1000 bytes in a file or object. (optional)
     * @param videoId The video id returned by the first call to this endpoint in a large video upload scenario. (optional)
     * @return RequestConfig
     */
    fun pOSTUploadRequestConfig(token: kotlin.String, file: java.io.File, contentRange: kotlin.String?, videoId: kotlin.String?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "file" to PartConfig(body = file, headers = mutableMapOf()),
            "videoId" to PartConfig(body = videoId, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        contentRange?.apply { localVariableHeaders["Content-Range"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/upload",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Generate an upload token
     * Use this endpoint to generate an upload token. You can use this token to authenticate video uploads while keeping your API key safe. Tutorials using [delegated upload](https://api.video/blog/endpoints/delegated-upload).
     * @param tokenMinusCreateMinusPayload  (optional)
     * @return UploadMinusToken
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun pOSTUploadTokens(tokenMinusCreateMinusPayload: TokenMinusCreateMinusPayload? = null) : UploadMinusToken = withContext(Dispatchers.IO) {
        val localVarResponse = pOSTUploadTokensWithHttpInfo(tokenMinusCreateMinusPayload = tokenMinusCreateMinusPayload)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UploadMinusToken
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Generate an upload token
     * Use this endpoint to generate an upload token. You can use this token to authenticate video uploads while keeping your API key safe. Tutorials using [delegated upload](https://api.video/blog/endpoints/delegated-upload).
     * @param tokenMinusCreateMinusPayload  (optional)
     * @return ApiResponse<UploadMinusToken?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun pOSTUploadTokensWithHttpInfo(tokenMinusCreateMinusPayload: TokenMinusCreateMinusPayload?) : ApiResponse<UploadMinusToken?> = withContext(Dispatchers.IO) {
        val localVariableConfig = pOSTUploadTokensRequestConfig(tokenMinusCreateMinusPayload = tokenMinusCreateMinusPayload)

        return@withContext request<TokenMinusCreateMinusPayload, UploadMinusToken>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation pOSTUploadTokens
     *
     * @param tokenMinusCreateMinusPayload  (optional)
     * @return RequestConfig
     */
    fun pOSTUploadTokensRequestConfig(tokenMinusCreateMinusPayload: TokenMinusCreateMinusPayload?) : RequestConfig<TokenMinusCreateMinusPayload> {
        val localVariableBody = tokenMinusCreateMinusPayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/upload-tokens",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
