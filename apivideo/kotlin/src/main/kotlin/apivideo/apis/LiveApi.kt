/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package apivideo.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.outmatchapi.apivideo.BadMinusRequest
import com.outmatchapi.apivideo.LiveMinusStream
import com.outmatchapi.apivideo.LiveMinusStreamMinusCreateMinusPayload
import com.outmatchapi.apivideo.LiveMinusStreamMinusListMinusResponse
import com.outmatchapi.apivideo.LiveMinusStreamMinusUpdateMinusPayload
import com.outmatchapi.apivideo.NotMinusFound

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import apivideo.infrastructure.ApiClient
import apivideo.infrastructure.ApiResponse
import apivideo.infrastructure.ClientException
import apivideo.infrastructure.ClientError
import apivideo.infrastructure.ServerException
import apivideo.infrastructure.ServerError
import apivideo.infrastructure.MultiValueMap
import apivideo.infrastructure.PartConfig
import apivideo.infrastructure.RequestConfig
import apivideo.infrastructure.RequestMethod
import apivideo.infrastructure.ResponseType
import apivideo.infrastructure.Success
import apivideo.infrastructure.toMultiValue

class LiveApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://ws.api.video")
        }
    }

    /**
     * Delete a live stream
     * 
     * @param liveStreamId The unique ID for the live stream that you want to remove.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun dELETELiveStreamsLiveStreamId(liveStreamId: kotlin.String) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = dELETELiveStreamsLiveStreamIdWithHttpInfo(liveStreamId = liveStreamId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete a live stream
     * 
     * @param liveStreamId The unique ID for the live stream that you want to remove.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun dELETELiveStreamsLiveStreamIdWithHttpInfo(liveStreamId: kotlin.String) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = dELETELiveStreamsLiveStreamIdRequestConfig(liveStreamId = liveStreamId)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation dELETELiveStreamsLiveStreamId
     *
     * @param liveStreamId The unique ID for the live stream that you want to remove.
     * @return RequestConfig
     */
    fun dELETELiveStreamsLiveStreamIdRequestConfig(liveStreamId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/live-streams/{liveStreamId}".replace("{"+"liveStreamId"+"}", encodeURIComponent(liveStreamId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Delete a thumbnail
     * Send the unique identifier for a live stream to delete it from the system.
     * @param liveStreamId The unique identifier for the live stream you want to delete. 
     * @return LiveMinusStream
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun dELETELiveStreamsLiveStreamIdThumbnail(liveStreamId: kotlin.String) : LiveMinusStream = withContext(Dispatchers.IO) {
        val localVarResponse = dELETELiveStreamsLiveStreamIdThumbnailWithHttpInfo(liveStreamId = liveStreamId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LiveMinusStream
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete a thumbnail
     * Send the unique identifier for a live stream to delete it from the system.
     * @param liveStreamId The unique identifier for the live stream you want to delete. 
     * @return ApiResponse<LiveMinusStream?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun dELETELiveStreamsLiveStreamIdThumbnailWithHttpInfo(liveStreamId: kotlin.String) : ApiResponse<LiveMinusStream?> = withContext(Dispatchers.IO) {
        val localVariableConfig = dELETELiveStreamsLiveStreamIdThumbnailRequestConfig(liveStreamId = liveStreamId)

        return@withContext request<Unit, LiveMinusStream>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation dELETELiveStreamsLiveStreamIdThumbnail
     *
     * @param liveStreamId The unique identifier for the live stream you want to delete. 
     * @return RequestConfig
     */
    fun dELETELiveStreamsLiveStreamIdThumbnailRequestConfig(liveStreamId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/live-streams/{liveStreamId}/thumbnail".replace("{"+"liveStreamId"+"}", encodeURIComponent(liveStreamId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortOrder
     */
     enum class SortOrder_gETLiveStreams(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc")
     }

    /**
     * List all live streams
     * With no parameters added to the url, this will return all livestreams. Query by name or key to limit the list.
     * @param streamKey The unique stream key that allows you to stream videos. (optional)
     * @param name You can filter live streams by their name or a part of their name. (optional)
     * @param sortBy Allowed: createdAt, publishedAt, name. createdAt - the time a livestream was created using the specified streamKey. publishedAt - the time a livestream was published using the specified streamKey. name - the name of the livestream. If you choose one of the time based options, the time is presented in ISO-8601 format. (optional)
     * @param sortOrder Allowed: asc, desc. Ascending for date and time means that earlier values precede later ones. Descending means that later values preced earlier ones. For title, it is 0-9 and A-Z ascending and Z-A, 9-0 descending. (optional)
     * @param currentPage Choose the number of search results to return per page. Minimum value: 1 (optional, default to 1)
     * @param pageSize Results per page. Allowed values 1-100, default is 25. (optional, default to 25)
     * @return LiveMinusStreamMinusListMinusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun gETLiveStreams(streamKey: kotlin.String? = null, name: kotlin.String? = null, sortBy: kotlin.String? = null, sortOrder: SortOrder_gETLiveStreams? = null, currentPage: kotlin.Int? = 1, pageSize: kotlin.Int? = 25) : LiveMinusStreamMinusListMinusResponse = withContext(Dispatchers.IO) {
        val localVarResponse = gETLiveStreamsWithHttpInfo(streamKey = streamKey, name = name, sortBy = sortBy, sortOrder = sortOrder, currentPage = currentPage, pageSize = pageSize)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LiveMinusStreamMinusListMinusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List all live streams
     * With no parameters added to the url, this will return all livestreams. Query by name or key to limit the list.
     * @param streamKey The unique stream key that allows you to stream videos. (optional)
     * @param name You can filter live streams by their name or a part of their name. (optional)
     * @param sortBy Allowed: createdAt, publishedAt, name. createdAt - the time a livestream was created using the specified streamKey. publishedAt - the time a livestream was published using the specified streamKey. name - the name of the livestream. If you choose one of the time based options, the time is presented in ISO-8601 format. (optional)
     * @param sortOrder Allowed: asc, desc. Ascending for date and time means that earlier values precede later ones. Descending means that later values preced earlier ones. For title, it is 0-9 and A-Z ascending and Z-A, 9-0 descending. (optional)
     * @param currentPage Choose the number of search results to return per page. Minimum value: 1 (optional, default to 1)
     * @param pageSize Results per page. Allowed values 1-100, default is 25. (optional, default to 25)
     * @return ApiResponse<LiveMinusStreamMinusListMinusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun gETLiveStreamsWithHttpInfo(streamKey: kotlin.String?, name: kotlin.String?, sortBy: kotlin.String?, sortOrder: SortOrder_gETLiveStreams?, currentPage: kotlin.Int?, pageSize: kotlin.Int?) : ApiResponse<LiveMinusStreamMinusListMinusResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = gETLiveStreamsRequestConfig(streamKey = streamKey, name = name, sortBy = sortBy, sortOrder = sortOrder, currentPage = currentPage, pageSize = pageSize)

        return@withContext request<Unit, LiveMinusStreamMinusListMinusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation gETLiveStreams
     *
     * @param streamKey The unique stream key that allows you to stream videos. (optional)
     * @param name You can filter live streams by their name or a part of their name. (optional)
     * @param sortBy Allowed: createdAt, publishedAt, name. createdAt - the time a livestream was created using the specified streamKey. publishedAt - the time a livestream was published using the specified streamKey. name - the name of the livestream. If you choose one of the time based options, the time is presented in ISO-8601 format. (optional)
     * @param sortOrder Allowed: asc, desc. Ascending for date and time means that earlier values precede later ones. Descending means that later values preced earlier ones. For title, it is 0-9 and A-Z ascending and Z-A, 9-0 descending. (optional)
     * @param currentPage Choose the number of search results to return per page. Minimum value: 1 (optional, default to 1)
     * @param pageSize Results per page. Allowed values 1-100, default is 25. (optional, default to 25)
     * @return RequestConfig
     */
    fun gETLiveStreamsRequestConfig(streamKey: kotlin.String?, name: kotlin.String?, sortBy: kotlin.String?, sortOrder: SortOrder_gETLiveStreams?, currentPage: kotlin.Int?, pageSize: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (streamKey != null) {
                    put("streamKey", listOf(streamKey.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (sortBy != null) {
                    put("sortBy", listOf(sortBy.toString()))
                }
                if (sortOrder != null) {
                    put("sortOrder", listOf(sortOrder.toString()))
                }
                if (currentPage != null) {
                    put("currentPage", listOf(currentPage.toString()))
                }
                if (pageSize != null) {
                    put("pageSize", listOf(pageSize.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/live-streams",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Show live stream
     * Supply a LivestreamId, and you&#39;ll get all the details for streaming into, and watching the livestream. Tutorials that use the [show livestream endpoint](https://api.video/blog/endpoints/live-stream-status).
     * @param liveStreamId The unique ID for the live stream you want to watch.
     * @return LiveMinusStream
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun gETLiveStreamsLiveStreamId(liveStreamId: kotlin.String) : LiveMinusStream = withContext(Dispatchers.IO) {
        val localVarResponse = gETLiveStreamsLiveStreamIdWithHttpInfo(liveStreamId = liveStreamId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LiveMinusStream
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Show live stream
     * Supply a LivestreamId, and you&#39;ll get all the details for streaming into, and watching the livestream. Tutorials that use the [show livestream endpoint](https://api.video/blog/endpoints/live-stream-status).
     * @param liveStreamId The unique ID for the live stream you want to watch.
     * @return ApiResponse<LiveMinusStream?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun gETLiveStreamsLiveStreamIdWithHttpInfo(liveStreamId: kotlin.String) : ApiResponse<LiveMinusStream?> = withContext(Dispatchers.IO) {
        val localVariableConfig = gETLiveStreamsLiveStreamIdRequestConfig(liveStreamId = liveStreamId)

        return@withContext request<Unit, LiveMinusStream>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation gETLiveStreamsLiveStreamId
     *
     * @param liveStreamId The unique ID for the live stream you want to watch.
     * @return RequestConfig
     */
    fun gETLiveStreamsLiveStreamIdRequestConfig(liveStreamId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/live-streams/{liveStreamId}".replace("{"+"liveStreamId"+"}", encodeURIComponent(liveStreamId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Update a live stream
     * Use this endpoint to update the player, or to turn recording on/off (saving a copy of the livestream). NOTE: If the livestream is actively streaming, changing the recording status will only affect the NEXT stream.    The public&#x3D;false &#39;private livestream&#39; is available as a BETA feature, and should be limited to livestreams of 3,000 viewers or fewer.
     * @param liveStreamId The unique ID for the live stream that you want to update information for such as player details, or whether you want the recording on or off.
     * @param liveMinusStreamMinusUpdateMinusPayload  (optional)
     * @return LiveMinusStream
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun pATCHLiveStreamsLiveStreamId(liveStreamId: kotlin.String, liveMinusStreamMinusUpdateMinusPayload: LiveMinusStreamMinusUpdateMinusPayload? = null) : LiveMinusStream = withContext(Dispatchers.IO) {
        val localVarResponse = pATCHLiveStreamsLiveStreamIdWithHttpInfo(liveStreamId = liveStreamId, liveMinusStreamMinusUpdateMinusPayload = liveMinusStreamMinusUpdateMinusPayload)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LiveMinusStream
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update a live stream
     * Use this endpoint to update the player, or to turn recording on/off (saving a copy of the livestream). NOTE: If the livestream is actively streaming, changing the recording status will only affect the NEXT stream.    The public&#x3D;false &#39;private livestream&#39; is available as a BETA feature, and should be limited to livestreams of 3,000 viewers or fewer.
     * @param liveStreamId The unique ID for the live stream that you want to update information for such as player details, or whether you want the recording on or off.
     * @param liveMinusStreamMinusUpdateMinusPayload  (optional)
     * @return ApiResponse<LiveMinusStream?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun pATCHLiveStreamsLiveStreamIdWithHttpInfo(liveStreamId: kotlin.String, liveMinusStreamMinusUpdateMinusPayload: LiveMinusStreamMinusUpdateMinusPayload?) : ApiResponse<LiveMinusStream?> = withContext(Dispatchers.IO) {
        val localVariableConfig = pATCHLiveStreamsLiveStreamIdRequestConfig(liveStreamId = liveStreamId, liveMinusStreamMinusUpdateMinusPayload = liveMinusStreamMinusUpdateMinusPayload)

        return@withContext request<LiveMinusStreamMinusUpdateMinusPayload, LiveMinusStream>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation pATCHLiveStreamsLiveStreamId
     *
     * @param liveStreamId The unique ID for the live stream that you want to update information for such as player details, or whether you want the recording on or off.
     * @param liveMinusStreamMinusUpdateMinusPayload  (optional)
     * @return RequestConfig
     */
    fun pATCHLiveStreamsLiveStreamIdRequestConfig(liveStreamId: kotlin.String, liveMinusStreamMinusUpdateMinusPayload: LiveMinusStreamMinusUpdateMinusPayload?) : RequestConfig<LiveMinusStreamMinusUpdateMinusPayload> {
        val localVariableBody = liveMinusStreamMinusUpdateMinusPayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/live-streams/{liveStreamId}".replace("{"+"liveStreamId"+"}", encodeURIComponent(liveStreamId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Create live stream
     * A live stream will give you the &#39;connection point&#39; to RTMP your video stream to api.video. It will also give you the details for viewers to watch the same livestream.  The public&#x3D;false &#39;private livestream&#39; is available as a BETA feature, and should be limited to livestreams of 3,000 viewers or fewer. See our [Live Stream Tutorial](https://api.video/blog/tutorials/live-stream-tutorial) for a walkthrough of this API with OBS. Your RTMP endpoint for the livestream is rtmp://broadcast.api.video/s/{streamKey} Tutorials that [create live streams](https://api.video/blog/endpoints/live-create).
     * @param liveMinusStreamMinusCreateMinusPayload  (optional)
     * @return LiveMinusStream
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun pOSTLiveStreams(liveMinusStreamMinusCreateMinusPayload: LiveMinusStreamMinusCreateMinusPayload? = null) : LiveMinusStream = withContext(Dispatchers.IO) {
        val localVarResponse = pOSTLiveStreamsWithHttpInfo(liveMinusStreamMinusCreateMinusPayload = liveMinusStreamMinusCreateMinusPayload)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LiveMinusStream
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create live stream
     * A live stream will give you the &#39;connection point&#39; to RTMP your video stream to api.video. It will also give you the details for viewers to watch the same livestream.  The public&#x3D;false &#39;private livestream&#39; is available as a BETA feature, and should be limited to livestreams of 3,000 viewers or fewer. See our [Live Stream Tutorial](https://api.video/blog/tutorials/live-stream-tutorial) for a walkthrough of this API with OBS. Your RTMP endpoint for the livestream is rtmp://broadcast.api.video/s/{streamKey} Tutorials that [create live streams](https://api.video/blog/endpoints/live-create).
     * @param liveMinusStreamMinusCreateMinusPayload  (optional)
     * @return ApiResponse<LiveMinusStream?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun pOSTLiveStreamsWithHttpInfo(liveMinusStreamMinusCreateMinusPayload: LiveMinusStreamMinusCreateMinusPayload?) : ApiResponse<LiveMinusStream?> = withContext(Dispatchers.IO) {
        val localVariableConfig = pOSTLiveStreamsRequestConfig(liveMinusStreamMinusCreateMinusPayload = liveMinusStreamMinusCreateMinusPayload)

        return@withContext request<LiveMinusStreamMinusCreateMinusPayload, LiveMinusStream>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation pOSTLiveStreams
     *
     * @param liveMinusStreamMinusCreateMinusPayload  (optional)
     * @return RequestConfig
     */
    fun pOSTLiveStreamsRequestConfig(liveMinusStreamMinusCreateMinusPayload: LiveMinusStreamMinusCreateMinusPayload?) : RequestConfig<LiveMinusStreamMinusCreateMinusPayload> {
        val localVariableBody = liveMinusStreamMinusCreateMinusPayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/live-streams",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Upload a thumbnail
     * Upload an image to use as a backdrop for your livestream. Tutorials that [update live stream thumbnails](https://api.video/blog/endpoints/live-upload-a-thumbnail).
     * @param liveStreamId The unique ID for the live stream you want to upload.
     * @param file The image to be added as a thumbnail.
     * @return LiveMinusStream
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun pOSTLiveStreamsLiveStreamIdThumbnail(liveStreamId: kotlin.String, file: java.io.File) : LiveMinusStream = withContext(Dispatchers.IO) {
        val localVarResponse = pOSTLiveStreamsLiveStreamIdThumbnailWithHttpInfo(liveStreamId = liveStreamId, file = file)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LiveMinusStream
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Upload a thumbnail
     * Upload an image to use as a backdrop for your livestream. Tutorials that [update live stream thumbnails](https://api.video/blog/endpoints/live-upload-a-thumbnail).
     * @param liveStreamId The unique ID for the live stream you want to upload.
     * @param file The image to be added as a thumbnail.
     * @return ApiResponse<LiveMinusStream?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun pOSTLiveStreamsLiveStreamIdThumbnailWithHttpInfo(liveStreamId: kotlin.String, file: java.io.File) : ApiResponse<LiveMinusStream?> = withContext(Dispatchers.IO) {
        val localVariableConfig = pOSTLiveStreamsLiveStreamIdThumbnailRequestConfig(liveStreamId = liveStreamId, file = file)

        return@withContext request<Map<String, PartConfig<*>>, LiveMinusStream>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation pOSTLiveStreamsLiveStreamIdThumbnail
     *
     * @param liveStreamId The unique ID for the live stream you want to upload.
     * @param file The image to be added as a thumbnail.
     * @return RequestConfig
     */
    fun pOSTLiveStreamsLiveStreamIdThumbnailRequestConfig(liveStreamId: kotlin.String, file: java.io.File) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "file" to PartConfig(body = file, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/live-streams/{liveStreamId}/thumbnail".replace("{"+"liveStreamId"+"}", encodeURIComponent(liveStreamId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
