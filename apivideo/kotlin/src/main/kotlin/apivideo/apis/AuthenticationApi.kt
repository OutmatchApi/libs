/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package apivideo.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.outmatchapi.apivideo.AccessMinusToken
import com.outmatchapi.apivideo.AuthenticateMinusPayload
import com.outmatchapi.apivideo.BadMinusRequest
import com.outmatchapi.apivideo.RefreshMinusTokenMinusPayload

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import apivideo.infrastructure.ApiClient
import apivideo.infrastructure.ApiResponse
import apivideo.infrastructure.ClientException
import apivideo.infrastructure.ClientError
import apivideo.infrastructure.ServerException
import apivideo.infrastructure.ServerError
import apivideo.infrastructure.MultiValueMap
import apivideo.infrastructure.PartConfig
import apivideo.infrastructure.RequestConfig
import apivideo.infrastructure.RequestMethod
import apivideo.infrastructure.ResponseType
import apivideo.infrastructure.Success
import apivideo.infrastructure.toMultiValue

class AuthenticationApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://ws.api.video")
        }
    }

    /**
     * Authenticate
     * To get started, submit your API key in the body of your request. api.video returns an access token that is valid for one hour (3600 seconds). A refresh token is also returned. View a [tutorial](https://api.video/blog/tutorials/authentication-tutorial) on authentication. All tutorials using the [authentication endpoint](https://api.video/blog/endpoints/authenticate)
     * @param authenticateMinusPayload  (optional)
     * @return AccessMinusToken
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun pOSTAuthApiKey(authenticateMinusPayload: AuthenticateMinusPayload? = null) : AccessMinusToken = withContext(Dispatchers.IO) {
        val localVarResponse = pOSTAuthApiKeyWithHttpInfo(authenticateMinusPayload = authenticateMinusPayload)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccessMinusToken
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Authenticate
     * To get started, submit your API key in the body of your request. api.video returns an access token that is valid for one hour (3600 seconds). A refresh token is also returned. View a [tutorial](https://api.video/blog/tutorials/authentication-tutorial) on authentication. All tutorials using the [authentication endpoint](https://api.video/blog/endpoints/authenticate)
     * @param authenticateMinusPayload  (optional)
     * @return ApiResponse<AccessMinusToken?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun pOSTAuthApiKeyWithHttpInfo(authenticateMinusPayload: AuthenticateMinusPayload?) : ApiResponse<AccessMinusToken?> = withContext(Dispatchers.IO) {
        val localVariableConfig = pOSTAuthApiKeyRequestConfig(authenticateMinusPayload = authenticateMinusPayload)

        return@withContext request<AuthenticateMinusPayload, AccessMinusToken>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation pOSTAuthApiKey
     *
     * @param authenticateMinusPayload  (optional)
     * @return RequestConfig
     */
    fun pOSTAuthApiKeyRequestConfig(authenticateMinusPayload: AuthenticateMinusPayload?) : RequestConfig<AuthenticateMinusPayload> {
        val localVariableBody = authenticateMinusPayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/auth/api-key",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Refresh token
     * Use the refresh endpoint with the refresh token you received when you first authenticated using the api-key endpoint. Send the refresh token in the body of your request. The api.video API returns a new access token that is valid for one hour (3600 seconds) and a new refresh token.  
     * @param refreshMinusTokenMinusPayload  (optional)
     * @return AccessMinusToken
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun pOSTAuthRefresh(refreshMinusTokenMinusPayload: RefreshMinusTokenMinusPayload? = null) : AccessMinusToken = withContext(Dispatchers.IO) {
        val localVarResponse = pOSTAuthRefreshWithHttpInfo(refreshMinusTokenMinusPayload = refreshMinusTokenMinusPayload)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccessMinusToken
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Refresh token
     * Use the refresh endpoint with the refresh token you received when you first authenticated using the api-key endpoint. Send the refresh token in the body of your request. The api.video API returns a new access token that is valid for one hour (3600 seconds) and a new refresh token.  
     * @param refreshMinusTokenMinusPayload  (optional)
     * @return ApiResponse<AccessMinusToken?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun pOSTAuthRefreshWithHttpInfo(refreshMinusTokenMinusPayload: RefreshMinusTokenMinusPayload?) : ApiResponse<AccessMinusToken?> = withContext(Dispatchers.IO) {
        val localVariableConfig = pOSTAuthRefreshRequestConfig(refreshMinusTokenMinusPayload = refreshMinusTokenMinusPayload)

        return@withContext request<RefreshMinusTokenMinusPayload, AccessMinusToken>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation pOSTAuthRefresh
     *
     * @param refreshMinusTokenMinusPayload  (optional)
     * @return RequestConfig
     */
    fun pOSTAuthRefreshRequestConfig(refreshMinusTokenMinusPayload: RefreshMinusTokenMinusPayload?) : RequestConfig<RefreshMinusTokenMinusPayload> {
        val localVariableBody = refreshMinusTokenMinusPayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/auth/refresh",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
